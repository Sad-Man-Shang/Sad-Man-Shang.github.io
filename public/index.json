[{"categories":["开源工作"],"content":" 模版项目申请书分为三个部分，技术方案、时间规划、项目经历 技术方案 1.请记住，技术方案越详细越有利于项目导师的理解和认可 ; 2.在技术方案中，学生应该重点展示出自己对开源项目的理解程度，可以从以下几点入手:根据自己的理解和前期项目学习储备来拆解目标开源项目，尽可能描述各个模块的功能:重点对项目发布的任务或需求进行分析，体现自己的思考和思路;具体描述自己的技术方案，比如自己的方案将会添加哪些模块，以及这些模块如何与现有模块通信 3.最好能为自己的方案找到一些可执行的依据，包括但不限于 :其他项目的成功经验; 论文等提供的理论依据 ","date":"2023-07-12","objectID":"/inlong/:0:0","series":["开源初探"],"tags":["开源","大数据","数据集成"],"title":"Inlong","uri":"/inlong/#模版"},{"categories":["开源工作"],"content":" Inlong一站式数据集成框架，将不同数据源的数据汇集（批量集成和实时集成）到目标端。 ","date":"2023-07-12","objectID":"/inlong/:0:0","series":["开源初探"],"tags":["开源","大数据","数据集成"],"title":"Inlong","uri":"/inlong/#inlong"},{"categories":["开源工作"],"content":" 架构![image-20230713005256473](/Users/shengquan/Library/Application Support/typora-user-images/image-20230713005256473.png) 数据链路 采集层：从各个数据源采集对应的数据，Agent 汇聚层：接收采集层的数据进行统一编码，做协议转换，大量的链接进行收敛，将采集层的数据进行统一处理，并且上报给缓存层，DataProxy 缓存层：MQ服务，支持TubeMQ，Pulsar，Kafka 分拣层：Sort on Flink，通过业务配置的流向，分拣到具体的服务当中；Sort standalone，非Flink版本； 需要自定义消费逻辑的时候，使用SDK进行消费；对接自己的离线/实时计算。 ","date":"2023-07-12","objectID":"/inlong/:1:0","series":["开源初探"],"tags":["开源","大数据","数据集成"],"title":"Inlong","uri":"/inlong/#架构"},{"categories":["开源工作"],"content":" 组件![image-20230713010058964](/Users/shengquan/Library/Application Support/typora-user-images/image-20230713010058964.png) ","date":"2023-07-12","objectID":"/inlong/:2:0","series":["开源初探"],"tags":["开源","大数据","数据集成"],"title":"Inlong","uri":"/inlong/#组件"},{"categories":["开源工作"],"content":" Demo![image-20230713010729918](/Users/shengquan/Library/Application Support/typora-user-images/image-20230713010729918.png) ","date":"2023-07-12","objectID":"/inlong/:3:0","series":["开源初探"],"tags":["开源","大数据","数据集成"],"title":"Inlong","uri":"/inlong/#demo"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List\u003cString\u003e generateParenthesis(int n) { List\u003cString\u003e res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List\u003cString\u003e res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable\u003cStatus\u003e { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue\u003cStatus\u003e queue = new PriorityQueue\u003cStatus\u003e(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#1-两数之和httpsleetcodecnproblemstwo-sum"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#2-两数相加httpsleetcodecnproblemsadd-two-numbers"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#3-无重复字符的最长子串httpsleetcodecnproblemslongest-substring-without-repeating-characters"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#4-寻找两个正序数组的中位数httpsleetcodecnproblemsmedian-of-two-sorted-arrays"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#5-最长回文子串httpsleetcodecnproblemslongest-palindromic-substring"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#10-正则表达式匹配httpsleetcodecnproblemsregular-expression-matching"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#11-盛最多水的容器httpsleetcodecnproblemscontainer-with-most-water"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#15-三数之和httpsleetcodecnproblems3sum"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#17-电话号码的字母组合httpsleetcodecnproblemsletter-combinations-of-a-phone-number"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#19-删除链表的倒数第-n-个结点httpsleetcodecnproblemsremove-nth-node-from-end-of-list"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#20-有效的括号httpsleetcodecnproblemsvalid-parentheses"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#21-合并两个有序链表httpsleetcodecnproblemsmerge-two-sorted-lists"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#22-括号生成httpsleetcodecnproblemsgenerate-parentheses"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#23-合并-k-个升序链表httpsleetcodecnproblemsmerge-k-sorted-lists"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#31-下一个排列httpsleetcodecnproblemsnext-permutation"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#32-最长有效括号httpsleetcodecnproblemslongest-valid-parentheses"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#33-搜索旋转排序数组httpsleetcodecnproblemssearch-in-rotated-sorted-array"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#34-在排序数组中查找元素的第一个和最后一个位置httpsleetcodecnproblemsfind-first-and-last-position-of-element-in-sorted-array"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#39-组合总和httpsleetcodecnproblemscombination-sum"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#42-接雨水httpsleetcodecnproblemstrapping-rain-water"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#46-全排列httpsleetcodecnproblemspermutations"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#48-旋转图像httpsleetcodecnproblemsrotate-image"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#49-字母异位词分组httpsleetcodecnproblemsgroup-anagrams"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#53-最大子数组和httpsleetcodecnproblemsmaximum-subarray"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#55-跳跃游戏httpsleetcodecnproblemsjump-game"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#56-合并区间httpsleetcodecnproblemsmerge-intervals"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#62-不同路径httpsleetcodecnproblemsunique-paths"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#64-最小路径和httpsleetcodecnproblemsminimum-path-sum"},{"categories":["操作系统"],"content":"haha ha abcdefg haha ","date":"2023-07-10","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:0:0","series":["24届从零开始到找到工作"],"tags":["面试"],"title":"操作系统","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#"}]