[{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 ","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 ","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#1-两数之和httpsleetcodecnproblemstwo-sum"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 ","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#2-两数相加httpsleetcodecnproblemsadd-two-numbers"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 ","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#3-无重复字符的最长子串httpsleetcodecnproblemslongest-substring-without-repeating-characters"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 ","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#4-寻找两个正序数组的中位数httpsleetcodecnproblemsmedian-of-two-sorted-arrays"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 ","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#5-最长回文子串httpsleetcodecnproblemslongest-palindromic-substring"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 ","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#10-正则表达式匹配httpsleetcodecnproblemsregular-expression-matching"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 ","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#11-盛最多水的容器httpsleetcodecnproblemscontainer-with-most-water"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 ","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["24届从零开始到找到工作"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#15-三数之和httpsleetcodecnproblems3sum"},{"categories":["操作系统"],"content":"haha ha abcdefg haha ","date":"2023-07-10","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:0:0","series":["24届从零开始到找到工作"],"tags":["面试"],"title":"操作系统","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#"}]