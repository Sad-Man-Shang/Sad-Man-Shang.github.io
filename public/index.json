[{"categories":null,"content":" volatile","date":"2023-12-07","objectID":"/%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/:0:0","series":null,"tags":null,"title":"并发之volatile","uri":"/%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/#volatile"},{"categories":null,"content":" brief围绕两句话展开：保证可见性、禁止指令冲排序。 volatile，保证所有线程看到这个变量的值是一致的。 为什么会不一致？因为多级缓存（L1、L2、L3），如果读到了，可以直接返回，所以读多写少的话性能很好。 缓存命中（读缓存行）、写命中（写缓存行） ","date":"2023-12-07","objectID":"/%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/:1:0","series":null,"tags":null,"title":"并发之volatile","uri":"/%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/#brief"},{"categories":null,"content":" 可见性实现机制对于volatile写操作，在汇编层面添加lock前缀的指令，做两件事1.缓存行写回内存；2.其他缓存行无效 lock，锁总线，先进的处理器会锁内存区域，改哪里锁哪里，并且使用缓存一致性协议阻止多处理器同时修改缓存。 其他处理器嗅探查看自己的缓存是否过期，如果过期，则自己的缓存行无效。 为此引出了一个volatile用法优化，有了一个相关的优化思路，比如如果有一个双向队列，要频繁的出队入队。强行padding到64字节，为了保证头尾节点不会被一起加载进缓存行，修改时不会互相锁定。（优化要求：频繁写，64字节的缓存行） 进而有一个神奇的注解，那就是@sun.misc.Contended 伪共享问题出现在以下场景： 多个核心（或线程）在同一时间读写不同的变量。 这些变量恰好位于同一个缓存行上。 当一个核心修改它所在缓存行上的一个变量时，整个缓存行都被标记为无效。 因此，其他核心在访问它们各自的变量时，需要从主内存重新加载整个缓存行，即使它们并没有真正共享任何数据。 而被@sun.misc.Contended标记的字段，会被填充到一个缓存行大小，避免伪共享。 ","date":"2023-12-07","objectID":"/%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/:2:0","series":null,"tags":null,"title":"并发之volatile","uri":"/%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/#可见性实现机制"},{"categories":null,"content":" 禁止指令重冲排序下面是基于保守策略的JMM内存屏障插入策略。· 在每个volatile写操作的前面插入一个StoreStore屏障，写volatile前其他写已经完成（完成指刷入主存） 在每个volatile写操作的后面插入一个StoreLoad屏障，写volatile后，修改可见（不是在volatile前面加内存屏障，因为volatile常见使用是单写+多线程读volatile，所以要在单后加而不是多前加） 在每个volatile读操作的后面插入一个LoadLoad屏障，读volatile后，再读其他的 在每个volatile读操作的后面插入一个LoadStore屏障，读volatile后，再写其他的 而new一个对象是写啊，会加上storestore以及storeload屏障，所以 非保守策略：按需求省略四个屏障中的几个 为什么是volatile和其他？ // 2341和1234会产生不同的结果i== 0 || 1 class VolatileExample { int a=0; volatile boolean flag = false; public void writer() { a = 1;//1 flag = true;// 2 public void reader () { if (flag) {//3 int i = a;//4 } } 写前不能冲排序，读后不能冲排序，写读不能重排序 ·当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。 ·当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。 ·当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。 volatile的禁止指令重排序使用：双重检查锁。（为什么要双重检查？sychronized下推因为避免频繁的获得锁。为什么要用volatile？禁止指令重排序。 ps：双重检查锁之外，还有静态内部类，这里使用的是类加载的初始化期间，获得Class对象初始化的锁的线程进行创建对象。 ","date":"2023-12-07","objectID":"/%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/:3:0","series":null,"tags":null,"title":"并发之volatile","uri":"/%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/#禁止指令重冲排序"},{"categories":["乱语"],"content":"tcp的三次握手：我爱你，我爱你，我们在一起吧，我们在一起吧。 tcp四次挥手：我们分手吧，我同意分手，但是我还有点想说的话XXXXXX，好的我知道了再见。 **线程的并发在观测结果上看就像双缝干涉实验：**某一个瞬间只有一个光子，某一瞬间只有一个线程在cpu执行。但是去看结果，又好像很多光，好像很多线程被同时执行。 计算机领域的常见问题 数据存在多个副本：一致性问题 锁的效率问题：粒度优化 两种实现方式各有利弊：remix一下 ","date":"2023-09-14","objectID":"/%E4%B8%80%E4%BA%9B%E4%B8%8D%E6%81%B0%E5%BD%93%E6%AF%94%E5%96%BB/:0:0","series":["看看时间都浪费在哪里了"],"tags":[],"title":"一些不恰当比喻","uri":"/%E4%B8%80%E4%BA%9B%E4%B8%8D%E6%81%B0%E5%BD%93%E6%AF%94%E5%96%BB/#"},{"categories":[],"content":" 阿里控股 1关于如何学习java JUC中的两个类：ThreadLocal、AQS 源码讲解：Spring bean初始化流程、AOP JVM的gc redis的数据结构？为什么支持高并发？zset的底层是什么？如何判断热key？项目中哪里用到了redis？ 如何保证rabbitMQ的顺序消费？rabbitmq就是一个queue啊！？只需要只有一个消费者就可以了。模型是什么？所有消息队列都是生产消费模型，不过面试官真正想问的是rabbitmq有哪些部分组成，生产者、消费者、交换机、队列、broker。 OAuth2.0的授权流程？ MySQL的索引有哪些？为什么不用B+树？ Canal的原理是什么？ 场景题：一个部门有子部门，子部门还有子部门，如何实现快速查询一个部门有哪些子部门？可以优化的思路有：java代码优化、sql优化、缓存优化、表设计优化 点赞相关的表如何设计？ ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#阿里控股-1"},{"categories":[],"content":" 阿里控股 2项目询问 mysql索引结构 sql语句执行流程 如何进行分页 缓存雪崩是什么？如何解决？ rabbitmq的原理 消息积压如何解决？ ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#阿里控股-2"},{"categories":[],"content":" 阿里控股3项目拷打 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#阿里控股3"},{"categories":[],"content":" 美团 1美团一面 raft角色有哪些，职责是什么？ raft日志同步的流程 redis支持的数据类型 zset的使用场景 redis如何加锁？ 缓存雪崩解决方式 StringBuilder和String的区别 重写hashcode、equals的使用场景 LinkedHashMap如何保证有序性？ ConcurrentHashMap如何保证线程安全？ volatile关键字解决了什么问题？可以保证原子性吗？ synchronized和lock的区别 synchronized可以被中断吗？ 乐观锁的实现方式 CAS 类加载流程、委派双亲机制、能不能加载java.long.Object类？ 堆内存和栈内存存了什么？ 堆内存溢出以及栈溢出的常见原因 覆盖索引使用举例、为什么效率高？ MySQL主从同步机制 索引失效的场景 手撕归并排序 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#美团-1"},{"categories":[],"content":" 美团 2经历拷问 项目难点 手撕循环打印 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#美团-2"},{"categories":[],"content":" 美团 捞1","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#美团-捞1"},{"categories":[],"content":" 美团 捞2","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#美团-捞2"},{"categories":[],"content":" TX qqIOS1个人介绍 spring源码看了多少？ mybatis从编码到查询数据库到返回结果的全过程 如果查询时间较长是什么原因？如何解决？ mysql和redis数据不一致如何处理？ tcp四次挥手 http几个版本 https的加密过程 手撕：2题，一个回文判断，一个反转整数 最近看过什么开源项目？具体看的哪一部分？ 消息队列的使用场景？了解哪个消息队列？具体说说？ 项目中为什么要使用gRPC？ 了解其他的语言吗？ linux如何查看cpu使用情况？ 进程间通信方式 1亿个无序数字找出最大的1000个 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#tx-qqios1"},{"categories":[],"content":" TX qqIOS2gc、 什么是内存泄漏、 synchronized底层原理 闲聊一会接一个手撕目标和为k的子数组个数 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#tx-qqios2"},{"categories":[],"content":" TX wd1个人介绍 spring源码看了多少？ mybatis从编码到查询数据库到返回结果的全过程 如果查询时间较长是什么原因？如何解决？ mysql和redis数据不一致如何处理？ tcp四次挥手 http几个版本 https的加密过程 手撕：2题，一个回文判断，一个反转整数 最近看过什么开源项目？具体看的哪一部分？ 消息队列的使用场景？了解哪个消息队列？具体说说？ 项目中为什么要使用gRPC？ 了解其他的语言吗？ linux如何查看cpu使用情况？ 进程间通信方式 1亿个无序数字找出最大的1000个 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#tx-wd1"},{"categories":[],"content":" TX wxg1大数相加 前k大 tcp三次握手 HashMap、ConcurrentHashMap 项目中难点 智力题：1000杯水一瓶毒药，喝了一小时会死，可以无限稀释。有十只小老鼠一小时找到毒药 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#tx-wxg1"},{"categories":[],"content":" TX wxg2锁 java内存共享 项目中难点 手撕 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#tx-wxg2"},{"categories":[],"content":" TX wxg3一个点是否在一个图形内？算法思路，如何优化？ 手撕：3结点最小公公祖先 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#tx-wxg3"},{"categories":[],"content":" DW 1springcloud的服务发现，nacos的作用？ 如何判断服务掉线？ 心跳信号的实现方式？定时任务（线程池 or 阻塞队列 负载均衡有哪些类型？ 讲讲一致性哈希使用场景？数据风暴就是啊，怎么没想起来啊可恶 用户表、商品表，保存用户对商品的关注关系，如何处理？为什么不是加一个fk？ 有一个读用户关注的品牌列表接口，如何提高接口性能？索引+多级缓存 如何处理用户取关？包括表和缓存，以及java中如何实现？表，加一列是否关注，缓存，根据具体情况双删或者canal+rabbitmq同步 如果表需要频繁的修改，如何提高写性能？ 首先要充分使用mysql的innodb存储引擎的特性，比如合并io，比如刷新邻接页 考虑水平拆分表？但是这个操作太重了，并且表拆分之后想合并 读写分离，降低数据库要处理的读请求，为写请求让出资源 在这之后，我在犹豫之中说了一个自认为离谱的操作，异步操作，比如写入消息队列，没想到面试官说这种思想才是最常见的。 我说起线程，面试官说起线程耗资源，我说用线程池。使用java自带的CompletableFuture 讲讲线程池参数，来的线程会被拒绝还是进入队列 在主线程中起一个线程，让它去执行任务，2秒内要得到结果，两秒后，无论结果怎么样，这个线程都要结束如何实现？使用Feature的get(long timeout, TimeUnit unit) ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#dw-1"},{"categories":[],"content":" HHXX 1讲一下canal 如何保证mysql到canal到rabbitmq的消息不会丢失？ Q：用户恶意频繁请求验证码如何解决？ 前端限制请求次数 后端统计请求次数 速率限制 ip屏蔽 速率限制： 在触发发送验证代码的端点上实施速率限制。 验证码（CAPTCHA）： 要求用户在请求验证代码前解决验证码。 IP屏蔽： 跟踪请求验证代码的IP地址，并暂时屏蔽在短时间内发出过多请求的IP。 电话号码/电子邮件验证： 要求用户在请求验证代码前验证其电话号码或电子邮件地址。 监控和警报： 在后端设置监控和警报，以通知管理员可疑活动，例如验证代码请求的激增。 蜜罐技术： 实施蜜罐技术来捕获机器人。这可能包括添加不可见的表单字段，如果填写了，将识别请求者为机器人。 使用挑战-响应机制： 实施额外的挑战-响应机制以验证请求是否来自合法用户。 了解网络攻击吗？ b树b+树区别 b+树使用场景 hashcode，equals 线程状态，notify\\notifyall\\LockSupport.unpark用过吗 32位和64位有什么区别？ http中能获得客户端的哪些信息？ 如何理解spring的ioc？spring会负责销毁bean吗？bean的生命周期？ 微服务 k8s、docker ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#hhxx-1"},{"categories":[],"content":" SXF 1raft如何选举？ 什么情况下会投票？ 对称加密和非对称加密了解吗？ 项目技术难点 第k大思路？堆做的话大顶堆还是小顶堆？ 手撕反转链表 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#sxf-1"},{"categories":[],"content":" SXF 2项目难点 在不知道验证码的情况下，如何通过验证？ 口述括号匹配 手撕lc10 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#sxf-2"},{"categories":[],"content":" Cider 1","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#cider-1"},{"categories":[],"content":" Cider 2mysql的默认隔离级别 可重复读和读已提交有什么区别？(1. undo log提供mvcc；2. 为什么需要RR？) 如何模拟数据库死锁？ 如果发生死锁，会有什么情况？（先阻塞，再超时） 对于一个sql语句，如何去查看执行计划？重点要看哪些字段？（id, select_type, table, type, possible_keys, key, key_len, ref, row, extra) 以下是执行计划中一些重要字段，你可能需要关注这些字段来理解查询的性能： id: 查询的标识符。如果你看到多行具有相同的id，它们可能是属于同一个查询的。 select_type: 查询的类型（例如，SIMPLE, SUBQUERY, UNION等）。 table: 正在访问的表的名称。 type: 访问类型（例如，ALL, index, range, ref, eq_ref, const, system, NULL）。通常，你应该避免全表扫描（ALL），并寻求更有效的访问类型，如索引查找（index）或常量查找（const）。 possible_keys: 数据库认为可能用于优化查询的索引列表。 key: 实际使用的索引。如果这个字段是NULL，那么没有使用索引，这可能会导致查询缓慢。 key_len: 使用的索引的长度。较短的索引通常更快。 ref: 显示索引的哪个部分被用来查找，可能是常量值或列名。 rows: 数据库估计需要检查的行数。较少的行通常意味着更快的查询。 Extra: 提供有关查询执行的额外信息，例如是否使用了文件排序或临时表。 如何理解索引覆盖？ 1～10构造b+树，这个树长什么样子？ spring的传播特性 单台linux服务器，起一个tomcat，一秒钟能扛住多少并发连接？（4元组确定唯一连接） C10K和C10M问题都是关于网络服务器性能和并发连接处理能力的问题。它们与Tomcat或任何其他网络服务器在单台服务器上的并发处理能力密切相关。下面是对C10K和C10M问题的简要介绍以及它们与服务器并发处理能力之间的关系： ### C10K问题： C10K问题是一个网络服务器设计的问题，它在1999年由Dan Kegel提出。这个问题涉及到网络服务器如何有效地处理数千个（10,000，即C10K）同时连接。传统的服务器和操作系统在面对高并发连接时往往会遇到性能瓶颈和资源限制。解决C10K问题需要考虑以下几方面： 1. **事件驱动或异步I/O**：使用事件驱动或异步I/O模型来减少每个连接的开销和处理延迟。 2. **多线程或多进程模型**：使用高效的多线程或多进程模型来提高服务器的并发处理能力。 3. **优化操作系统和网络堆栈**：优化操作系统设置和网络堆栈配置以支持大量的并发连接。 ### C10M问题： C10M问题是C10K问题的自然延伸，它考虑的是如何在一台机器上处理数百万（10,000,000，即C10M）的并发连接。解决C10M问题通常需要更高级的优化和技术，包括： 1. **用户空间网络栈**：使用用户空间网络栈来减轻内核空间网络处理的开销。 2. **零拷贝技术**：使用零拷贝技术来减少数据传输的CPU和内存开销。 3. **硬件加速**：利用硬件加速功能，如网络卡的TCP/IP卸载。 ### 与服务器并发处理能力的关系： 1. **性能瓶颈**：C10K和C10M问题突显了在高并发场景下服务器可能遇到的性能瓶颈和资源限制。 2. **架构和优化**：解决这些问题需要对服务器架构、网络模型和系统配置进行优化，以提高并发处理能力和资源效率。 3. **技术选型**：选择能够应对高并发场景的技术和框架，如使用事件驱动或异步I/O的网络库和服务器。 通过理解和应对C10K和C10M问题，开发者和系统管理员可以更好地设计和优化网络服务器，提高其在高并发场景下的性能和稳定性。 什么场景下会用linkedlist？实际应用中，为生命arraylist比linkedlist性能好？ rabbitmq重复消费如何处理？ 在使用RabbitMQ时，可能会遇到重复消费的问题。这种情况可能是由于网络延迟、消费者崩溃或其他错误条件导致的。处理RabbitMQ的重复消费问题通常包括以下几个方面： ### 1. **幂等处理**:（全量而非增量 确保你的消息处理逻辑是幂等的，即重复处理相同的消息不会导致问题或不一致的状态。这是处理重复消息的最佳实践。 - 例如，如果消息表示要将某个值增加1，你可以改为设置一个绝对值，从而避免重复增加。 ### 2. **消息去重**:（保存消息id 在消费者端实现消息去重逻辑，通常可以通过维护一个已处理消息ID的缓存或数据库来实现。 - 在消费者收到消息时，首先检查消息ID是否已在缓存或数据库中。 - 如果消息ID已存在，那么跳过这条消息；否则，处理消息并将消息ID添加到缓存或数据库中。 ### 3. **消息确认机制**:（消息确认机制 利用RabbitMQ的消息确认机制来确保消息只在成功处理后被确认和移除。 - 如果处理失败，可以选择重新入队该消息，但要注意避免无限循环。 ### 4. **死信队列（DLQ）**:（确保消息不被重复消费 配置死信队列来处理不能正常处理的消息，例如，当消息重复消费时将其发送到死信队列。 - 这样可以人工介入或其他处理逻辑来处理这些消息，而不是让它们不断地被重复消费。 ### 5. **日志记录和监控**:（日志 记录详细的日志，并设置监控和警报，以便在出现重复消费或其他问题时快速发现和解决问题。 ### 6. **调整队列和交换机设置**: 根据具体的使用场景和需求，可能需要调整RabbitMQ的队列和交换机的配置，以减少重复消费的可能性。 ### 7. **考虑使用幂等性API**: 如果可能，考虑使用设计为幂等的API和服务。这样，即使调用多次，也只会产生一次效果。 CAP是什么，C和数据库的C区别 分布式事务的一般方案选择 分布式事务处理是一个复杂的问题，尤其在微服务或分布式系统架构中。通常有几种常见的方案用于处理分布式事务，它们的选择取决于系统的具体需求和约束。以下是分布式事务的一些常见解决方案： ### 1. **两阶段提交（2PC, Two Phase Commit）**: 两阶段提交是一种经典的分布式事务处理协议。它分为两个阶段：准备阶段和提交/回滚阶段。所有参与者首先在准备阶段就是否准备好提交事务达成一致，然后在提交阶段执行提交或回滚操作。两阶段提交协议可以保证事务的原子性，但可能会遇到单点故障和阻塞问题。 ### 2. **三阶段提交（3PC, Three Phase Commit）**: 三阶段提交是对两阶段提交协议的改进，它增加了一个预提交阶段以减少阻塞问题。但是，三阶段提交仍然存在单点故障问题。 ### 3. **补偿事务（Compensating Transactions）**: 补偿事务是一种通过业务补偿操作来撤销之前操作的方法。每个操作都有一个对应的补偿操作，用于在事务失败时回滚。补偿事务适用于长事务和服务间的协作。 ### 4. **分布式事务中间件**: 使用分布式事务中间件如Saga或TCC（Try-Confirm-Cancel）模式来处理分布式事务。分布式事务中间件可以提供事务管理、协调和监控功能。 ### 5. **最终一致性（Eventual Consistency）**: 在某些场景中，可以接受系统在一段时间后达到一致状态而不是立即达到一致。通过事件驱动的架构和消息队列，可以实现系统的最终一致性。 ### 6. **幂等操作和重试**: 设计幂等操作，并通过重试机制来确保操作的成功。幂等操作可以在网络失败或其他错误条件下被安全地重试。 ### 7. **依赖单一事务源**: 在可能的情况下，设计系统以依赖单一的事务源。例如，将所有事务相关的操作集中在一个服务或数据库中处理。 ### 8. **使用分布式数据库**: 某些分布式数据库提供分布式事务支持，例如Google Spanner和CockroachDB。 选择分布式事务的解决方案需要考虑系统的特点、业务需求、数据一致性要求和开发维护成本等因素。在实际应用中，可能需要组合使用上述方案或寻找其他适合特定场景的解决方案。 建议 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#cider-2"},{"categories":[],"content":" oppo 1事务的特性以及如何实现？ 如何加锁？不加锁的时候如何实现并发控制？ 索引类型 什么情况下会用到索引？ 为什么要用redis呢？一定要用redis吗？ ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#oppo-1"},{"categories":[],"content":" 去哪儿 1Oauth2.0 如何保持用户登陆状态？cookie禁用怎么办？ 如何保证双写一致性 mysql建立索引，有什么规范或者注意事项吗？ 主键id有两种生成方法，UUID和自增，有什么区别？ 如何优化select * from tbname limit 1000000, 100;?这个sql是如何执行的？ leftjoin，左表有100条数据，会大于100条吗？ 如何建立线程池？ 浏览器输入www.baidu.com，发生了什么？ ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#去哪儿-1"},{"categories":[],"content":" 欢聚 测开 Intern 1如何理解测开？ 乐观锁、悲观锁是什么，以及对应的使用场景。底层原理 static关键字的使用场景 spring boot的特点 消息中间件的原理 讲讲双写一致性 谈谈你对索引的理解 索引失效的场景 非关系型数据库，redis的使用场景 常见的linux命令，如何输出一个文件的不断追加的内容？ 淘宝买东西，根据支付订单号，检查系统的退款api，入参是支付订单号、金额。设计测试用例。 如何理解同步和异步？对于调用放来说意味着什么？ 自己写一个自动化程序，如何规避外界影响，不被异步阻塞？ ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#欢聚-测开-intern-1"},{"categories":[],"content":" 欢聚 测开 Intern 2实习中你学到了什么？ 如何理解java的堆和栈？存储的什么东西？ java入参什么时候传的是值，什么时候传的是地址？ 如何使用多线程？（如何创建线程池 线程之间如何通信？数据x如何从线程a传递到线程b 如何实现代码互斥执行？ Lock比sychronized灵活在哪里？ 线程安全？那些集合类是线程安全的？ 为什么需要原子类？ 如何自己实现一个原子类？ mysql做分库分表 inner join和outer join的结果锁是什么？ 两个表做关联查询，除了用join还有别的办法吗？ 索引原理，为什么加了索引查询会变快？ 如何看待测试这个岗位？ 对于测试，用过什么框架吗？ 对于一个要先执行a再执行b的任务，如何执行？ ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#欢聚-测开-intern-2"},{"categories":[],"content":" 多益 1如何设计一个实时路况系统 反转链表 期望工资 ","date":"2023-09-05","objectID":"/interviewrecording/:0:0","series":["面试复盘"],"tags":[],"title":"Interview Recording","uri":"/interviewrecording/#多益-1"},{"categories":null,"content":"三张图了解kafka 整体架构 主题、分区、备份 两个线程 集群模式下，多个一个broker中可能有某个leader也可能有某个broker 关键点： 拦截器如何创建、使用？（在生产者，继承一个接口，Producerinterceptor，拦截器的添加需要使用List\u003c\\String\u003e进行添加，string是全限定名 ","date":"2023-09-05","objectID":"/kafka/:0:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#"},{"categories":null,"content":" Producerinterceptor详解// ProducerRecord中的内容不可被更改，因为有主题、分区等属性，随意修改可能不安全，所以需要重新new一个 // 不要修改topic、分区、key，修改key会影响分区以及压缩日志的功能 // 修改value不应该影响value的序列化 public ProducerRecord onSend(ProducerRecord producerRecord); // 消息发送前以及发送失败都会调用，先于callback执行 public void onAcknowledgement(RecordMetadata recordMetadata， Exception e); // 清理工作 public void close(); public void configure(Map\u003cString，?\u003e map) [ ","date":"2023-09-05","objectID":"/kafka/:1:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#producerinterceptor详解"},{"categories":null,"content":" 如何对发送的消息进行转化？在生产者的拦截器上进行转化，在onSend中进行实现","date":"2023-09-05","objectID":"/kafka/:2:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#如何对发送的消息进行转化在生产者的拦截器上进行转化在onsend中进行实现"},{"categories":null,"content":" 序列化方法是什么？json-\u003eString的序列化，json-\u003ebyte[]的序列化，第三方的序列化protobuf格式、avro格式、Thrift格式、json格式配合实现Serializer\u003c\u003e使用 ","date":"2023-09-05","objectID":"/kafka/:3:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#序列化方法是什么"},{"categories":null,"content":" 如何发送到固定分区？组装ProducerRecord的时候判断kv是否符合 自定义分区器，实现partitioner，重写partition方法 ProducerRecord中可以指定分区，可以但是不推荐，会让消息组装和逻辑耦合，不太雅观 不设置分区号，就会使用DefaultPartitioner，使用murmur2Hash+topositive计算key的hash，并且%分区数 key为null的情况，default分区去会调用stickyPartitionCache的partion方法进行nullkey的分区操作。查看之前该topic的分区，如果之前没发送过，那就在可用的分区中轮训。如果想要将null发送到指定分区，自己创建分区器。 ","date":"2023-09-05","objectID":"/kafka/:4:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#如何发送到固定分区"},{"categories":null,"content":" 如何保证消息发送成功且保证吞吐量？实现Callback，放入send，public void onCompletion(RecordMetadata recordMetadata, Exception e); 消息拦截器的onAcknowledgement方法，只要你发送消息，就能够返回消息的一些offset等信息，只要收到这些信息就说明发送成了。不推荐，因为这样会非常的损耗性能，吞吐量不能够得到保证。 发送消息的send方法，我们已经使用过了，这个send方法有一个Future\u003cRecordMetadata\u003e返回值类型，可以接受异步线程的执行结果，我们可以通过future的get方法，但是get是会阻塞的啊。。。 如果不调用send方法返回的future的get方法，就会导致在异常的情况下，无法获取到异常信息，就会导致消息发送的失败，虽然不调用get方法是异步发送消息，有高的吞吐量，但是又不能保证kafka消息发送成功。因此，我们需要添加一个callback接口，当我们的消息有发送失败的时候，这个callback接口就能够起到它的作用，callback接口是异步回调机制。即使使用retry，也要使用callback来为retry兜底 ","date":"2023-09-05","objectID":"/kafka/:5:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#如何保证消息发送成功且保证吞吐量实现callback放入send"},{"categories":null,"content":" acks参数如何设置？P110:不理会返回，性能最高，记录网站点击量、页面停留时间、视频点击量 1:只要集群首领收到了就收到了 all/-1:所有的都收到才收到 ","date":"2023-09-05","objectID":"/kafka/:6:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#acks参数如何设置p11"},{"categories":null,"content":" 发送批次设计为了提高吞吐量，batch发送 消息累加器中，生产者有32MB的buffer.menory存放消息批次 ProducerBatch的大小batch.size 为16kb（满16kb发送） linger.ms= 10000，一个ProducerBatch初次收到消息后，需要等待多久（收到消息后10秒内一定发） 调整这两个参数的目的是为了在延迟允许的前提下，减少发送次数 ","date":"2023-09-05","objectID":"/kafka/:7:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#发送批次设计"},{"categories":null,"content":" 8 kafka发送大消息（比batch.size大）要注意什么？消息在batch.size之内，会复用java.io.Bytebuffer，不然直接发送 直接发送的问题就是要每次都申请消息大小的空间，所以如果频繁发送大消息，不如调高batch.size 另外有max.request.size的默认1mb，超过这个无法发送，需要调整。同时，这个是发送最大值，而不是broker的接收最大值，调整broker的message.max.bytes，同时消费者的fetch.max.bytes 更大的比如10MB，别用Kafka了，用文件传输协议吧。如果一定要用的话： 1. 消息拆分并且单线程发送到指定分区，这样确保顺序且在一个分区内，可以拼回去 2. 对消息进行压缩，kafka的生产者支持消息的压缩，通过参数compression.type进行消息压缩。 可以选择snappy，gzip，lz4等压缩形式。确保消息能够最小的发送。 ","date":"2023-09-05","objectID":"/kafka/:8:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#8-kafka发送大消息比batchsize大要注意什么"},{"categories":null,"content":" 9 retry机制不用：通过callback机制对发送失败的消息进行监听，然后再次进行发送（失败的消息保存到db中，日志中） 用：kafka 通过retries 参数控制重试的次数，通过retry.backoff.ms控制重试次数之间的时间间隔。你们这个retry.backoff.ms这个时间间隔设置的是多大啊？（第二次连击）我们的时间间隔是500ms，之所以设置为500ms，是因为我们kafka中topic分区的副本首领选举的整个过程是500ms以内完成的。kafka的retry这机制，不是每次都retry的，如果收到了这样的error：消息大小超过了request.max.size 或者超过了message.max.bytes 类似这样的错误，kafka是不会选择重试的，因为这种错误是无法通过重试而成功的。如果是因为网络延迟、网络抖动啊、分区的一系列暂时不可用啊，这种错误kafka认为有可能在重试的过程中成功。 ","date":"2023-09-05","objectID":"/kafka/:9:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#9-retry机制"},{"categories":null,"content":" 10 顺序消费打到同一主题同一分区，并且对这个分区的数据进行消费 消息失败，不用retry，使用callback，可能会乱序：1、2、3、1失败、1重试 max.in.flight.requests.per.connection，这个参数的意义是，一个kafka的生产者，同时允许多少个未发送成功的消息存在。如果max.in.flight.requests.per.connection参数 = 1，那么只要有一条消息发送未成功并且一直在重试，那么其他的消息是不能再次发送的，1的意思就是，发一条，咱们就收到1条的结果，这条结果成功也好，失败也好，这都是一个结果，1就代表收到这个消息的发送结果。但是重试就不是了，重试的意思是不认命，结果还没定下来啊。如果max.in.flight.requests.per.connection 的值大于1的，刚才我们发送1,2,3，的场景，就可能出现乱序。因为即便1的发送在重试，那也只是1条信息没有收到结果，max.in.flight.requests.per.connection的值是大于1的，所以2和3还能够继续发送。 所以，在顺序消息发送和消费的场景下，必须要保证max.in.flight.requests.per.connection= 1. 最大在飞请求 ","date":"2023-09-05","objectID":"/kafka/:10:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#10-顺序消费"},{"categories":null,"content":" 11 消费者和消费者组 ","date":"2023-09-05","objectID":"/kafka/:11:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#11-消费者和消费者组"},{"categories":null,"content":" 12 分区再均衡 ","date":"2023-09-05","objectID":"/kafka/:12:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#12-分区再均衡"},{"categories":null,"content":" 13 消费者的poll仅仅是为了获取数据吗？1. 获取数据，并且poll方法支持阻塞获取； 2. 分区再均衡 （poll方法它就是从分区里获取数据的，它与分区的关系是最为紧密的） 3.群组协调 （高级部分说明）新加入了消费者，消费者会进行 joingroup 操作。 4. 发送心跳。（我们消费者组里边可以有很多消费者，有消费者如果发生异常断连，那么这个消费者就标记为不可用，其他消费者还需要进行该分区的消费，触发一次再均衡。） 5. 提交偏移量，如果消费者的 enable.auto.commit 配置设置为 true（默认值），poll() 方法将定期自动提交最近拉取的消息的偏移量，这意味着这些消息已被消费者处理。 ","date":"2023-09-05","objectID":"/kafka/:13:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#13-消费者的poll仅仅是为了获取数据吗"},{"categories":null,"content":" 14 如何进行幂等校验或者数据筛查？1. 我们可以接收到消息后，对消息进行判断，筛查以及幂等校验。（不建议使用这种方式。） 2. 自定义消费者拦截器。implements ConsumerInterceptor接口，里边有onConsume方法，这个方法是poll方法返回之前被调用的。 3. onCommit 方法是对 offset偏移量（消费者消费数据后，会提交一个offset偏移量，kafka根据这个偏移量可以确定消息是否被消费了）提交后调用的方法。 我们可以从该方法中获取一些偏移量的信息，不过，没有额外的需求，这部分可以保持为空方法体。 如果一条消息有生成的 timestamp。我们可以用拦截器消息过期丢弃的操作，用此来模拟 类似于rabbitmq的ttl机制。 ","date":"2023-09-05","objectID":"/kafka/:14:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#14-如何进行幂等校验或者数据筛查"},{"categories":null,"content":" 15消费者提交偏移量的经验1. 自动提交 enable.auto.commit = true 提交异常会导致重复消费 2. 手动提交consumer.commitSync(); sync，同步提交，会阻塞 3. 异步提交 consumer.commitASync(); 防止同步阻塞导致吞吐量降低 4. 同步+异步 ","date":"2023-09-05","objectID":"/kafka/:15:0","series":null,"tags":null,"title":"Kafka","uri":"/kafka/#15消费者提交偏移量的经验"},{"categories":["innodb","log"],"content":"为什么mysql的innodb存储引擎中，只有undo log，redo log缓冲却不在缓冲池中呢？ 个人理解，undolog可以在mvcc的时候可以通过缓存快速读取之前的版本，再出现脏页后可以刷回磁盘与数据页的使用方式类似，所以放在缓冲池中；而redo log 缓冲则是负责保存redo log，正常情况下是不需要从redo log缓冲中读取数据的，而且为了保证数据的持久性，或许更高频率的保存到磁盘才是更安全的方法，不太可能使用和缓冲池一样的落盘策略，比如redo log缓冲的写盘使用了两次写的策略。 Undo Logs: 主要用途: 提供数据的旧版本，从而支持MVCC以及事务回滚功能。 在Buffer Pool中的角色: 读: 当需要基于MVCC为某个事务提供数据的旧版本时，Undo Logs中缓存的数据页可以加速此读取过程。或者当事务需要回滚的时候应用undo logs到数据页。 写: 当事务修改数据时，这些更改首先在内存中的Undo Logs里记录（WAL，写undo、写redo、commit）。随后，这些内存中的更改会随着脏页的刷新被写回到磁盘上的Undo Logs中。 Redo Logs: 主要用途: 确保数据的持久性，记录数据的变化以便在系统崩溃时重新应用这些变化。 Redo Log Buffer的角色: 写: 当事务在内存中进行修改时，相关的更改首先被写入到Redo Log Buffer中。之后，为了确保数据持久性，这些缓存在Redo Log Buffer中的更改会被定期或在事务提交时批量写入到磁盘上的Redo Logs中。 所以： Undo logs 的缓存（在Buffer Pool中）主要是为了支持MVCC的读取操作和事物的回滚以及将脏页写回磁盘。 Redo logs 的缓冲（Redo Log Buffer）主要用来优化数据更改的磁盘写入操作。 这种设计确保了InnoDB在提供高并发性和数据持久性之间取得了很好的平衡。 ","date":"2023-09-04","objectID":"/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%93%E5%86%B2%E6%B1%A0%E4%B8%AD%E5%8F%AA%E6%9C%89undolog/:0:0","series":["看看时间都浪费在哪里了"],"tags":["mysql","innodb"],"title":"为什么缓冲池中只有undolog","uri":"/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%93%E5%86%B2%E6%B1%A0%E4%B8%AD%E5%8F%AA%E6%9C%89undolog/#"},{"categories":["jvm"],"content":"说问题先说版本，jdk8u 众所周知，java中hashcode是32位的int类型。 在学习synchronized关键字的实现的时候，接触到了markword，在32位jvm中只有25位来存储hashcode。 机智的我立刻发现了异常 25位存储空间如何才能存储32位的hashcode啊？？？ 难到是有什么padding操作？ 我看了源码之后发现，是朴实无华的直接往markword里面存，用的之后直接取出。 intptr_t hash() const { // inline intptr_t mask_bits (intptr_t x, intptr_t m) { return x \u0026 m; } // 这里直接返回了 return mask_bits(value() \u003e\u003e hash_shift, hash_mask); } 也就是说32位虚拟机压根不存高7位 一整个大崩溃……这与我刻板印象下的HashMap的put过程中发生的扰动运算不一致啊，那这样的话32位虚拟机环境下岂不是h \u003e\u003e\u003e 12更好一点？ static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16); } 测试代码如下 public class MyClass { public static void main(String args[]) { int minLeadingZeroes = 32; for (int i = 0; i \u003c 1_000_000; i++) { int hash = System.identityHashCode(new Object()); minLeadingZeroes = Math.min(minLeadingZeroes, Integer.numberOfLeadingZeros(hash)); } System.out.println(\"Smallest number of leading zeroes in identity hash codes of 1000000 objects = \" + minLeadingZeroes); } } ","date":"2023-09-04","objectID":"/markword%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A832%E4%BD%8Dhashcode/:0:0","series":["看看时间都浪费在哪里了"],"tags":["hashcode","markword"],"title":"Markword如何存储32位hashcode","uri":"/markword%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A832%E4%BD%8Dhashcode/#"},{"categories":null,"content":"学习计划 ALF OC，swift混编 CoCoa的Potocol-delegate设计模式，实现定位协议获得当前经纬度 Alamfire请求、SwiftJSON解析数据，将数据赋值给model Navgation controller切换tableView 修改数据库、更新视图、reloaddata、 Realm数据库存储数据、 展示filter数据、查询完毕使用deipatchqueue让searchbar失焦，手起键盘，让主线程优先运行 OC，masonry相对布局写个界面，foundation、UIView这些基本库搞一下 ","date":"2023-08-24","objectID":"/ios/:0:0","series":null,"tags":null,"title":"IOS","uri":"/ios/#"},{"categories":["interview"],"content":" 操作系统进程同步的临界区 进程同步是多个进程在执行时为了协调他们的行为或确保共享资源的一致性而进行的相互制约。其中，临界区是进程同步的核心概念。 ### 临界区： **临界区（Critical Section）** 是一个访问共享资源或数据的代码段，而这些资源在同一时刻只能被一个进程（或线程）访问。在临界区内的代码，同一时刻只能被一个执行单元（如进程或线程）执行。如果不遵循这一规则，那么可能会出现数据不一致或其他不可预见的结果。 例如，假设有两个进程都要修改一个共享的变量。如果这两个进程同时修改该变量，那么最终的结果将是不确定的。为了确保正确性，修改这个共享变量的代码必须被当作临界区，并确保任何时刻只有一个进程能执行这段代码。 ### 临界区的属性： 1. **互斥性**：同一时刻只能有一个进程执行临界区代码。 2. **不可剥夺**：进入临界区的进程只有在退出时才释放其对临界区的控制。 3. **等待限制**：请求进入临界区的进程不应无限期地被延迟。 4. **循环等待**：有一个约定的顺序或方法，以避免进程之间的循环等待情况。 ### 实现临界区的方法： 1. **禁止中断**：这是一个简单但粗糙的方法，适用于单处理器系统。进入临界区前禁止所有中断，退出时再恢复。 2. **特殊的机器指令**：使用测试和设置锁（Test and Set Lock）或者交换（Swap）等特殊的原子操作。 3. **Peterson's Solution**：这是一个基于软件的方法，用于两个进程的同步。 4. **信号量（Semaphores）**：信号量是一个经典的同步原语，可以用来实现多个进程之间的同步。 5. **互斥体（Mutex）**：通常用于线程同步。 6. **管程（Monitors）**：这是一个更高级的同步原语，它包含了共享数据以及可以操作这些数据的一组过程。 为了保证共享资源的一致性和数据的完整性，在多任务环境中实现临界区保护是至关重要的。 操作系统的内存管理机制 进程线程的区别，线程调度机制，进程的状态 死锁：是什么、发生条件、如何避免 死锁 是计算机科学中的一个概念，尤其在操作系统和并发控制中，指的是两个或多个进程或线程在等待某个资源而永远无法进行下去的情况。 死锁的发生条件： 死锁发生时，通常满足以下四个条件（这四个条件是并发出现的，不是顺序出现的）： 1. 互斥条件（Mutual Exclusion）：资源不能被多个进程同时占用，即一次只有一个进程可以使用资源。 2. 持有并等待（Hold and Wait）：一个进程持有至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程持有，所以它必须等待。 3. 非抢占条件（No Preemption）：资源不能被强制从一个进程中撤回，只能由占有它的进程自愿释放。 4. 循环等待（Circular Wait）：存在一个进程资源的等待循环，即：P0 等待 P1 持有的资源，P1 等待 P2 持有的资源，...，Pn 等待 P0 持有的资源。 只要其中一个条件不满足，死锁就可以被防止。 如何避免死锁： 1. 打破互斥条件：这个策略并不总是可行，因为有些资源（例如打印机）在其性质上是互斥的。 2. 打破持有并等待条件：要求进程在请求资源前释放其所有资源，这样它就不能持有资源并等待其他资源了。 3. 打破非抢占条件：操作系统可以介入并抢占资源，将其分配给其他进程。当原始进程准备运行时，如果需要的资源不可用，它就必须等待。 4. 打破循环等待条件：为系统中的所有资源分配一个线性顺序，并要求每个进程按照这种顺序递增（或递减）的方式请求资源。 除了上述的死锁避免策略，还有其他处理死锁的方法，如死锁检测和恢复（系统周期性地检查死锁，并取消或回滚某些操作以恢复正常状态） ————————— 检测：资源分配图，node是process和资源，边是分配和请求；timeout机制 避免：银行家算法 恢复：回滚process linux上一个程序运行起来是一个进程对吗？什么是僵尸进程？ 1. 进程的定义： 在 Linux 和其他 UNIX-like 系统中，当一个程序运行起来时，它确实是一个进程。进程是一个执行中的程序实例。它有自己的地址空间、内存、数据栈以及与其他进程隔离的资源。一个程序可以有多个运行中的进程实例。 2. 僵尸进程（Zombie Process）： 僵尸进程是已经完成执行但仍在进程表中的进程。简而言之，它是一个已经死去但其父进程尚未回收其状态信息的进程。以下是僵尸进程的特点： - 僵尸进程不消耗任何实际资源。尽管如此，它们仍会占用进程表中的位置，这可能会导致系统在达到最大进程数时无法启动新的进程。 - 一个进程在调用 `exit` 系统调用或执行完毕后会变成僵尸进程，直到其父进程调用 `wait` 系统调用来读取子进程的退出状态。 - 如果一个子进程变成僵尸，而其父进程没有正确地调用 `wait` 或 `waitpid` 来回收它，那么这个子进程就会一直保持僵尸状态。 - 如果父进程先于子进程退出，`init` 进程（进程ID为1）将成为子进程的新父进程，并负责清理这些子进程，从而防止它们成为僵尸进程。 如果你在系统上看到大量的僵尸进程，这可能意味着有些程序没有正确地管理它们的子进程。大多数情况下，僵尸进程是无害的，但它们占据的进程表条目可能会成为问题。如果进程表满了，系统可能无法启动新的进程。 32位地址空间，高地址到地址放的什么内容？（只回答了内核空间和用户空间，具体也不了解….） 用户空间又分为哪些部分？ os中用户态和内核态详细的交互过程 内核线程与用户线程怎么切换以及交互的，两个映射关系是什么 讲讲请求分段，请求分页，请求段页的实现方式及使用场景。请求分页的具体工作流程能不能讲讲呢？页面置换算法有哪些？（其中我说了LRU，结果后面算法题出的就是LRU😂） ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#操作系统"},{"categories":["interview"],"content":" select epoll poll多路复用中select和epoll区别，epoll的水平触发和边沿触发 图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！ 深入学习IO多路复用 select/poll/epoll 实现原理 IO多路复用了解过吗？什么是IO多路复用？（讲了概念，select、poll、epoll） select、epoll分别在什么场景下使用？（讲了两者的具体实现细节（select的轮询，epoll的优化——功能分离、就绪队列，编码层面上的理解），select适用于简单、socket会变的情景，epoll使用于效率要求高的，订阅socket不变的场景） ","date":"2023-08-12","objectID":"/interview/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#select-epoll-poll"},{"categories":["interview"],"content":" 虚拟内存为什么用虚拟内存 一定要用虚拟内存么 使用虚拟内存会变慢么 物理地址和逻辑地址之间的转换 -\u003e 从Linux的内存管理到MMU 物理地址和虚拟地址区别？ 怎么转换？ 为什么要多级页表和快表？ 缺页中断处理流程？ 页表项的结构？（页地址、页偏移，各种标记位标识 CPU 特权级、读写权限、是否在内存中……） 你提到了 CPU 特权级？怎么转换的？（中断） 具体有哪些中断？（外部中断，异常，软中断） 共享内存和进程的地址空间的关系 逻辑地址和虚拟地址怎么理解？ 逻辑地址的好处是什么？ 不加逻辑地址有什么不灵活之处吗？（我就拿虚拟内存来举例逻辑地址的灵活性，面试官帮我总结了这是内存利用效率上的） 还有吗？（我：便于内存回收吗？面试官： 怎么讲？讲了内存分配，扯到逻辑地址可以实现物理地址离散分配） ","date":"2023-08-12","objectID":"/interview/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#虚拟内存"},{"categories":["interview"],"content":" Linux查看 cpu 命令，常用命令 3、 Linux 程序如何调试 软连接与硬连接 深入理解Linux网络 ","date":"2023-08-12","objectID":"/interview/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#linux"},{"categories":["interview"],"content":" 零拷贝零拷贝说一下 ","date":"2023-08-12","objectID":"/interview/:4:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#零拷贝"},{"categories":["interview"],"content":" 缓存CPU 4 个核有共享缓存对吧，怎么保证缓存一致性？（总线锁，MESI） channel的原理（环形队列+锁+两个读写索引号+两个等待队列），哪些channel操作会panic，如何正确判断一个channel是否关闭（多返回值或者另起一个channel告知） 复制粘贴的过程中操作系统做了什么？ read命令的内核态和用户态的流程 操作系统的系统调用是什么 为什么要分用户态和内核态 进程有哪些状态 进程运行过程详细说？在操作系统中长什么样子？ execve syscall 内存分配算法 malloc怎么实现的 操作系统复制拷贝的过程？ 简介网络层模型 -\u003e 知道Linux内协议栈的实现吗 数据在内核空间和用户空间之间的拷贝 -\u003e 零拷贝问题（讲到CSAPP中浅显的DMA） 讲一讲操作系统的死锁，死锁形成的条件以及如何避免 在实际情况中文件相互引用也会造成死锁 -\u003e 讲了链接时候的头文件引用情况 操作系统如何实现CPU Cache和内存数据一致性的。 键盘输入字符会发生什么 用户态到内核态的切换有哪些方式？中断、陷阱、故障（缺页异常）、终止 操作系统进程间通信，管道共享内存信号，系统发送kill信号（把信号、中断、信号处理程序能讲的都讲了一遍，sigterm可以用户程序处理，但是sigkill特殊，操作系统会立刻中断进程） 操作系统调度的方式 操作系统IO多路复用 操作系统进程调度 哪一个Linux Shell命令查看端口使用情况？ 端口的概念 操作系统里面有两个概念是进程和线程，你能说说他们的区别吗 ","date":"2023-08-12","objectID":"/interview/:5:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#缓存"},{"categories":["interview"],"content":" 进程间通信、线程进程线程是什么？ 进程间通信方式？信号量、消息队列、套接字、共享内存、管道、信号 六个通信方式里面哪个效率最高？共享内存 进程间最高效的通信方式 进程之间、线程之间怎么进行交互 线程之间内存是共享的吗 ","date":"2023-08-12","objectID":"/interview/:6:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#进程间通信线程"},{"categories":["interview"],"content":" 计算机网络ping的底层 ping的数据报格式，字节数 session、cookie：应用场景、为什么不存数据库？会话技术存在的意义？ arp dos 攻击怎么回事，怎么解决 数据从网卡到内存的过程描述一下？具体有几次中断？ 子网是什么 同一局域网内如何通信 路由协议详解，做了什么 OSPF 计算机网络七层架构和五层的区别 长连接是什么？还有什么影响？ 在刷抖音的时候，下拉出现新视频，加载下一条视频到它返回的过程中，从网络角度来看发生了什么？先做了什么，后做了什么，数据是怎么返回的，用到的一些协议等等？ 如果没有网络连接，应该从哪些方面去排除问题 ARP协议 在ping的过程中，mac地址会变吗 结合七层模型讲一讲网址键入的全过程 浏览器输入地址后发生的全过程 五层对应的各层协议 dns解析域名过程 说说OSI七层模型？ 用户输入网址到显示对应页面的全过程？ DNS 的解析过程？ HTTP有多少版本？ HTTP1.0/1.1/2.0/3.0的主要区别是什么？https和websocket和rpc 目前使用最广泛的是哪个HTTP版本？ 什么是幂等？幂等方法了解哪些？ 除了Get方法之外还了解其他幂等方法吗？ 一个TCP连接可以发送多少次HTTP请求? 一个客户端与服务器用tcp连接，服务器宕机之后客户端的一系列事情 http怎么转为rpc tcp建立连接的过程 http1.0、1.1、2.0，问了1.1中发一个报文丢失之后怎么办？ tcp过程三次握手四次挥手的状态？三次挥手可以吗？出现什么问题？ ​ http传输音视频数据可以吗？视频聊天在应用层用的什么协议，传输层用的什么协议？ udp为什么比tcp快？ 信息不可达怎么办？ 浏览器输入网址到打开网页的流程 IPv6 ISO七层模型和每层常见的协议； 路由器和交换机区别？ 链路层是干什么的？有哪些协议？ IP 地址和 MAC 地址的区别？ cookie 和 session 的区别和联系 知道rpc吗，详细解释一下 socket了解吗 http的method？具体？ cookie和session有什么区别？ http和https的区别？单项认证和双向认证流程？对称加密和非对称加密？流程？ DNS解析的过程？域名服务器怎么解析？ ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#计算机网络"},{"categories":["interview"],"content":" http \u0026 httpsHTTP概念、流程、格式（header里面有什么，都代表了什么 ） HTTPS概念、流程、连接过程、加密解密流程原理、数字证书签发和验证流程、密钥交换流程、为什么有两种加密方式 常见加密算法 HTTP和HTTPS区别、握手过程（Keep-Alive重点\u0026与TCP的关系\u0026时长上限、长连接是什么） 浏览器输入 URL后发生了什么？（八股）具体到 HTTP 协议？ HTTP常见状态码 如果一个项目全都使用POST会如何 然后问了ssl加密过程（这里问了一个问什么需要用ca确认证书的方式拿到公钥，（我的回答是为了安全））， http1.0 1.1 2.0之间的区别（问了为什么1.0 1.1无法解决头部阻塞，（他告诉我是因为之前是使用文件协议，不像2.0用的二进制分帧）） 项目里用到了HTTPS，说一下HTTP和HTTPS的区别 加密算法有几大类（没回答出来，但其实我是知道的，后来面试官提示了对称加密和非对称加密） 怎么理解对称加密和非对称加密？（介绍了两者的细节） HTTPS秘钥的过程了解吗？（从设计角度讲了这个过程，包括数字证书、公钥、私钥） 服务端怎么解析的请求 Cookie原理 cookie和session 问：你能介绍一下HTTP协议吗？ 答：HTTP协议是一个无状态的协议，本次请求和之前的请求无关。它是一种报文交换格式的约定，规定了响应码、请求头、请求方法等内容，比如说常用的GET、POST、DELETE、PUT请求等，为了解决HTTP请求的无状态，我们通常会使用服务端的会话管理机制或者COOKIE来追踪客户端状态，对于响应码，有多种响应码表示不同的响应状态，比如正常响应是200，302重定向、404资源不存在、500服务端错误等。HTTPS是HTTP的安全版本，具体安全机制的实现方案不太了解（非计算机专业），但是了解其安全加密方案是基于公私钥的加密方案。 HTTP 怎么拆包的？（CRLF 分隔，同时有一个 Content-Length 字段决定 body 长度） HTTP 如何传输大文件呢？（分块传输，Transfer-Encoding: chunked） 分块传输怎么判断什么时候传输完成呢？（最后一个包是空的） CA证书 SSL加密过程 怎么验证服务器证书就是服务器的证书（我没理解明白，应该问的是中间人攻击） http的无状态指的是什么？ HTTP请求方法各种方法的应用场景 HTTP状态码从1到5是什么意思？500，502，504分别什么意思 ？ HTTPS加密、解密过程是怎么样的，总共需要加密几次？ 什么是RESTful ，增删改查对应的HTTP动词是什么？ HTTP request的格式 如果没有ConTent-Length 怎么使用HTTP （Transfer-Encoding为chunked） HTTP 与 HTTPS的区别？ 为什么要有两种加密？ HTTP的请求报文的形式 GET和POST的区别 POST还支持什么编码类型 GET保留的完整记录是什么 1.HTTP的请求方法有哪些 2.HTTP的状态码 3.HEAD方法有什么作用 4.HTTP各版本的不同 非对称加密为什么不安全？ （自己问http有拥塞控制吗？讲一下time-wait状态 是http的问题吗） 应用层除去HTTP之外还有什么 -\u003e SMTP, FTP ","date":"2023-08-12","objectID":"/interview/:0:1","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#http--https"},{"categories":["interview"],"content":" TCP/IP \u0026 UDPTCP 如何保证可靠性，拥塞控制如何实现？拥塞窗口讲一讲，为什么要用慢启动算法; 结构 TCP和UDP对比，区别，使用场景，分别有哪些协议？面向what？是否可靠？内部数据结构？TCP基于数据流川叔，UDP基于包传输 tcp中拥塞控制算法、流程 TCP如何做到稳定连接？（拥塞控制那些） TCP重传、滑动窗口、流量控制、拥塞控制 如何不断的装包？ 哪些发生在内核态？从java的socket写出到收到，经历了那些？如何进入内核态？ 为什么 TCP 会粘包？（TCP 是字节流） 怎么解决粘包？（刚才不一直在聊 HTTP 解决粘包吗。。。） 如何设计一种机制在UDP上实现可靠传输？Q TCP粘包现象 TCP和HTTP长连接的区别。 TCP保活机制是谁实现的。 三次握手 \u0026 四次挥手tcp fin和ack可以在一个报文中吗 握手、挥手过程，为什么要这样做 最后一次握手丢失后服务端和客户端会处于什么状态？ 序列号为什么是随机的。 为什么是三次。 TCP 三次握手交换了什么东西？ 为什么有窗口大小？ 第三次握手丢失后服务端和客户端会处于什么状态？（这个因为第一次面试的时候发现一个问题 所以跟面试官讨论了一会） 那这个问题你有没有自己去抓包测试？ TCP可靠性怎么保证，三次握手，两次握手可行否？TCP三次握手，TIME_WAIT，三次握手 四次挥手； 四次挥手没有第四次会怎么样？（超时关闭？） TIME_WAIT和CLOSE_WAIT区别 大量连接处于CLOSE_WAIT是什么原因 close_wait状态多久出现，出现原因是什么 time-wait存在的意义 ，TIME_WAIT状态的详细分析，何时出现，何处出现，为何出现，是否有弊端，如何避免 介绍下四次挥手？ 三次行不行 每次挥手的状态？（7个状态） contect 和 accept对应 TCP 三次握手的什么阶段？ ","date":"2023-08-12","objectID":"/interview/:0:2","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#tcpip--udp"},{"categories":["interview"],"content":" TCP/IP \u0026 UDPTCP 如何保证可靠性，拥塞控制如何实现？拥塞窗口讲一讲，为什么要用慢启动算法; 结构 TCP和UDP对比，区别，使用场景，分别有哪些协议？面向what？是否可靠？内部数据结构？TCP基于数据流川叔，UDP基于包传输 tcp中拥塞控制算法、流程 TCP如何做到稳定连接？（拥塞控制那些） TCP重传、滑动窗口、流量控制、拥塞控制 如何不断的装包？ 哪些发生在内核态？从java的socket写出到收到，经历了那些？如何进入内核态？ 为什么 TCP 会粘包？（TCP 是字节流） 怎么解决粘包？（刚才不一直在聊 HTTP 解决粘包吗。。。） 如何设计一种机制在UDP上实现可靠传输？Q TCP粘包现象 TCP和HTTP长连接的区别。 TCP保活机制是谁实现的。 三次握手 \u0026 四次挥手tcp fin和ack可以在一个报文中吗 握手、挥手过程，为什么要这样做 最后一次握手丢失后服务端和客户端会处于什么状态？ 序列号为什么是随机的。 为什么是三次。 TCP 三次握手交换了什么东西？ 为什么有窗口大小？ 第三次握手丢失后服务端和客户端会处于什么状态？（这个因为第一次面试的时候发现一个问题 所以跟面试官讨论了一会） 那这个问题你有没有自己去抓包测试？ TCP可靠性怎么保证，三次握手，两次握手可行否？TCP三次握手，TIME_WAIT，三次握手 四次挥手； 四次挥手没有第四次会怎么样？（超时关闭？） TIME_WAIT和CLOSE_WAIT区别 大量连接处于CLOSE_WAIT是什么原因 close_wait状态多久出现，出现原因是什么 time-wait存在的意义 ，TIME_WAIT状态的详细分析，何时出现，何处出现，为何出现，是否有弊端，如何避免 介绍下四次挥手？ 三次行不行 每次挥手的状态？（7个状态） contect 和 accept对应 TCP 三次握手的什么阶段？ ","date":"2023-08-12","objectID":"/interview/:0:2","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#三次握手--四次挥手"},{"categories":["interview"],"content":" DNSDNS的工作原理 DNS劫持 DNS的作用 dns是一个webserver吗？ ","date":"2023-08-12","objectID":"/interview/:0:3","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#dns"},{"categories":["interview"],"content":" linuxLinux指令，查看文件大小，ls和du的区别，查看网络io和磁盘io使用指令（nstat、iotop） linux怎么在文件里查找特定单词grep 'word' filename 给定文件，每行都有时间、用户、id、url组成，统计行数、人数 wc -l cut -d ',' -f 2 filename.txt | sort | uniq | wc -l Linux nio怎么实现的？ Linux的硬链接和软链接 io多路复用，epoll底层原理（红黑树、rdlist、epoll_wait linux socket函数 有在linux上部署过什么吗？ Linux常用命令 具体描述一下如何用epoll实现I/O多路复用？ 介绍一下触发条件（边缘触发、水平触发） 多路复用解决了什么 select、poll、epoll优缺点、区别、使用场景、如何使用 多路复用原理（为什么1 1.1不行呢） 流 帧的概念 vim编辑模式，常用快捷键 ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#linux-1"},{"categories":["interview"],"content":" 数据库（MySQL为主）MySQL集群中主库宕机，从库如何立即感知到并接管? 数据库分库分表 如何实现串行化？ changeBuffer、页分裂合页合并 mvcc 假设我们是单机数据库，不考虑分布式的情况，自增主键的缺点是什么？（想了一会，不了解） 有接触过分布式系统RAFT协议吗？（没有） timezone 当我们输入一个SQL查询语句时，mysql数据库引擎是如何执行并得到最终结果的？（答：先查询缓存-\u003e解析器-\u003e优化器） 死锁是什么，怎样解决银行家算法，事务回滚 写过SQL优化？ SQL优化？日志查询定位SQL，explain解析 数据库的锁，共享锁互斥锁和共享锁悲观锁的区别和关系是什么 对范式有哪些了解呢，范式的作用是什么，后端的业务系统是否适合范式理论，了解过数据库除范式之外的其他理论吗 串行化如何实现 ，可重复读的特性，如何解决幻读 性别字段要建立索引吗？为什么？什么是区分度？MySQL查看字段区分度的命令？ MySQL主从复制流程和原理？ MySQL如何查看查询是否用到了索引？如何查看SQL执行时间？MySQL 中可以使用以下几种方法来检查查询是否使用了索引： EXPLAIN命令：EXPLAIN 命令可以分析 SQL 语句的执行计划，并显示该语句是否使用了索引。如果使用了索引，会显示 “Using index”。explain结果有哪些字段？ 记录查询语句：在 MySQL 中，可以通过启用查询语句记录功能，记录下所有执行的查询语句。然后，可以使用 MySQL 日志文件来检查某个查询是否使用了索引。 performance_schema：MySQL 中提供了 performance_schema 功能，它可以记录查询的执行情况，包括是否使用了索引。 通过使用以上方法，可以方便地检查某个查询是否使用了索引，从而帮助优化查询的性能。 type列的最好，最好级别？都代表了什么意思？ mysql中一个update语句什么情况下会很慢？一个UPDATE语句在以下情况下可能会非常慢： 缺少索引：如果UPDATE语句涉及的列没有索引，MySQL就需要扫描整张表以找到所需的行，这可能会导致很慢的查询性能。 过多的数据：如果需要更新的数据量非常大，这也可能导致UPDATE语句执行很慢。 复杂的表关系：如果UPDATE语句涉及复杂的表关系，例如外键，这也可能导致UPDATE语句执行很慢。 触发器和存储过程：如果UPDATE语句触发了触发器或调用了存储过程，这也可能导致UPDATE语句执行很慢。 服务器负载过高：如果服务器负载过高，UPDATE语句执行可能会非常慢。 通过确定上述因素，可以帮助改进UPDATE语句的性能。 针对上述情况，给出详细的解决办法 说了因为主键问题导致分页合并页 update加载的段太大 changbuffer中没有语句命中的行(没答出来) mysql中null值怎么存放？有什么好处？行中（标记位），辅助索引中（不存），null！=null mysql事务执行过程中，未提交的事物会被持久化吗？ 隔离级别，以及其实现方式，一致性实现方式 如何解决丢失修改的问题? 了解CAS吗？ 缺少主键的话MySQL如何处理 建表语句、一条sql和这条sql的explain之后的结果？问为啥不走索引，怎么做？我回答的是有个字段没有建索引，可以增加一个联合索引，顺序可以改变吗？最左匹配原则 接着又给了一道题，在一个事务中有两条sql，select语句和update语句，问在你说的各个隔离级别下，mysql会出现什么问题？RR：有锁和mvcc控制不会有问题，读未提交：会看到其他事务的脏数据，读已提交：读已提交会造成不可重复读问题和幻读问题，但是这里只有一个select，应该不会有问题，大家觉得呢？这里没有updata和insert所以也不会造成幻读这里好像不可重复读和幻读的概念搞反了，这才反应过来 了解SQL注入吗？如何去防止SQL注入？ MySQL自己有一些支持SQL注入的方式，了解吗？ MySQL内部有哪些锁？（server层，engine层） 数据库B+树 Pagecache 数据库两种引擎，索引结构 关系型数据库和非关系型数据库 数据库的引擎 \\4. Sql语句 \\5. 数据库的锁 \\6. 数据库的隔离状态 \\7. 怎么防止幻读 \\3. sql两种引擎区别 \\4. 聚簇索性和非聚簇索性 \\5. Sql语句查询前七天数据 \\13. 问问db数据库（g了，中间被锁搞短路了，本来能说出来四个隔离级别解决什么问题，被锁给卡傻了） \\14. 讲讲mysql的锁机制，查询语句命中索引是把锁加到哪 \\15. mysql的间隙锁有了解吗 \\16. mvcc解决什么问题 \\17. 幻读在innodb下怎么解决的？ \\18. 隔离级别 mysql 的事物 ACID 以及都是如何实现的？ 答:A原子性用 undo log 实现 I隔离性说了 MVCC，以及 readview，表隐式字段，快照读，版本链，如何判断当前事物能不能读某个版本，等等…(MVCC 推荐看 b 站 IT 老哥讲解的视频) D 持久性说了 redo log 和 mysql 的 buffer 那一套(这里面问的特别深，顺序 IO 和随机 IO，redo log写入策略..) C一致性:一致性怎么实现这个问题难我很久了,之前搜博客也没看到很好的解答,我就按照自己理解说其他三个都能保证的话就具备了一致性,面试官否定~ \\9. mysql的锁有哪些? 答:行锁,间隙锁,表锁,以及锁升级过程 追问:就这些了吗? next-key lock 没有没有了解过,我:…… 后面还问了一些暂时想不起来了 MySQL的聚簇索引以及为什么要这样设计（为什么面试没答上来，可能是局部性原理） \\11. \\14. 隔离级别，可重读是怎么实现的？幻读是怎么回事？间隙锁知道不？ 读写锁互斥关系，其他分类的锁 6.读已提交和可重复度底层实现的区别？（没答好） 可重复读 主从复制， 是基于binlog复制的,有3种格式:statement:记录的是修改SQL语句row：记录的是每行实际数据的变更mixed：statement和row模式的混合 那Mysql在5.0这个版本以前，binlog只支持STATEMENT这种格式！而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别！ \\15. 介绍下事务，如果了解的话，介绍下事务是怎么实现的 \\16. 平常使用较多的数据库是？mysql吗？mysql用的比较多的特性或者命令？ \\19. 设计一个短信验证码验证的一个用户登录系统，怎么设计mysql的数据表，或者说怎么设计数据结构 traceroute的底层 mysql 如何存储nullhttps://mp.weixin.qq.com/s/sqW51yqeAXcDs9r84UFP7A 行级锁https://mp.weixin.qq.com/s/Ef73pSWb_k6yiTTlNCrEjg 全剧锁https://mp.weixin.qq.com/s/SgteE94sZfAMv5mZJYrTqw 解析器：词法（关键词、符号匹配）、语法（形成语法树）、语义分析（存在性与合法性） 优化器: ​ RBO基于规则优化:简化条件(删除类似的条件)，表链接优化(query tree优化)，scan优化（索引-\u003e全表） ​ CBO基于代价优化: 执行器：火山模型，优点：独立抽象实现，互相之间没有耦合，逻辑结构简单 缺点：没计算一条数据又多次函数调用开销磨，导致CPU效率不高 向量化 每个Operator每次操作计算的不再是一行数据，而是一批数据(Batch N行数据)，计算完成后向上层算子返回一个Batch。 优点 函数调用次数降低为1/N : CPU cache命中率更高 可以利用CPU提供的SIMD(Single Instruction Multi Data)机制 mysql查询语句 mysql底层数据结构，查询过程 mysql和mongo的区别，为什么选mysql 编译执行：动态编译执行技术LLVM mysql锁机制 9、MVCC 11、保证幂等性的方案 有聚合函数时select的列需要在聚合或者groupby中 内存缓冲池、到extendible hashtable索引、到火山模型、到事务控制, 哈希索引的并发控制） MYSQL的端口号 项目数据库的表组成，表的设计，三范式（优劣） 对范式有哪些了解呢 范式的作用是什么 Mysql为什么要使用两阶段提交？ 后端的业务系统是否适合范式理论 了解过数据库除范式之外的其他理论吗 自增id用尽 null存储形式 数据库的四大范式讲一讲？ 数据一致性？ 写并发如何执行 数据库是如何实现分页查询的， 当数据量很大的时候， 如何提高效率。 mysql 数据误删怎么还原（给的方案是找到最近的备份文件，然后通过bin日志和relay日志恢复剩下的数据）其实还可以回滚 Sql注入攻击 设计数据库连接池需要考虑:1. 连接池容量及初始大小设置;2. 获取连接超时时间设置;3. 连接最大生命周期设置; 4. 连接的获取与释放实现;5. 连接的定期检测与维护;6. 是否实现连接池规范如DataSource; 7. 额外功能如连接泄漏检测等;8. 不同数据库的特点,如Oracle限制的连接数。 ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#数据库mysql为主"},{"categories":["interview"],"content":" 数据库（MySQL为主）MySQL集群中主库宕机，从库如何立即感知到并接管? 数据库分库分表 如何实现串行化？ changeBuffer、页分裂合页合并 mvcc 假设我们是单机数据库，不考虑分布式的情况，自增主键的缺点是什么？（想了一会，不了解） 有接触过分布式系统RAFT协议吗？（没有） timezone 当我们输入一个SQL查询语句时，mysql数据库引擎是如何执行并得到最终结果的？（答：先查询缓存-\u003e解析器-\u003e优化器） 死锁是什么，怎样解决银行家算法，事务回滚 写过SQL优化？ SQL优化？日志查询定位SQL，explain解析 数据库的锁，共享锁互斥锁和共享锁悲观锁的区别和关系是什么 对范式有哪些了解呢，范式的作用是什么，后端的业务系统是否适合范式理论，了解过数据库除范式之外的其他理论吗 串行化如何实现 ，可重复读的特性，如何解决幻读 性别字段要建立索引吗？为什么？什么是区分度？MySQL查看字段区分度的命令？ MySQL主从复制流程和原理？ MySQL如何查看查询是否用到了索引？如何查看SQL执行时间？MySQL 中可以使用以下几种方法来检查查询是否使用了索引： EXPLAIN命令：EXPLAIN 命令可以分析 SQL 语句的执行计划，并显示该语句是否使用了索引。如果使用了索引，会显示 “Using index”。explain结果有哪些字段？ 记录查询语句：在 MySQL 中，可以通过启用查询语句记录功能，记录下所有执行的查询语句。然后，可以使用 MySQL 日志文件来检查某个查询是否使用了索引。 performance_schema：MySQL 中提供了 performance_schema 功能，它可以记录查询的执行情况，包括是否使用了索引。 通过使用以上方法，可以方便地检查某个查询是否使用了索引，从而帮助优化查询的性能。 type列的最好，最好级别？都代表了什么意思？ mysql中一个update语句什么情况下会很慢？一个UPDATE语句在以下情况下可能会非常慢： 缺少索引：如果UPDATE语句涉及的列没有索引，MySQL就需要扫描整张表以找到所需的行，这可能会导致很慢的查询性能。 过多的数据：如果需要更新的数据量非常大，这也可能导致UPDATE语句执行很慢。 复杂的表关系：如果UPDATE语句涉及复杂的表关系，例如外键，这也可能导致UPDATE语句执行很慢。 触发器和存储过程：如果UPDATE语句触发了触发器或调用了存储过程，这也可能导致UPDATE语句执行很慢。 服务器负载过高：如果服务器负载过高，UPDATE语句执行可能会非常慢。 通过确定上述因素，可以帮助改进UPDATE语句的性能。 针对上述情况，给出详细的解决办法 说了因为主键问题导致分页合并页 update加载的段太大 changbuffer中没有语句命中的行(没答出来) mysql中null值怎么存放？有什么好处？行中（标记位），辅助索引中（不存），null！=null mysql事务执行过程中，未提交的事物会被持久化吗？ 隔离级别，以及其实现方式，一致性实现方式 如何解决丢失修改的问题? 了解CAS吗？ 缺少主键的话MySQL如何处理 建表语句、一条sql和这条sql的explain之后的结果？问为啥不走索引，怎么做？我回答的是有个字段没有建索引，可以增加一个联合索引，顺序可以改变吗？最左匹配原则 接着又给了一道题，在一个事务中有两条sql，select语句和update语句，问在你说的各个隔离级别下，mysql会出现什么问题？RR：有锁和mvcc控制不会有问题，读未提交：会看到其他事务的脏数据，读已提交：读已提交会造成不可重复读问题和幻读问题，但是这里只有一个select，应该不会有问题，大家觉得呢？这里没有updata和insert所以也不会造成幻读这里好像不可重复读和幻读的概念搞反了，这才反应过来 了解SQL注入吗？如何去防止SQL注入？ MySQL自己有一些支持SQL注入的方式，了解吗？ MySQL内部有哪些锁？（server层，engine层） 数据库B+树 Pagecache 数据库两种引擎，索引结构 关系型数据库和非关系型数据库 数据库的引擎 \\4. Sql语句 \\5. 数据库的锁 \\6. 数据库的隔离状态 \\7. 怎么防止幻读 \\3. sql两种引擎区别 \\4. 聚簇索性和非聚簇索性 \\5. Sql语句查询前七天数据 \\13. 问问db数据库（g了，中间被锁搞短路了，本来能说出来四个隔离级别解决什么问题，被锁给卡傻了） \\14. 讲讲mysql的锁机制，查询语句命中索引是把锁加到哪 \\15. mysql的间隙锁有了解吗 \\16. mvcc解决什么问题 \\17. 幻读在innodb下怎么解决的？ \\18. 隔离级别 mysql 的事物 ACID 以及都是如何实现的？ 答:A原子性用 undo log 实现 I隔离性说了 MVCC，以及 readview，表隐式字段，快照读，版本链，如何判断当前事物能不能读某个版本，等等…(MVCC 推荐看 b 站 IT 老哥讲解的视频) D 持久性说了 redo log 和 mysql 的 buffer 那一套(这里面问的特别深，顺序 IO 和随机 IO，redo log写入策略..) C一致性:一致性怎么实现这个问题难我很久了,之前搜博客也没看到很好的解答,我就按照自己理解说其他三个都能保证的话就具备了一致性,面试官否定~ \\9. mysql的锁有哪些? 答:行锁,间隙锁,表锁,以及锁升级过程 追问:就这些了吗? next-key lock 没有没有了解过,我:…… 后面还问了一些暂时想不起来了 MySQL的聚簇索引以及为什么要这样设计（为什么面试没答上来，可能是局部性原理） \\11. \\14. 隔离级别，可重读是怎么实现的？幻读是怎么回事？间隙锁知道不？ 读写锁互斥关系，其他分类的锁 6.读已提交和可重复度底层实现的区别？（没答好） 可重复读 主从复制， 是基于binlog复制的,有3种格式:statement:记录的是修改SQL语句row：记录的是每行实际数据的变更mixed：statement和row模式的混合 那Mysql在5.0这个版本以前，binlog只支持STATEMENT这种格式！而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别！ \\15. 介绍下事务，如果了解的话，介绍下事务是怎么实现的 \\16. 平常使用较多的数据库是？mysql吗？mysql用的比较多的特性或者命令？ \\19. 设计一个短信验证码验证的一个用户登录系统，怎么设计mysql的数据表，或者说怎么设计数据结构 traceroute的底层 mysql 如何存储nullhttps://mp.weixin.qq.com/s/sqW51yqeAXcDs9r84UFP7A 行级锁https://mp.weixin.qq.com/s/Ef73pSWb_k6yiTTlNCrEjg 全剧锁https://mp.weixin.qq.com/s/SgteE94sZfAMv5mZJYrTqw 解析器：词法（关键词、符号匹配）、语法（形成语法树）、语义分析（存在性与合法性） 优化器: ​ RBO基于规则优化:简化条件(删除类似的条件)，表链接优化(query tree优化)，scan优化（索引-\u003e全表） ​ CBO基于代价优化: 执行器：火山模型，优点：独立抽象实现，互相之间没有耦合，逻辑结构简单 缺点：没计算一条数据又多次函数调用开销磨，导致CPU效率不高 向量化 每个Operator每次操作计算的不再是一行数据，而是一批数据(Batch N行数据)，计算完成后向上层算子返回一个Batch。 优点 函数调用次数降低为1/N : CPU cache命中率更高 可以利用CPU提供的SIMD(Single Instruction Multi Data)机制 mysql查询语句 mysql底层数据结构，查询过程 mysql和mongo的区别，为什么选mysql 编译执行：动态编译执行技术LLVM mysql锁机制 9、MVCC 11、保证幂等性的方案 有聚合函数时select的列需要在聚合或者groupby中 内存缓冲池、到extendible hashtable索引、到火山模型、到事务控制, 哈希索引的并发控制） MYSQL的端口号 项目数据库的表组成，表的设计，三范式（优劣） 对范式有哪些了解呢 范式的作用是什么 Mysql为什么要使用两阶段提交？ 后端的业务系统是否适合范式理论 了解过数据库除范式之外的其他理论吗 自增id用尽 null存储形式 数据库的四大范式讲一讲？ 数据一致性？ 写并发如何执行 数据库是如何实现分页查询的， 当数据量很大的时候， 如何提高效率。 mysql 数据误删怎么还原（给的方案是找到最近的备份文件，然后通过bin日志和relay日志恢复剩下的数据）其实还可以回滚 Sql注入攻击 设计数据库连接池需要考虑:1. 连接池容量及初始大小设置;2. 获取连接超时时间设置;3. 连接最大生命周期设置; 4. 连接的获取与释放实现;5. 连接的定期检测与维护;6. 是否实现连接池规范如DataSource; 7. 额外功能如连接泄漏检测等;8. 不同数据库的特点,如Oracle限制的连接数。 ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#mysql如何查看查询是否用到了索引如何查看sql执行时间"},{"categories":["interview"],"content":" 数据库（MySQL为主）MySQL集群中主库宕机，从库如何立即感知到并接管? 数据库分库分表 如何实现串行化？ changeBuffer、页分裂合页合并 mvcc 假设我们是单机数据库，不考虑分布式的情况，自增主键的缺点是什么？（想了一会，不了解） 有接触过分布式系统RAFT协议吗？（没有） timezone 当我们输入一个SQL查询语句时，mysql数据库引擎是如何执行并得到最终结果的？（答：先查询缓存-\u003e解析器-\u003e优化器） 死锁是什么，怎样解决银行家算法，事务回滚 写过SQL优化？ SQL优化？日志查询定位SQL，explain解析 数据库的锁，共享锁互斥锁和共享锁悲观锁的区别和关系是什么 对范式有哪些了解呢，范式的作用是什么，后端的业务系统是否适合范式理论，了解过数据库除范式之外的其他理论吗 串行化如何实现 ，可重复读的特性，如何解决幻读 性别字段要建立索引吗？为什么？什么是区分度？MySQL查看字段区分度的命令？ MySQL主从复制流程和原理？ MySQL如何查看查询是否用到了索引？如何查看SQL执行时间？MySQL 中可以使用以下几种方法来检查查询是否使用了索引： EXPLAIN命令：EXPLAIN 命令可以分析 SQL 语句的执行计划，并显示该语句是否使用了索引。如果使用了索引，会显示 “Using index”。explain结果有哪些字段？ 记录查询语句：在 MySQL 中，可以通过启用查询语句记录功能，记录下所有执行的查询语句。然后，可以使用 MySQL 日志文件来检查某个查询是否使用了索引。 performance_schema：MySQL 中提供了 performance_schema 功能，它可以记录查询的执行情况，包括是否使用了索引。 通过使用以上方法，可以方便地检查某个查询是否使用了索引，从而帮助优化查询的性能。 type列的最好，最好级别？都代表了什么意思？ mysql中一个update语句什么情况下会很慢？一个UPDATE语句在以下情况下可能会非常慢： 缺少索引：如果UPDATE语句涉及的列没有索引，MySQL就需要扫描整张表以找到所需的行，这可能会导致很慢的查询性能。 过多的数据：如果需要更新的数据量非常大，这也可能导致UPDATE语句执行很慢。 复杂的表关系：如果UPDATE语句涉及复杂的表关系，例如外键，这也可能导致UPDATE语句执行很慢。 触发器和存储过程：如果UPDATE语句触发了触发器或调用了存储过程，这也可能导致UPDATE语句执行很慢。 服务器负载过高：如果服务器负载过高，UPDATE语句执行可能会非常慢。 通过确定上述因素，可以帮助改进UPDATE语句的性能。 针对上述情况，给出详细的解决办法 说了因为主键问题导致分页合并页 update加载的段太大 changbuffer中没有语句命中的行(没答出来) mysql中null值怎么存放？有什么好处？行中（标记位），辅助索引中（不存），null！=null mysql事务执行过程中，未提交的事物会被持久化吗？ 隔离级别，以及其实现方式，一致性实现方式 如何解决丢失修改的问题? 了解CAS吗？ 缺少主键的话MySQL如何处理 建表语句、一条sql和这条sql的explain之后的结果？问为啥不走索引，怎么做？我回答的是有个字段没有建索引，可以增加一个联合索引，顺序可以改变吗？最左匹配原则 接着又给了一道题，在一个事务中有两条sql，select语句和update语句，问在你说的各个隔离级别下，mysql会出现什么问题？RR：有锁和mvcc控制不会有问题，读未提交：会看到其他事务的脏数据，读已提交：读已提交会造成不可重复读问题和幻读问题，但是这里只有一个select，应该不会有问题，大家觉得呢？这里没有updata和insert所以也不会造成幻读这里好像不可重复读和幻读的概念搞反了，这才反应过来 了解SQL注入吗？如何去防止SQL注入？ MySQL自己有一些支持SQL注入的方式，了解吗？ MySQL内部有哪些锁？（server层，engine层） 数据库B+树 Pagecache 数据库两种引擎，索引结构 关系型数据库和非关系型数据库 数据库的引擎 \\4. Sql语句 \\5. 数据库的锁 \\6. 数据库的隔离状态 \\7. 怎么防止幻读 \\3. sql两种引擎区别 \\4. 聚簇索性和非聚簇索性 \\5. Sql语句查询前七天数据 \\13. 问问db数据库（g了，中间被锁搞短路了，本来能说出来四个隔离级别解决什么问题，被锁给卡傻了） \\14. 讲讲mysql的锁机制，查询语句命中索引是把锁加到哪 \\15. mysql的间隙锁有了解吗 \\16. mvcc解决什么问题 \\17. 幻读在innodb下怎么解决的？ \\18. 隔离级别 mysql 的事物 ACID 以及都是如何实现的？ 答:A原子性用 undo log 实现 I隔离性说了 MVCC，以及 readview，表隐式字段，快照读，版本链，如何判断当前事物能不能读某个版本，等等…(MVCC 推荐看 b 站 IT 老哥讲解的视频) D 持久性说了 redo log 和 mysql 的 buffer 那一套(这里面问的特别深，顺序 IO 和随机 IO，redo log写入策略..) C一致性:一致性怎么实现这个问题难我很久了,之前搜博客也没看到很好的解答,我就按照自己理解说其他三个都能保证的话就具备了一致性,面试官否定~ \\9. mysql的锁有哪些? 答:行锁,间隙锁,表锁,以及锁升级过程 追问:就这些了吗? next-key lock 没有没有了解过,我:…… 后面还问了一些暂时想不起来了 MySQL的聚簇索引以及为什么要这样设计（为什么面试没答上来，可能是局部性原理） \\11. \\14. 隔离级别，可重读是怎么实现的？幻读是怎么回事？间隙锁知道不？ 读写锁互斥关系，其他分类的锁 6.读已提交和可重复度底层实现的区别？（没答好） 可重复读 主从复制， 是基于binlog复制的,有3种格式:statement:记录的是修改SQL语句row：记录的是每行实际数据的变更mixed：statement和row模式的混合 那Mysql在5.0这个版本以前，binlog只支持STATEMENT这种格式！而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别！ \\15. 介绍下事务，如果了解的话，介绍下事务是怎么实现的 \\16. 平常使用较多的数据库是？mysql吗？mysql用的比较多的特性或者命令？ \\19. 设计一个短信验证码验证的一个用户登录系统，怎么设计mysql的数据表，或者说怎么设计数据结构 traceroute的底层 mysql 如何存储nullhttps://mp.weixin.qq.com/s/sqW51yqeAXcDs9r84UFP7A 行级锁https://mp.weixin.qq.com/s/Ef73pSWb_k6yiTTlNCrEjg 全剧锁https://mp.weixin.qq.com/s/SgteE94sZfAMv5mZJYrTqw 解析器：词法（关键词、符号匹配）、语法（形成语法树）、语义分析（存在性与合法性） 优化器: ​ RBO基于规则优化:简化条件(删除类似的条件)，表链接优化(query tree优化)，scan优化（索引-\u003e全表） ​ CBO基于代价优化: 执行器：火山模型，优点：独立抽象实现，互相之间没有耦合，逻辑结构简单 缺点：没计算一条数据又多次函数调用开销磨，导致CPU效率不高 向量化 每个Operator每次操作计算的不再是一行数据，而是一批数据(Batch N行数据)，计算完成后向上层算子返回一个Batch。 优点 函数调用次数降低为1/N : CPU cache命中率更高 可以利用CPU提供的SIMD(Single Instruction Multi Data)机制 mysql查询语句 mysql底层数据结构，查询过程 mysql和mongo的区别，为什么选mysql 编译执行：动态编译执行技术LLVM mysql锁机制 9、MVCC 11、保证幂等性的方案 有聚合函数时select的列需要在聚合或者groupby中 内存缓冲池、到extendible hashtable索引、到火山模型、到事务控制, 哈希索引的并发控制） MYSQL的端口号 项目数据库的表组成，表的设计，三范式（优劣） 对范式有哪些了解呢 范式的作用是什么 Mysql为什么要使用两阶段提交？ 后端的业务系统是否适合范式理论 了解过数据库除范式之外的其他理论吗 自增id用尽 null存储形式 数据库的四大范式讲一讲？ 数据一致性？ 写并发如何执行 数据库是如何实现分页查询的， 当数据量很大的时候， 如何提高效率。 mysql 数据误删怎么还原（给的方案是找到最近的备份文件，然后通过bin日志和relay日志恢复剩下的数据）其实还可以回滚 Sql注入攻击 设计数据库连接池需要考虑:1. 连接池容量及初始大小设置;2. 获取连接超时时间设置;3. 连接最大生命周期设置; 4. 连接的获取与释放实现;5. 连接的定期检测与维护;6. 是否实现连接池规范如DataSource; 7. 额外功能如连接泄漏检测等;8. 不同数据库的特点,如Oracle限制的连接数。 ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#mysql中一个update语句什么情况下会很慢"},{"categories":["interview"],"content":" Server 层数据库连接池怎么设计的？ jdbc database connection pool https://www.progress.com/tutorials/jdbc/jdbc-jdbc-connection-pooling 数据库的几种连接和区别 MySQL的blob和text的区别？ SQL执行过程 数据库连接池怎么设计的？ 用什么数据结构？ 连接池满了，此时要建立新的连接怎么办？ 执行计划了解吗？ 优化器的原理知道嘛？ 连接操作join了解嘛？（左连接，右连接，内连接） inner join连接操作怎么实现的？（问底层） join的时间复杂度？（加索引和不加索引） ","date":"2023-08-12","objectID":"/interview/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#server-层"},{"categories":["interview"],"content":" 引擎层设置自增主键索引时，如果达到上限的话怎么办？这条SQL还能执行成功吗？ 分库分表，不借助中间件怎么实现，MyCat了解过吗（不了解），分库和分表怎么选择？结合项目场景讨论划分规则 ","date":"2023-08-12","objectID":"/interview/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#引擎层"},{"categories":["interview"],"content":" innodb特性与其他引擎对比哪种情况下该使用innodb，哪种情况下使用myisam呢？ MYSQL常用的存储引擎，介绍一下它们索引的实现方法 为什么MyISAM效率高 顺带索引结构，聚簇索引和非聚簇索引 innodb特点 innodb索引物理结构 主键，回表，覆盖索引 与MyISAM对比 ","date":"2023-08-12","objectID":"/interview/:2:1","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#innodb特性与其他引擎对比"},{"categories":["interview"],"content":" 文件Undolog redolog binlog，写了一些什么内容？用什么方法写的？什么时候写？ 持久化先提交redolog还是binlog ","date":"2023-08-12","objectID":"/interview/:2:2","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#文件"},{"categories":["interview"],"content":" 事务什么是数据库事务？事务的作用是什么？ 1.事务的四种性质 ，如何保证，如何实现，实现原理（MVCC原理扩展到了InnoDB可重复读级别的实现 2.如何实现的隔离性、原子性 MVCC是怎么实现的 mysql是怎么实现RR的？ 既然串行化能解决幻读，为什么还用间隙锁去解决幻读？ 四种隔离等级，分别做了什么，带来什么问题，怎么解决。隔离级别如何实现的（深入到ReadView和next-key lock，需不需要索引？） -\u003e什么情况下next-key会退化 什么时候会用到Serializable？ 默认RR ","date":"2023-08-12","objectID":"/interview/:2:3","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#事务"},{"categories":["interview"],"content":" 索引MysQL主键索引，唯一索引的区别，两种索引的存储结构是怎样的，在内存方面是怎么存的，查询时是怎么走的？ mysql优化、索引、执行过程、缓存 InnoDB里聚簇索引和普通索引区别是什么？（扯了B+树模型本身以及两个索引的区别） 为什么有最左前缀原则，为什么要设计最左前缀原则？（即B+树中为什么要排序）？（从磁盘存储，磁盘寻道过程上答，推荐宝宝睡前故事这本书） 为什么普通索引里存储的是主键的值，为什么不是像文件偏移量这种数据呢？（因为地址在变） 索引为什么用B+树实现呢？（围绕减少磁盘IO开扯） 除了提升磁盘效率以外还有什么原因呢？（围绕范围查询开扯） 除了这两点以外还有什么原因吗？有一个非常基础的原因（有利于顺序写吗，因为数据是有序的…） mysql推荐自增主键的原因，我能不能用字符串和随机数取做一个主键？（扯到B+树结构，追加写，防止页分裂…） 那使用自增主键也有一些坏处，有哪些？（分布式场景中自增主键的比较难获取…） 设计联合索引的时候，如何考虑字段的顺序？查询频率、数据独特、字段长度 不同引擎的索引种类，数据结构，优缺点 innodb的索引种类：数据结构划分，btree，hash，倒排索引，r，各种索引实现的数据结构？ 主键索引需要将索引全部加载到内存里面吗 mysql的主键索引和非主键索引是什么 索引分类-\u003e非聚簇索引和聚簇索引-\u003e区别？ 物理上分为聚簇索引和非聚簇索引 性别字段要建立索引吗？为什么？ 什么是区分度？ 索引的缺点，优点，三种添加方式 主键索引需要将索引全部加载到内存里面吗 叶子节点满了，叶子节点最大有多少 联合索引？能做范围查询吗 怎么进行索引调优 Mysql的索引底层实现 除了B+树之外还有吗？adaptive hash index，倒排索引， B+树的操作时间复杂度 有其他数据结构更低的吗 数据库为什么不使用哈希表做底层索引 什么是索引覆盖 ABC建立联合索引，什么走索引？ 为什么有这个最左匹配现象？ 11.B+树和B树建立索引会表现出什么性能区别？举例子 12.举一个sql例子，能充分利用上叶子节点的双向链表 13.只有叶子节点有数据，这个有什么影响？ 14.场景题（update语句group by) 聚集索引和辅助索引的区别？ 索引覆盖是啥啊？ 辅助索引的叶子节点存的是啥啊？ 建立索引的列的value 和对应主键 MySQL有哪些索引相关的规则 讲一讲索引下推 MySQL 有哪些索引？（主键，唯一，普通） 聚类、非聚类索引区别？ 联合索引 abc，查 a（走索引），查 b （不走），查 b = 1 and a = 1（走），查 a \u003e 0 and b = 1 （走，但 b 列走不了） 最后一个情况，为什么 a 走 b 不走？（最左匹配） 你给我详细分析一下 a \u003e 0 and b = 1 查询索引的过程？（我说先匹配 a，再通过叶子节点链表取出数据过滤 b） 如果一定要用索引匹配 b，怎么设计这个算法？（二分？想了一下挺麻烦的） B+ 树叶子节点是链表怎么二分？（同页上的数据可以二分，页结构中有一个数组） 怎么知道命中索引了没？（explain） like 左边有通配符为什么不匹配？（不知道，感觉和最左匹配差不多） 索引的种类 数据结构mysql的索引用的什么数据结构 B+树属于二叉树么 为什么不用红黑树 红黑树和B+树的区别 mysql为什么用B+树做索引为什么不用（B树、跳表、红黑树、二叉树、哈希表）做索引？ mysql中B+ Tree索引和Hash索引的实现，各自优缺点（比如hash为什么不能范围查找？二叉树的时间复杂度，页读取减少IO次数，范围查找） b+树为什么设计成非子叶节点只有索引？ B+树有什么缺点？ B树和B+树的区别？ B+树存储的形式 B+树的并发问题，效率问题 红黑树跟b+树的区别 索引优化有哪些 B+树在mysql里的实现 B+树插入数据的流程 如何查看sql命令是否用到索引 主键索引和非主键索引的B+树的区别？ 为什么非主键索引的叶子节点为什么不存记录的地址 创建索引时需要注意什么 建立索引有什么要求？一个表能建多少个索引？ 如果删除索引出现问题了导致锁表怎么办？ 索引结构？ 回表什么事回表？ 怎么减少回表？ 回表出现错误怎么办产生回表的原因？ 举一个需要回表的例子？ innodb 辅助索引为什么存主键 id，回表不是要浪费时间？ 索引失效mysql索引什么情况下会失效, 正在创建中的索引。为什么会失效。 能够使用\u003e和\u003e=的时候你会使用哪一个？为什么？ 组合索引（a,b,c），查询a，c能不能走索引，为什么不能？ mysql的索引设计 前面提到了有时候索引的大小会比原来的数据还大，举例？ 如果是一样的数据，有序插入和随机插入，对于索引来说哪一种更好一些（答有序，插入会大体集中在同几个node上，磁盘cache友好，最后的node空间利用率也更高。随机会随机访问node，而且node分裂也不集中） 小奖励：如果在事务提交的过程中宕机了，那么在恢复数据的时候，是如何恢复的？ mysql事务提交的详细过程以及在其中失败了要怎么恢复？ 为什么不符合最左前缀匹配原则会不走索引 为什么不适用哈希索引，效率不是更高吗？ 那么自适应哈希索引又是干什么的呢？ 当查询条件有xx == null 时索引一定会失效吗 不加索引怎么优化连接操作？（大表在前，小表在后）还有嘛？（加缓存？不太确定） ","date":"2023-08-12","objectID":"/interview/:2:4","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#索引"},{"categories":["interview"],"content":" 索引MysQL主键索引，唯一索引的区别，两种索引的存储结构是怎样的，在内存方面是怎么存的，查询时是怎么走的？ mysql优化、索引、执行过程、缓存 InnoDB里聚簇索引和普通索引区别是什么？（扯了B+树模型本身以及两个索引的区别） 为什么有最左前缀原则，为什么要设计最左前缀原则？（即B+树中为什么要排序）？（从磁盘存储，磁盘寻道过程上答，推荐宝宝睡前故事这本书） 为什么普通索引里存储的是主键的值，为什么不是像文件偏移量这种数据呢？（因为地址在变） 索引为什么用B+树实现呢？（围绕减少磁盘IO开扯） 除了提升磁盘效率以外还有什么原因呢？（围绕范围查询开扯） 除了这两点以外还有什么原因吗？有一个非常基础的原因（有利于顺序写吗，因为数据是有序的…） mysql推荐自增主键的原因，我能不能用字符串和随机数取做一个主键？（扯到B+树结构，追加写，防止页分裂…） 那使用自增主键也有一些坏处，有哪些？（分布式场景中自增主键的比较难获取…） 设计联合索引的时候，如何考虑字段的顺序？查询频率、数据独特、字段长度 不同引擎的索引种类，数据结构，优缺点 innodb的索引种类：数据结构划分，btree，hash，倒排索引，r，各种索引实现的数据结构？ 主键索引需要将索引全部加载到内存里面吗 mysql的主键索引和非主键索引是什么 索引分类-\u003e非聚簇索引和聚簇索引-\u003e区别？ 物理上分为聚簇索引和非聚簇索引 性别字段要建立索引吗？为什么？ 什么是区分度？ 索引的缺点，优点，三种添加方式 主键索引需要将索引全部加载到内存里面吗 叶子节点满了，叶子节点最大有多少 联合索引？能做范围查询吗 怎么进行索引调优 Mysql的索引底层实现 除了B+树之外还有吗？adaptive hash index，倒排索引， B+树的操作时间复杂度 有其他数据结构更低的吗 数据库为什么不使用哈希表做底层索引 什么是索引覆盖 ABC建立联合索引，什么走索引？ 为什么有这个最左匹配现象？ 11.B+树和B树建立索引会表现出什么性能区别？举例子 12.举一个sql例子，能充分利用上叶子节点的双向链表 13.只有叶子节点有数据，这个有什么影响？ 14.场景题（update语句group by) 聚集索引和辅助索引的区别？ 索引覆盖是啥啊？ 辅助索引的叶子节点存的是啥啊？ 建立索引的列的value 和对应主键 MySQL有哪些索引相关的规则 讲一讲索引下推 MySQL 有哪些索引？（主键，唯一，普通） 聚类、非聚类索引区别？ 联合索引 abc，查 a（走索引），查 b （不走），查 b = 1 and a = 1（走），查 a \u003e 0 and b = 1 （走，但 b 列走不了） 最后一个情况，为什么 a 走 b 不走？（最左匹配） 你给我详细分析一下 a \u003e 0 and b = 1 查询索引的过程？（我说先匹配 a，再通过叶子节点链表取出数据过滤 b） 如果一定要用索引匹配 b，怎么设计这个算法？（二分？想了一下挺麻烦的） B+ 树叶子节点是链表怎么二分？（同页上的数据可以二分，页结构中有一个数组） 怎么知道命中索引了没？（explain） like 左边有通配符为什么不匹配？（不知道，感觉和最左匹配差不多） 索引的种类 数据结构mysql的索引用的什么数据结构 B+树属于二叉树么 为什么不用红黑树 红黑树和B+树的区别 mysql为什么用B+树做索引为什么不用（B树、跳表、红黑树、二叉树、哈希表）做索引？ mysql中B+ Tree索引和Hash索引的实现，各自优缺点（比如hash为什么不能范围查找？二叉树的时间复杂度，页读取减少IO次数，范围查找） b+树为什么设计成非子叶节点只有索引？ B+树有什么缺点？ B树和B+树的区别？ B+树存储的形式 B+树的并发问题，效率问题 红黑树跟b+树的区别 索引优化有哪些 B+树在mysql里的实现 B+树插入数据的流程 如何查看sql命令是否用到索引 主键索引和非主键索引的B+树的区别？ 为什么非主键索引的叶子节点为什么不存记录的地址 创建索引时需要注意什么 建立索引有什么要求？一个表能建多少个索引？ 如果删除索引出现问题了导致锁表怎么办？ 索引结构？ 回表什么事回表？ 怎么减少回表？ 回表出现错误怎么办产生回表的原因？ 举一个需要回表的例子？ innodb 辅助索引为什么存主键 id，回表不是要浪费时间？ 索引失效mysql索引什么情况下会失效, 正在创建中的索引。为什么会失效。 能够使用\u003e和\u003e=的时候你会使用哪一个？为什么？ 组合索引（a,b,c），查询a，c能不能走索引，为什么不能？ mysql的索引设计 前面提到了有时候索引的大小会比原来的数据还大，举例？ 如果是一样的数据，有序插入和随机插入，对于索引来说哪一种更好一些（答有序，插入会大体集中在同几个node上，磁盘cache友好，最后的node空间利用率也更高。随机会随机访问node，而且node分裂也不集中） 小奖励：如果在事务提交的过程中宕机了，那么在恢复数据的时候，是如何恢复的？ mysql事务提交的详细过程以及在其中失败了要怎么恢复？ 为什么不符合最左前缀匹配原则会不走索引 为什么不适用哈希索引，效率不是更高吗？ 那么自适应哈希索引又是干什么的呢？ 当查询条件有xx == null 时索引一定会失效吗 不加索引怎么优化连接操作？（大表在前，小表在后）还有嘛？（加缓存？不太确定） ","date":"2023-08-12","objectID":"/interview/:2:4","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#数据结构"},{"categories":["interview"],"content":" 索引MysQL主键索引，唯一索引的区别，两种索引的存储结构是怎样的，在内存方面是怎么存的，查询时是怎么走的？ mysql优化、索引、执行过程、缓存 InnoDB里聚簇索引和普通索引区别是什么？（扯了B+树模型本身以及两个索引的区别） 为什么有最左前缀原则，为什么要设计最左前缀原则？（即B+树中为什么要排序）？（从磁盘存储，磁盘寻道过程上答，推荐宝宝睡前故事这本书） 为什么普通索引里存储的是主键的值，为什么不是像文件偏移量这种数据呢？（因为地址在变） 索引为什么用B+树实现呢？（围绕减少磁盘IO开扯） 除了提升磁盘效率以外还有什么原因呢？（围绕范围查询开扯） 除了这两点以外还有什么原因吗？有一个非常基础的原因（有利于顺序写吗，因为数据是有序的…） mysql推荐自增主键的原因，我能不能用字符串和随机数取做一个主键？（扯到B+树结构，追加写，防止页分裂…） 那使用自增主键也有一些坏处，有哪些？（分布式场景中自增主键的比较难获取…） 设计联合索引的时候，如何考虑字段的顺序？查询频率、数据独特、字段长度 不同引擎的索引种类，数据结构，优缺点 innodb的索引种类：数据结构划分，btree，hash，倒排索引，r，各种索引实现的数据结构？ 主键索引需要将索引全部加载到内存里面吗 mysql的主键索引和非主键索引是什么 索引分类-\u003e非聚簇索引和聚簇索引-\u003e区别？ 物理上分为聚簇索引和非聚簇索引 性别字段要建立索引吗？为什么？ 什么是区分度？ 索引的缺点，优点，三种添加方式 主键索引需要将索引全部加载到内存里面吗 叶子节点满了，叶子节点最大有多少 联合索引？能做范围查询吗 怎么进行索引调优 Mysql的索引底层实现 除了B+树之外还有吗？adaptive hash index，倒排索引， B+树的操作时间复杂度 有其他数据结构更低的吗 数据库为什么不使用哈希表做底层索引 什么是索引覆盖 ABC建立联合索引，什么走索引？ 为什么有这个最左匹配现象？ 11.B+树和B树建立索引会表现出什么性能区别？举例子 12.举一个sql例子，能充分利用上叶子节点的双向链表 13.只有叶子节点有数据，这个有什么影响？ 14.场景题（update语句group by) 聚集索引和辅助索引的区别？ 索引覆盖是啥啊？ 辅助索引的叶子节点存的是啥啊？ 建立索引的列的value 和对应主键 MySQL有哪些索引相关的规则 讲一讲索引下推 MySQL 有哪些索引？（主键，唯一，普通） 聚类、非聚类索引区别？ 联合索引 abc，查 a（走索引），查 b （不走），查 b = 1 and a = 1（走），查 a \u003e 0 and b = 1 （走，但 b 列走不了） 最后一个情况，为什么 a 走 b 不走？（最左匹配） 你给我详细分析一下 a \u003e 0 and b = 1 查询索引的过程？（我说先匹配 a，再通过叶子节点链表取出数据过滤 b） 如果一定要用索引匹配 b，怎么设计这个算法？（二分？想了一下挺麻烦的） B+ 树叶子节点是链表怎么二分？（同页上的数据可以二分，页结构中有一个数组） 怎么知道命中索引了没？（explain） like 左边有通配符为什么不匹配？（不知道，感觉和最左匹配差不多） 索引的种类 数据结构mysql的索引用的什么数据结构 B+树属于二叉树么 为什么不用红黑树 红黑树和B+树的区别 mysql为什么用B+树做索引为什么不用（B树、跳表、红黑树、二叉树、哈希表）做索引？ mysql中B+ Tree索引和Hash索引的实现，各自优缺点（比如hash为什么不能范围查找？二叉树的时间复杂度，页读取减少IO次数，范围查找） b+树为什么设计成非子叶节点只有索引？ B+树有什么缺点？ B树和B+树的区别？ B+树存储的形式 B+树的并发问题，效率问题 红黑树跟b+树的区别 索引优化有哪些 B+树在mysql里的实现 B+树插入数据的流程 如何查看sql命令是否用到索引 主键索引和非主键索引的B+树的区别？ 为什么非主键索引的叶子节点为什么不存记录的地址 创建索引时需要注意什么 建立索引有什么要求？一个表能建多少个索引？ 如果删除索引出现问题了导致锁表怎么办？ 索引结构？ 回表什么事回表？ 怎么减少回表？ 回表出现错误怎么办产生回表的原因？ 举一个需要回表的例子？ innodb 辅助索引为什么存主键 id，回表不是要浪费时间？ 索引失效mysql索引什么情况下会失效, 正在创建中的索引。为什么会失效。 能够使用\u003e和\u003e=的时候你会使用哪一个？为什么？ 组合索引（a,b,c），查询a，c能不能走索引，为什么不能？ mysql的索引设计 前面提到了有时候索引的大小会比原来的数据还大，举例？ 如果是一样的数据，有序插入和随机插入，对于索引来说哪一种更好一些（答有序，插入会大体集中在同几个node上，磁盘cache友好，最后的node空间利用率也更高。随机会随机访问node，而且node分裂也不集中） 小奖励：如果在事务提交的过程中宕机了，那么在恢复数据的时候，是如何恢复的？ mysql事务提交的详细过程以及在其中失败了要怎么恢复？ 为什么不符合最左前缀匹配原则会不走索引 为什么不适用哈希索引，效率不是更高吗？ 那么自适应哈希索引又是干什么的呢？ 当查询条件有xx == null 时索引一定会失效吗 不加索引怎么优化连接操作？（大表在前，小表在后）还有嘛？（加缓存？不太确定） ","date":"2023-08-12","objectID":"/interview/:2:4","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#回表"},{"categories":["interview"],"content":" 索引MysQL主键索引，唯一索引的区别，两种索引的存储结构是怎样的，在内存方面是怎么存的，查询时是怎么走的？ mysql优化、索引、执行过程、缓存 InnoDB里聚簇索引和普通索引区别是什么？（扯了B+树模型本身以及两个索引的区别） 为什么有最左前缀原则，为什么要设计最左前缀原则？（即B+树中为什么要排序）？（从磁盘存储，磁盘寻道过程上答，推荐宝宝睡前故事这本书） 为什么普通索引里存储的是主键的值，为什么不是像文件偏移量这种数据呢？（因为地址在变） 索引为什么用B+树实现呢？（围绕减少磁盘IO开扯） 除了提升磁盘效率以外还有什么原因呢？（围绕范围查询开扯） 除了这两点以外还有什么原因吗？有一个非常基础的原因（有利于顺序写吗，因为数据是有序的…） mysql推荐自增主键的原因，我能不能用字符串和随机数取做一个主键？（扯到B+树结构，追加写，防止页分裂…） 那使用自增主键也有一些坏处，有哪些？（分布式场景中自增主键的比较难获取…） 设计联合索引的时候，如何考虑字段的顺序？查询频率、数据独特、字段长度 不同引擎的索引种类，数据结构，优缺点 innodb的索引种类：数据结构划分，btree，hash，倒排索引，r，各种索引实现的数据结构？ 主键索引需要将索引全部加载到内存里面吗 mysql的主键索引和非主键索引是什么 索引分类-\u003e非聚簇索引和聚簇索引-\u003e区别？ 物理上分为聚簇索引和非聚簇索引 性别字段要建立索引吗？为什么？ 什么是区分度？ 索引的缺点，优点，三种添加方式 主键索引需要将索引全部加载到内存里面吗 叶子节点满了，叶子节点最大有多少 联合索引？能做范围查询吗 怎么进行索引调优 Mysql的索引底层实现 除了B+树之外还有吗？adaptive hash index，倒排索引， B+树的操作时间复杂度 有其他数据结构更低的吗 数据库为什么不使用哈希表做底层索引 什么是索引覆盖 ABC建立联合索引，什么走索引？ 为什么有这个最左匹配现象？ 11.B+树和B树建立索引会表现出什么性能区别？举例子 12.举一个sql例子，能充分利用上叶子节点的双向链表 13.只有叶子节点有数据，这个有什么影响？ 14.场景题（update语句group by) 聚集索引和辅助索引的区别？ 索引覆盖是啥啊？ 辅助索引的叶子节点存的是啥啊？ 建立索引的列的value 和对应主键 MySQL有哪些索引相关的规则 讲一讲索引下推 MySQL 有哪些索引？（主键，唯一，普通） 聚类、非聚类索引区别？ 联合索引 abc，查 a（走索引），查 b （不走），查 b = 1 and a = 1（走），查 a \u003e 0 and b = 1 （走，但 b 列走不了） 最后一个情况，为什么 a 走 b 不走？（最左匹配） 你给我详细分析一下 a \u003e 0 and b = 1 查询索引的过程？（我说先匹配 a，再通过叶子节点链表取出数据过滤 b） 如果一定要用索引匹配 b，怎么设计这个算法？（二分？想了一下挺麻烦的） B+ 树叶子节点是链表怎么二分？（同页上的数据可以二分，页结构中有一个数组） 怎么知道命中索引了没？（explain） like 左边有通配符为什么不匹配？（不知道，感觉和最左匹配差不多） 索引的种类 数据结构mysql的索引用的什么数据结构 B+树属于二叉树么 为什么不用红黑树 红黑树和B+树的区别 mysql为什么用B+树做索引为什么不用（B树、跳表、红黑树、二叉树、哈希表）做索引？ mysql中B+ Tree索引和Hash索引的实现，各自优缺点（比如hash为什么不能范围查找？二叉树的时间复杂度，页读取减少IO次数，范围查找） b+树为什么设计成非子叶节点只有索引？ B+树有什么缺点？ B树和B+树的区别？ B+树存储的形式 B+树的并发问题，效率问题 红黑树跟b+树的区别 索引优化有哪些 B+树在mysql里的实现 B+树插入数据的流程 如何查看sql命令是否用到索引 主键索引和非主键索引的B+树的区别？ 为什么非主键索引的叶子节点为什么不存记录的地址 创建索引时需要注意什么 建立索引有什么要求？一个表能建多少个索引？ 如果删除索引出现问题了导致锁表怎么办？ 索引结构？ 回表什么事回表？ 怎么减少回表？ 回表出现错误怎么办产生回表的原因？ 举一个需要回表的例子？ innodb 辅助索引为什么存主键 id，回表不是要浪费时间？ 索引失效mysql索引什么情况下会失效, 正在创建中的索引。为什么会失效。 能够使用\u003e和\u003e=的时候你会使用哪一个？为什么？ 组合索引（a,b,c），查询a，c能不能走索引，为什么不能？ mysql的索引设计 前面提到了有时候索引的大小会比原来的数据还大，举例？ 如果是一样的数据，有序插入和随机插入，对于索引来说哪一种更好一些（答有序，插入会大体集中在同几个node上，磁盘cache友好，最后的node空间利用率也更高。随机会随机访问node，而且node分裂也不集中） 小奖励：如果在事务提交的过程中宕机了，那么在恢复数据的时候，是如何恢复的？ mysql事务提交的详细过程以及在其中失败了要怎么恢复？ 为什么不符合最左前缀匹配原则会不走索引 为什么不适用哈希索引，效率不是更高吗？ 那么自适应哈希索引又是干什么的呢？ 当查询条件有xx == null 时索引一定会失效吗 不加索引怎么优化连接操作？（大表在前，小表在后）还有嘛？（加缓存？不太确定） ","date":"2023-08-12","objectID":"/interview/:2:4","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#索引失效"},{"categories":["interview"],"content":" coding求连续出现3次的数字 mysql如何查看最近慢查询 Mysql的慢查询如何排查？ 如何监控redo日志的刷盘频率？ l0层的sstableMyRocks介绍一下 如果使用 MySQL，怎么实现原子自增 简单sql：查询班上英语成绩最高的同学（可能有多个） 求所有女性平均年龄大于30的城市 用户关系表，主键id字段，用户id(user_id)，组织id(group_id)，表中有8000万+数据，每个用户对应几百个组织id，组织id不重复，你会怎么建索引，（建联合索引好还是单纯user_id好，实际两个都不好，这是一个场景问题？？）（可能得从数据库范式方面分析这个表结构是否合理） 表 学生id 班级id 分数 第一题:查询每个班的平均分和班级id 第二题:查询每个班分数最高的人的id 和分数 当查询数据库时使用limit 10000，10有什么弊端？有什么好的解决方案吗？ Sql题：表1 “id,score,type” type中存有1，2，3三种类型 将其转换成表2 “id,score_1,score_2,score_3” Sql题：找到热搜列表中一天内点赞次数最多的前十条博客，找出最新更新的十篇帖子 找到用户最近的登陆时间 一个城市的所有用户 Sql题：找到热搜列表中一天内点赞次数最多的前十条博客，找出最新更新的十篇帖子 来了一堆乱序的sql请求，有一堆update和insert，没有版本号没有时间戳，如何让它们正确执行？（懵了…面试官提醒后意识到是考察具体sql语句，但没写过insert和update合并语句，不会 两个表，一个personid一个address，不管有没有地址信息，输出所有personde的表中信息 一个表，有姓名、学号和性别，查找出学号最小的10个学生（写出来）（排序） 新增一个学生信息进去（写出来） sql题,查询age第二大的行 select * from t order by age limit 1,1; 追问:如果有age重复数据,把重复数据都查出来(没想到子查询,没做出来,平时八股文,mysql原理背的多，实际操作好烂) 有一张product表，product(id, title, category, sub_category)，索引index(sub_category, category)，写一条SQL来查询product表中category = 10并且sub_category = 10010的数据 答： 复制代码 select * from productwheresub_category = ``10010 and cate_gory = ``10``; 问：为什么要把sub_category放在这里 答：因为要符合索引的最左匹配原则 问：那把sub_category的查询条件改成大于10010，这条语句还能走索引吗？ 答：（实在没想明白）能 问：那把category的查询条件改成大于10呢？ 答：（依旧没想明白）不能 查询薪水最大值；每个主管的薪水最大值员工 2.1 写一个MySQL语句 -\u003e 类似 185. 部门工资前三高的所有员工 ","date":"2023-08-12","objectID":"/interview/:2:5","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#coding"},{"categories":["interview"],"content":" 引擎InnodB怎么实现崩溃后数据恢复的 数据库内核实现 mysql常用的存储引擎 mysql的乐观锁、悲观锁详细介绍一下 InnoDB和MyISAM的区别 姓名 学科 成绩 选出所有科目成绩都在80以上的同学的名字 添加一个用户数据类型，讲了数据库堆页、TOAST、overflow、vacuum、超大row的插入、行插入最近使用页、脏页落盘。实验里的细节：端序，变长类型的存储。数据库事务、MVCC、隔离等级（隔离等级因为自己项目用不上，不是非常熟悉，说得不咋样） PG里面的页，插入数据的时候是从后面插入的，能讲一下吗？（不太清楚） 幻读 select d from table where a \u003e 100 and b = 1 order by c desc.如何建立索引？（联合索引，索引实效，底层B+树，回表等）联合索引顺序 (a,b,c)？（是的） 范围查找可以用索引嘛？（可以，但具体执行要看优化器如何优化） 共享单车这个场景需要什么表，我回答需要用户表，单车分配表，车辆维修管理表 然后就问怎么分析出哪个地方的车不够用需要增加自行车，我说可以根据区域内开锁和解锁的数量，或者根据区域用户活跃度。 然后面试官说 华强北每天几万人上下班车辆都不够用，你怎么知道够不够用？？ 我想着这怎么分配都不可能够用呀。。我学校每天上下课高峰车都不够用，而且车已经很多了，高峰期也不会够用呀。。 我后面还是坚持这个说法，他又开始举例，比如说这个区域只有十辆车，每天开锁解锁也就这10辆，怎么知道车够不够用。（我实在是不会，脑瓜子热 分析不出来啊。。） 隔离级别。 为什么选RR隔离级别。 统计连续三天访问同一个网站的活跃用户 MySQL的隔离级别。 各级别有什么问题（脏读，不可重复读）。 RR级别是如何解决幻读的。 MVCC是如何实现的。 MySQL有哪些锁，有什么作用。 MySQL事务特性，ACID，隔离级别，MVCC怎么实现？可重复读？ mysql同步原理 如何做主从和数据同步 什么是事务 ","date":"2023-08-12","objectID":"/interview/:2:6","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#引擎"},{"categories":["interview"],"content":" 分页、分段管理7.分段和分页的区别？ ","date":"2023-08-12","objectID":"/interview/:2:7","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#分页分段管理"},{"categories":["interview"],"content":" 锁数据库的锁介绍一下 你提到的共享锁互斥锁和共享锁悲观锁的区别和关系是什么 select for update 是加表锁还是行锁 行锁最大并发数 ","date":"2023-08-12","objectID":"/interview/:2:8","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#锁"},{"categories":["interview"],"content":" 分布式事务seata 分布式事务 数据库之间的主从同步 MySQL实现分布式锁 分布式事务的中间件和解决方案 MySQL 的乐观锁和悲观锁 具体的乐观锁悲观锁的实现场景 讲一下脏读和幻读的区别 怎么解决脏读和幻读的问题 MVCC 怎么解决脏读 MySQL 有哪些锁 间隙锁的作用是什么 读写锁了解吗 自旋锁的概念 如果递归地进行自旋锁会怎样 怎么设计可重入锁 ","date":"2023-08-12","objectID":"/interview/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#分布式事务"},{"categories":["interview"],"content":" Java基础和多线程jit 封装、继承、多态 反射 多态的实现机制 面向对象，多态的底层原理，接口和抽象类有什么区别与联系，说说使用场景 泛型， 多线程，线程，创建线程的方式，线程池底层原理和参数设置 集合框架：原理，源码，使用场景，时间复杂度，Collections.sort（）底层原理，Set 了解过吗?知道 add() 会出什么问题吗? 异常处理：Exception，Error 关键字（底层与语义与实际保障）：final、finally、finalize、synchronized、volatile 关键类（类中的方法与作用）：Object，ThreadLocal，String，System concurrenthashmap与hashmap底层数据结构，jdk1.8的锁如何实现 hashCode 和 equals 方法有什么关系，尤其是当使用哈希表的时候，这两个方法要同时重写吗，如果两个对象的 equals 为 true 那他们的 hashCode 的值是不是必须要一样，反过来呢，那什么叫哈希冲突呢，哈希冲突怎么处理呢，wait 和 notify 有什么用，wait 和 sleep 方法有什么区别，wait 方法的参数指定时间有什么用吗，finalize 方法有什么用、什么时候调用呢 异常有哪些分类？Error 和 Exception都是谁的子类？ 锁的类型 讲讲Java底层结构集合 hashmap，底层是什么，版本区别，怎么线程不安全，为什么有segment分段索 String.intern()，使用场景 spinlock单核实现（不知道，底层是CAS吗？讲了下CAS原理，老哥说没这么复杂就是死循环） StringBuilder及StringBuffer的区别 concurrentHashmap提升效率的原因 Java 的 Object 有哪些方法？ equals() 和 hashcode() 八股 哈希冲突如何解决？（开放定址，链接法，再哈希） 这些办法的优缺点？ 负载因子是什么？怎么算？ clone() 怎么用？引用拷贝深拷贝浅拷贝？ wait() 和 sleep() 八股，包括区别 HashMap，结构，插入，扩容等，相同hashcode一定插入一个key value吗 TreeMap对key有什么要求，它是根据什么来排序的 父子进程用过没？ 父子进程的内存是拷贝还是共享？ 公共库之类的资源，操作系统是怎么实现父子进程共享的？ 乐观所与悲观所 进程线程的区别，多进程比多线程稳定吗，进程如何通信，线程如何通信 管道自己用过没 IO多路复用 介绍ThreadLocal，ThreadLocal为什么会出现内存泄露问题，ThreadLocal的key为什么设计成弱引用 我设计如何多线程安全地修改共享变量， 同时性能高。 线程同步中，锁的实现原理 举一个多线程和多进程软件的例子，浏览器页面为什么要用多进程 synchronized 多线程如何不加锁实现同步？多线程不加锁 实现同步怎么做 缓存一致性。 进程间通信方式。 java的io了解吗？ 多路复用说一下 僵尸进程 五种io模型 synchronized和lock区别 深拷贝浅拷贝说一下 乐观锁和悲观锁你的理解。使用场景 进程间同步的几种方式 多线程 进程、线程、虚拟线程 乐观锁和悲观锁、乐观锁实现方式（没答上来） 死锁概念及产生条件 死锁怎么办？ 守护进程 double占多少个字节，double为什么会精度丢失 hash冲突的解决 java的hashCode和equals hashCode的设计原则（怎么保证离散性） 线程安全的Map 怎么自己设计一个Synchronized ReentrantLock CAS volatile ReentrantLook和Synchronized的区别 减少Hash冲突的办法？ 一致性hash ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#java基础和多线程"},{"categories":["interview"],"content":" JVM变量从产生到结束，字符串常量呢？ ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#jvm"},{"categories":["interview"],"content":" 实战如何查看堆内存信息 出现OOM如何排查 jps jstack jmap jvm 虚拟机老年代什么情况下会发生 gc，给你一个场景，一台 4 核 8G 的服务器，每隔两 个小时就要出现一次老年代 gc，现在有日志，怎么分析是哪里出了问题 ","date":"2023-08-12","objectID":"/interview/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#实战"},{"categories":["interview"],"content":" 内存模型jvm内存模型 每个地方是做什么的，作用、相关错误、如何检测、如何解决 什么时候内存泄漏？如何解决？ 怎样排查 CPU 彪高、内存彪高 ","date":"2023-08-12","objectID":"/interview/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#内存模型"},{"categories":["interview"],"content":" GCgc时机 如何查看垃圾收集器状态 如何分析gc日志，分析堆转储快照 为什么jdk8移除永久代，并把方法区移至元空间？元空间需要GC吗？是young gc还是full gc G1的使用场景和实现原理，rememberd set的作用，什么时候会往里面写更新？Collection set的作用？ g1和cms区别 老年代频繁回收如何分析解决 如何gc调优 垃圾收集器和垃圾回收算法 可达性分析算法中根节点有哪些 gc算法：老年代和新生代使用了什么算法？对象如何进入老年代？ 乐观锁和悲观锁 乐观锁的使用场景、使用乐观锁的产品或者中间件 锁升级介绍一下 Java进程和线程、以及jvm以及操作系统中间的关系 Java类加载过程 JVM强引用/弱引用在内存中的分布 线程池空闲线程到底是杀掉还是保留 JVM怎么查有什么线程，JVM常用的命令（啊？真没用过，我只背了八股，看来是不够） JVM怎么判断一个对象要回收，可达性算法的根节点是什 空类占几个字节；字节对齐的好处 加载器双亲委派模型及破坏 死锁的原因及预防 ","date":"2023-08-12","objectID":"/interview/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#gc"},{"categories":["interview"],"content":" 类加载类加载器 双亲委派模型 类加载机制 ","date":"2023-08-12","objectID":"/interview/:4:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#类加载"},{"categories":["interview"],"content":" JUCSemaphore 多线程怎么同步 线程中断有什么用，若某个线程的 run()方法正常运行，执行累加运算，调用 Thread. interrupt()，会发生什么? 多线程是不是肯定比单线程好? 什么样的任务适合用多线程什么适合单线程? 单 CPU 的情况下适合用多线程吗? wait 和 sleep 区别 rentrantlock使用场景 ThreadLocal的应用会导致什么问题？如何用Mybatis的原理解决？ AQS原理 线程实现方式 COuntyDownLatch和CyclocBarrier区别 volatile 从指令重排序，内存屏障，聊到总线风暴 父子线程如何共享数据？interitableThreadLocals NIO、多路复用、NIO、BIO 区别，NIO 解决了什么问题，Netty 线程模型 多线程是什么?为什么需要多线程?什么情况下需要多线程? 什么是线程安全？ 加锁会带来哪些性能问题。如何解决? 线程优先级： setPriority 这个方法，他是 jvm 提供的一个方法，并且能够调用 本地方法 setPriority0. 我们发现优先级貌似没有起作用，为什么？ 1. 我们现在的计算机都是多核的，t1，t2 会让哪个cpu处理不好说。由不同的cpu同时提供资源执行。 2. 优先级不代表先后顺序。哪怕你的优先级低，也是有可能先拿到我们的cpu时间片的，只不过这个时间片比高优先级的线程的时间片短。 优先级针对的是 cpu时间片的长短问题。 3. 目前工作中，实际项目里，不必要使用setPriority方法。我们现在都是用 hystrix， sential也好，一些开源的信号量控制工具，都能够实现线程资源的合理调度。这个 setPriority方法，很难控制。实际的运行环境太复杂。 有多少种实现线程的方法？ synchronized，如何通知阻塞的线程锁释放？cas、waitinglist ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#juc"},{"categories":["interview"],"content":" 线程池线程池，线程池的参数，线程池提交一个任务后的的运行过程，什么时候会触发饱和策略? 如何实现 线程池参数 核心2，等待3，max10，已有两个任务，新来一个任务如何处理？ 缓存线程池的参数如何处理？ ThreadLocal是什么? ThreadLocal的实现原理？ 使用ThreadLocal有什么问题吗？如何解决？ 拒绝策略 阻塞队列应用场景 阻塞队列是一个支持附加操作的队列。这两个附加操作是:在队列为空时。获取元素的线程 会等待队列为非空;当队列满时，存储元素的线程会等队列可用。阻塞队列常用于生产者和 消费者的场景，生成者是往队列里添加元素的线程，消费者是从队列里拿走元素的线程。 ","date":"2023-08-12","objectID":"/interview/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#线程池"},{"categories":["interview"],"content":" redis和分布缓存、分布式锁","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#redis和分布缓存分布式锁"},{"categories":["interview"],"content":" redis还有哪些缓存技术？ 哪些高并发场景不能使用缓存？ sentinel和cluster区别和使用场景 redis单线程为什么快？ qps能上多少？如何知道的？ 如何实现分布式锁 Redis 的哈希环最多有 16384 个槽，为什么是 16384?哈希环出现数据倾斜如何解决？ 大key什么是大？热key产生原因、后果、如何解决 Redis 哨兵模式用的什么原理？主从切换如何实现？ Redis里面使用了Raft协议？Raft和Paxos的区别？ 和LevelDB的区别 如何确保数据库一致性？（删缓存、延时双删） 数据结构种类、底层数据结构实现？ 什么是缓存穿透、击穿、雪崩、预热？如何解决？ Redis如何实现分布式锁？ 如何搭集群 单线程的Redis的QPS是多少？ 单线程的Redis为什么这么快？ 项目中说用 Redis 维持了用户登录状态，怎么实现的，还有其他实现方式吗 Redis 的主从原理 什么是增量复制 什么时候进行全量复制 Redis 有哪些持久化方式 说说 AOF RDB 的原理呢 Redis 有哪些具体的数据结构，你都用过吗 Set 和 Zset 你会在什么时候用呢 Redis的持久化机制？ Redis切片集群？数据和实例之间的如何进行映射？ Redis扩容之后，哈希槽的位置是否发生变化？ Redis缓存和数据库不一致解决方法？ Redis的数据类型及应用、缓存击穿、穿透、雪崩 redis是否支持事务 redis如何做持久化 redis为啥支持高并发，为啥性能优越 redis6.0新特性 redis内存淘汰策略 问问redis（底层压缩列表和对应结构忘了） redis底层5大类型 redis类型对应的底层实现 为什么用跳表，跳表和链表区别 为什么数据小用链表、大的用跳表（节省空间，优化性能，性能和空间折中） redis为什么是单线程 redis数据结构 MySQL 和 Redis 数据一致性问题 Redis 中 ZSet 的底层（压缩链表，哈希表，跳跃表） Redis 内存淘汰策略 Redis在项目中的使用？做了什么功能？用了什么数据结构？（答map。面试官说没有这个） Redis有哪些数据结构，底层实现了解过吗？（有看过博客，没有系统学习，时间久远已忘却。） redis解决写热key的问题（热key读，热key写） 我看你项目用到了 redis 具体用到了哪些数据结构？（string，hash，zset） zset 实现，跳表是怎么回事？高度？时间复杂度？为什么不用 b+ 树？ redis 是单进程还是多进程？ 项目用到了 redis 哪些结构（zset，hash），说一说底层实现 zset 除了跳表+hash表外还有其他实现吗？ 才想起来数据量较小时会用压缩列表实现 压缩列表实现的主要目的，答节省内存 key的过期机制 redis的io多路复用模型 redis和mysql的一致性怎么保证（先删后更新、双删，面试官后来指出用个mq异步删除更好，这块确实接触不多 Redis缓存和数据库的一致性，延迟双删 redis里内存淘汰是LRU对吧？（还可以是其他机制，一般是LRU） 假如让你去实现LRU cache的话，你会怎么实现？（链表基本实现，扯了下MySQL的LRU策略优化——冷热数据分离） LRU cache不适用于什么场景？（想了一会儿，因为没碰到具体啥业务场景，所以开始一堆假设，反推，自言自语。然后说——数据量很大，一个周期取数据，取完数据就马上被淘汰了） 如何实现LFU？（我其实也不太记得了，只记得要存储频率这种关系，所以说的比较模糊，因为大致也提到了频率、map啥的，而且LFU有好几种实现方案，所以也就混过去了） 那这样的话如何找到频率最小的删除掉呢？（开始胡言乱语，又扯到用红黑树这种结构去实现，当然这是可以的） 这样做的查找插入时间复杂度是多少？（继续开始胡言乱语，又开始假设用hashmap去实现，O(1),后来提醒是TreeMap，所以又改成O(logn)） 那插入时间复杂度是多少？(logn) 有没有时间复杂度更低方式？ ","date":"2023-08-12","objectID":"/interview/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#redis"},{"categories":["interview"],"content":" 分布式CAP原则 分布式锁如何添加？放在什么位置？ ","date":"2023-08-12","objectID":"/interview/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#分布式"},{"categories":["interview"],"content":" 分布式iduuid算法：随机数、时间戳+结点编号、基于哈希（根据唯一input来确保唯一output 雪花算法不同于以往的随机数算法，雪花算法是基于时间戳的64bits长度的算法，41bit（69年）、时间戳++5bit数据中心+5bit机器编号+12bit顺序码 聊一聊雪花算法。还有其他的唯一id算法，背后的原理 随机数：UUID.ramdomUUID()\\v4 时间戳：雪花算法 \\ v1 (基于时间戳、随机数和MAC地址) \\v2（时间戳的前4位置换为POSIX的UID或GID) \\ hash-based：UUID(byte[]) 和UUID(long,long)\\v3 redis通过源自自增（初始值和步长可以设置），也可以添加日期，进行日期+自增号 雪花算法就可以谈各种，比如id 他是怎么分布的，哪一些位放什么信息，以及单台机器上生成id是否有序，雪花算法的缺点啊，推特最后为什么没有继续用呢？ 还有比如java的uuid，或者美团的overleaf 方案等等，都可以谈。最起码我可以引入redis/mysql，做一个自增的id，然后引入了他就可能有各种的问题，比如单点故障啊等等，可以一直说。z redis数据结构有哪几种？（讲了四种，忘了一种，开始扯高级结构补了，不过后面想起来了补上了list） redis里的hash扩容了解吗？（不了解） redis过期策略（一开始答偏了，答到了内存淘汰算法，后来面试官换了种问法，也答了惰性删除和定期删除） redis持久化机制，说一下你的理解（RDB、AOF、混合方式） aof刷盘机制有哪几种？（说了三种和优缺点） 4、redis的数据结构 5、zosrt的时间复杂度以及为什么是logn redis的跳表，如何查找，插入，删除，维护索引，隔2个建索引和隔3个建索引的时间复杂度和空间复杂度分析。 真实的分布式文件系统介绍一下 GFS一致性说一下 GFS负载均衡说一下 GFS如何保证client最快获取文件 raft会不会出现双主？双主对外能提供服务吗 什么时候leader提交日志 raft出现follower日志不一致的情况怎么办 9.Redis主从复制 对象存储架构 看过分布式论文没？为什么写这个项目 接口实现，研究过公有云其他的对象存储接口没 9.redis中hash数据结构的rehash为什么快 项目里redis的作用，存了什么数据 为什么不用memcached 跳表了解吗？ 有向图的循环依赖检测并打印出循环的环，可能存在多个环。 Redis的基本数据结构有哪些？布隆过滤器具体原理？ 5.redis数据模型，重点问跳表，跳表跟平衡二叉树的优劣 5.redis的zset底层实现，跳表，与其相同的接***衡二叉树的实现，红黑树，还有吗（我提了b树 b+树但是必须是二叉） （不确定是不是redis）动态链接库，静态链接库 Redis清理过期Key的时机。 Redis持久化机制。 Redis用来干什么的（项目相关）。 Redis持久化方式。 Redis为什么快。 redis你了解它整体有哪些数据结构？zset的数据结构？ 14.redis持久化？redis运行很久，AOF执行语句会一直膨胀很大吗？ 15.了解redis热key和大key？解决手段？ 16.redis分布式集群搭建？ 介绍一下锁 布隆过滤器。 知道分布式锁吗 常用redis使用分布式锁，你知道吗 在使用redis的时候采用的是什么模式 Gossip协议，为什么没用Paxos。 分布式CAP。 \\5. CAP里面只能满足两个么。 \\6. 了解BASE么 分布式锁（这个讲的挺久的） 布隆过滤器为什么有差错 建立多大的hash表，时间复杂度 ","date":"2023-08-12","objectID":"/interview/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#分布式id"},{"categories":["interview"],"content":" 设计模式介绍常用的设计模式 尽可能得写出多种单例模式、优缺点 装饰和模板？ 实现设计模式中简单工厂模式 \\1. 了解哪些设计模式？ \\2. 单例模式有几种实现方式？ \\3. 单例模式最常用的实现方式是哪种？为什么？ ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#设计模式"},{"categories":["interview"],"content":" 项目分布式session如何实现？为了解决什么问题？ban了cookie怎么办？ . 介绍一下自己最熟悉的项目，项目使用的技术栈？项目的微服务是怎么划分的？ \\2. 项目的签到功能是怎么实现的？ 项目的搜索附近的人功能是怎么实现的？ 为什么选择使用这项技术？有没有和其他技术进行过对比？可扩展性如何？ ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#项目"},{"categories":["interview"],"content":" gogo语言 new 和 make 的区别 进程、线程、协程 gc golang的协程 是怎么实现的？和线程比有什么不一样，又给他带来哪些的好处？ 这个问题1面有涉及到，所以后面也好好准备了一下。可以谈的点很多，除了上一篇提到了，还可以说栈，保护现场恢复现场，用户态内核态，对比等等。最后可以加上一句，避免了内核频繁状态切换的成本。 go channel的调度机制有了解吗？泛型？ 这两个确实不了解，直接说不太清楚。 go语言的内存逃逸（我不会go，问go八股了😭） 进程线程和协程 go slice的日常使用坑（我讲了浅拷贝和底层数组扩容的问题） 协程介绍一下 为什么协程快 go slice 扩容 recover为什么能处理panic，换句话说为什么recover要写在defer里（让讲底层原理，我讲了讲defer的，但是panic的底层结构我还真不了解…… Go协程同步方式。 Go里面各类锁。 GMP模型。 Go的字符串转byte数组，底层会复制还是沿用原数据。 如何沿用原数据。 内存逃逸。 GMP（阐述、P和M代表啥、为什么引入P） 怎么限制goroutine的拉起数？ goroutine之间是怎么实现同步的？ 内存管理（阐述、为什么对象分三种、怎么避免内存资源浪费（比如16B的大小的对象，一个页中使用了10%有效，90%无效）） 进程、线程和协程（问得很细，cfs，pid，tgid 3、gmp模型、goroutine是并行还是串行（并发）、并发安全 4、mvcc原理、mysql中各种锁、解决幻读的方式 项目中，如果高并发请求怎么限制goroutine？ 5、 6、grpc的调用流程，为什么可以跨语言（项目里用到了grpc 7、go语言异常处理，和python的比较 go语言slice的深浅拷贝，成功被绕晕 😂 grpc原理、protobuf和json的比较（编码方式、应用场景 ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#go"},{"categories":["interview"],"content":" coding跳表实现 ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#coding-1"},{"categories":["interview"],"content":" 基本算法非递归不用栈如何遍历二叉树 二叉树中序遍历（非递归） 矩阵左上角走到最下角最小路径和，为了写得快写了dfs，分析时空复杂度，其他方法说了bfs，因为都是非负的，可以把值看成边，然后dijkstra 判断树B是否是树A的子结构？ 中序遍历递归和非递归 一个栈的最大元素 lru缓存结构的实现 约瑟夫环 数组找出乘积为n的两个数 非递归遍历二叉树 二叉树的最大宽度 两个有序链表的Topk 二叉树转双向链表 给定数字二进制位反转之后输出 二叉树和红黑树的区别 trie树 红黑树的性质，为什么增删改查都是O(logn) 最大子序和 ","date":"2023-08-12","objectID":"/interview/:0:1","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#基本算法"},{"categories":["interview"],"content":" lc岛屿系列 第K系列 括号系列 股票系列 拓扑排序系列/课程表系列/一个有向无环图，找出每个节点的层数 无重复字串系列 N数之和系列 最长子串系列 跳跃系列 3 4 5 15 20 21 22 23 25 32 36 40-\u003e变形：考虑有负数的情况呢 42 41.缺失的第一个整数( Leetcode 41) 46 47.全排序II( Leetcode 47) 48 49 53 54 56 70 76 78 92 93 102 114 122 123 124 139 140 142 143 152 156 149 162 188 207 210 221 316 340 394 402 407 438 448.找到所有数组中消失的数字 498 543 740 887 1106 1115 1195 1372 1498 1502 树的子结构 状态机的题目 给定一个单链表，链表的奇数位置节点递增，偶数位置节点递减，把它变成一个递增单链表。 给一个数字的字符串，排列出全部的合法ip组合 队列求相同元素 给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 最长连续子数组1438?581?offer42 两个数组A,B里面元素相同，顺序不同，B元素之间不能比较，A元素间不能比较，A,B可以比较，返回-1则为小于，0等于，1大于 给定一个数字n=34563，一个数组{5,4,1,3}，求由数组中的数字组成的小于n的最大整数 不包含重复数字的数组的所有子集 数组中有正数有负数有0，子数组之和等于K，求有多少个这样的子数组（一开始想滑动窗口来着，写出来不行，因为有负数的原因？ 又换成前缀和，行了。） 生成全排列去重排序之后的结果 两个list求相同元素（无限流怎么办） 01字符串中找到合乎条件的 ","date":"2023-08-12","objectID":"/interview/:0:2","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#lc"},{"categories":["interview"],"content":" 智力题两个箱子，50个红球50个黄球，怎么放才能让每次拿到红球概率最大？ 山羊和车 甲和乙在一个圆形棋盘中下棋，问甲先下怎么下能赢。 说的是有个小虫，每隔2s繁殖翻倍，2只2s后就是4只，以此类推…1个瓶子放入1只小虫，装满小虫用了2min；现在1只瓶子里放入2只虫子，装满用了多久？ 64马赛马8次一组，决出前4名最少次数？8+4+2+1=15次，还有更优的嘛？有，10次 25个马5个赛道 最少比几次得出最快的五只马？ 两张桌子，一张3个，一张4个，A、B玩游戏，轮流拿，每次只能拿1-2个，不能不拿，也不能一次拿两张桌子，这个游戏如果先手的话有什么必胜的策略吗？ 那有没有初始的不是3、4，而是4、5？ 最后面试官说回到3、4这个问题，刚刚说到3、4变0、3，有没有别的思路？（后面问了别的思路是不经过0、3） 经过自言自语也回答了1、2这种情况，然后和面试官聊这种情况，相当于我当A，他当B 最终和面试官扯了15min ","date":"2023-08-12","objectID":"/interview/:0:3","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#智力题"},{"categories":["interview"],"content":" 实践给一个具体的csv文件，实现一些读写操作 写一个判断文件相互引用的程序 a. 每个文件可引用多个文件，应该是结构体的形式 b. 形成一个图的形式，需要dfs和bfs 多线程打印123 字符串里数据存入数据库 两个线程交替打印a、b，sychronized、Semaphore、LockSupport 写一个解析csv文件的类 ","date":"2023-08-12","objectID":"/interview/:0:4","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#实践"},{"categories":["interview"],"content":" 理论lsm介绍一下 LRU的实现，优化，实例，linux的实现（最后这个不清楚） LRU的性能有问题知道吗（不知道，加减都是o(1)，性能有问题可以用LFU） ","date":"2023-08-12","objectID":"/interview/:0:5","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#理论"},{"categories":["interview"],"content":" 其他松鼠捡松子（n个格子，每个格子有不同数量的松子，松鼠在第一个格子，每次可以向前跳3-5格，到了一个格子拿走松子，问跳出去后松鼠最少捡多少松子） 溢出问题，一个数组vector\u003cint32_t\u003e，整体和是不溢出的，但部分和会溢出，怎么求和？双指针 ","date":"2023-08-12","objectID":"/interview/:0:6","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#其他"},{"categories":["interview"],"content":" 排序归并排序和快排的实现，时间复杂度和空间复杂度。 写一个快排并实现 快排，堆排序的原理，写一下用归并排序合并两个有序数组 写出所知道的排序方法的时间复杂度和空间复杂度 排序算法中堆排序，是否是不稳定排序，为什么是不稳定，已经一些排序相关扩展 什么是稳定的排序 快排和归并排序稳定吗？ 介绍一下堆排序的思想 （3）给定两个有序数组，找出其中的第K大 1,给出一个数组a,一个整数k,你每次可以选择一个数加一,进行k次,求k次之后数组乘积最大值%1e9+7。（秒） 2,给出n个以坐标系原点为左下角,(xi,yi)(1 =\u003c i \u003c= n) 为右上角的矩形,再给出一个数组,每个数组项(x,y)代表一个点。返回数组，表示每个点被包含在几个矩阵之中。(x轴无限大，y轴小于等于100)(写出来了，但是有个函数没用对导致跑不起来，但是面试官表示理解算法应该没问题) 1,给出一个水管（两条直线构成），底边在x轴上，顶部的y轴坐标为w.给你n个圆（x,y,r三元组表示）在水管中，若圆之间交叉或正好相切则水无法通过，求水是否无法流通。（并查集秒） 2，给你n个数，只能遍历一次，空间复杂度O(1),你需要在数组里的最大值中，等概率地随机返回其中一个最大值的下标。（不会，面试官稍加引导之后想出来了） 3，2的升级版，给你n个数，只能遍历一次，空间复杂度O(1),你需要在数组里的最大值中，等概率地随机返回其中k个最大值的下标，保证最大值不小于k个。（真不会，面试官尝试引导，后来懂了，最后没时间就没写了。） 页面置换算法 手撕lru算法 二叉树的之字形遍历 给你多个ip地址（可能涵盖所有的ip地址），判断是否为国内ip，事先给你一些不相交的ip地址段表示国内ip。 思路：将ip转化为long数值存储，然后比较。考虑时间复杂度（朴素法O(n2)，二分法O(nlogn)） 二叉搜索树中第K大的节点 一天中有n个用户 变量有userid, logintime,logouttime （用户号，登陆时间，登出时间） 问最大峰值和持续时间 例 1 1 10 2 8 10 3 8 12 最大峰值3个用户 持续时间是8~10 可能有多个峰值 滑动窗口最大值（做的太快，6分钟a了。面试官说我做过，很不爽）又出一题 \\2. 已知一个函数f() 可以生成0或1，概率为1/2 让你实现一个函数生成1的概率为P 3.用两个栈实现数组排序 十分钟写完 面试官质疑我的思路 但是结果正确 https://leetcode-cn.com/problems/word-break-ii/ 连续数组最大值-》进阶-》连续数组 两段的最大值 写代码 三个字符‘(’,’)’,’*’ *代表任意字符 判断括号是否匹配 5、算法题： 1、二叉树中找到两个节点最近的公共父节点 2、写一个带过期时间的lru 一个日志（结构为ip+时间） 岛屿涨潮（二维数组，模拟 一道简单的dp（类似于加油站问题 一道模拟，网球桶装网球 一道比较难的dp（集卡） 位操作状压+回溯+备忘录，四十分钟a出来了 ","date":"2023-08-12","objectID":"/interview/:0:7","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#排序"},{"categories":["interview"],"content":" kafka/RabbitMQ消费者没收到消息、消息顺序错误、发功过程中损坏 Kafka实现主从数据的一致性，是否会造成数据的丢失？ ISR队列 怎么去避免消息重复发送或者漏发送 kafka 如何保证不重复消费 kafka 保证顺序消费吗以及为什么 kafka实现高吞吐的原因 kafka重复消费问题 消息队列如何保证不丢消息 消息队列的作用有什么 消息的可靠性如何保证 消费端获取到消息但是失败了怎么办 多次消费怎么解决 消息队列：RabbitMQ有什么特点 消息队列有什么作用 \\9. kafka的产生背景和在项目中的使用 \\10. topic和partition，partition是干什么的 \\11. Consumer Group是干什么的 \\12. 怎么将partition分配到多个broker上？怎么动态调整partition和broker的数量？ \\13. rebalance什么时候发生，rebalance过程（这个真不知道） \\8. 项目中使用Kafka的原因？为什么不用RocketMQ或者其他的MQ？ kafka性吞吐量更高，主要是由于Producer端将多个小消息合并，批量发向Broker。kafka采用异步发送的机制，当发送一条消息时，消息并没有发送到broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送。 \\ 我有一个项目的类似网关，就是与第三方对接，负责报文加密解密，解析报文(参数转换)这些，然后再向核心系统推送 面试官问我：如果消息推送失败了怎么办？ 答:在推送之前有一个 log 表先保存这些消息,然后再向核心系统推送,确保消息不会丢失 又问:万一 log 也插入失败了呢?我说这属于系统故障了，他说只是这条记录插入失败，mysql 能保证 100% 插入成功吗? 我…. 给我说有没有考虑用消息队列 消息队列用的什么?为什么用RabbitMQ,kafka有没有考虑过 我说并发量不高,所以没用kafuka,追问:为什么kafuka能有高吞吐?我根本没用过….. 追问mq的其他使用场景,我说异步,限流,削峰 2、项目里的MQ用到了什么地方 3、为什么用RabbitMQ，对比过其他的MQ吗 4、RabbitMQ消息丢失怎么处理 5、如果生产者没有收到消息队列的确认ACK，怎么处理这个投递失败的消息 6、RabbitMQ消费者端消息幂等性怎么保证 消息队列有了解过吗 Rabbitmq有什么应用场景 kafka为什么这么快 kafka怎么解决重复消费 kafka重复消费问题 \\1. kafka如何做到高可用（不会，面试官不太满意，因为我的工作经历没有互联网高并发，而且kafka的确没怎么看） kafka特殊的一致性（ISR,OSR） ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#kafkarabbitmq"},{"categories":["interview"],"content":" Spring Spring Boot框架","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#spring-spring-boot框架"},{"categories":["interview"],"content":" IOC","date":"2023-08-12","objectID":"/interview/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#ioc"},{"categories":["interview"],"content":" AOP","date":"2023-08-12","objectID":"/interview/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#aop"},{"categories":["interview"],"content":" 组件过滤器监听器 设计模式的使用 springboot 和 spring 的区别 spring如何设置bean单例非单例 对于final的类，可以代理吗？cglib servlet规范，业务流程 aop 怎么去拦截异常用 around;ioc 中如 果两个 bean 有依赖关系，怎么先加载其中一个，后加载需要依赖的那个，显式(@Order 或 者配置 xml)隐式 谁管理Bean的生命周期？ AOP面向切面编程，spring aop的两种方式。 bean的生命周期，源码细节、设计思路 RESTful 什么是ioc 怎么解决ab对象互相引用问题 用到什么注解 Spring 的 BeanFactory 和 FactoryBean 有什么区别？BeanFactory和ApplicationContext的关系 Autowired和resource的区别 JPA 手撕Mapper Spring 的 IoC 和 AOP 能讲一下吗，DI 和 IoC 是什么关系，AOP 的切面是什么意思 Spring 的反向代理 Spring 如何解决循环依赖问题 Spring 常用的注解 Spring Boot 与 Spring MVC 的区别 MyBatis 原理。(简单说了下 Dao 到 mapper.xml 的过程和原理)对比其他的 ORM 框架，mybatis #{}和${}的区别是什么?JPA规范 springboot 如何实现自动装配的? aop 在项目中用过吗?怎么用 的?底层如何实现的?介绍一下动态代理。jdk 原生的动态代理和 cglib 的动态代理有什么 区别? apollo 过滤器、拦截器 ","date":"2023-08-12","objectID":"/interview/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#组件"},{"categories":["interview"],"content":" 锁乐观锁悲观锁：java、mysql java锁 mysql锁 ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#锁-1"},{"categories":["interview"],"content":" 场景题下单过程中，是下订单减库存还是付款减库存比较好？分析优劣 现在有一亿条数据，要求你利用 HashMap 对数据进行去重并排序，你会怎么做? 设计一个数据库连接池怎么设计 设计一个侵入性最小的限流服务 限流标准(并发数? qps?并发数和 qps 关系?说出了 5 种限流方案 和对应算法原理) 设计一个分布式缓存架构，需要考虑数据结构，考虑页面置换策略，考虑分布式怎么存储，考虑本地缓存和过期时间 多表更新，分布式事务如何解决？ 设计一个分布式缓存架构 1）考虑数据结构。（key value结构） 2）考虑页面置换策略（FIFO，LRU，LFU） 3）分布式怎么存储。（中心结点通过HASH来分布，Redis集群分片存储） 本地缓存怎么设计？要有过期时间？要考虑并发 https://blog.csdn.net/xiaoxiaole0313/article/details/104604093 大数据的场景题：微博热搜1-50怎么设置？如果要你做一个热搜怎么搭建数仓？设置哪些字段？怎么提取关键词？按什么规则排热搜？如果用户输入关键词怎么过滤出热搜？ 有10万个URL黑名单，如何用布隆过滤器数据结构实现快速判断？（trim树、布隆过滤器、hashmap）各种情况的时间复杂度 爬虫爬一个网站，里面有重复的记录，怎么存储不重复 有两个文件，找出相同的行 场景题：字符串左右模糊匹配，比如“我爱中国”匹配“爱中”怎么设计索引？（我说存一个反序，通配符都加后面行不行？面试官说有问题，不过也没往下聊了） 场景题：2T 的两个大文件，每一行存储一个字符串，内存只有 1G，如何找出两个文件中相同的字符串？你设计的算法，每一个字符串需要被读几次？ 设计一个火车票购票系统需要考虑哪些方面的问题 去检索10秒内ip出现次数超过100 的ip 大文件上传怎么做的分包处理，重传处理 情景题： 设计一个真实的电梯运行模型，一个电梯需要有哪些信息，以及实现它的状态转移函数。 主要是谈谈思路， 我根据磁盘的电梯算法来答的， 基本做出来了。 看到我使用了redis实现帖子的热度榜单，让我设计如何使用多台机器处理帖子（我当时答的使用消息队列），然后让我用redis的数据结构设计帖子的评论功能 有1亿个浮点数，找出最大的10000个数据，限制内存为16kb 两个设计题： （1）设计一个秒杀系统，要求不能超卖并且秒杀的成功率高 （2）设计一个王者荣耀的排行榜，要去按照区服排 redis怎么实现分布式锁 设计题1：使用redis实现分布式锁、写代码 ，只写了线程获取锁的步骤和伪代码 设计题2：商家入驻抖音电商需要缴纳一笔保证金，设计一个系统，记录商家缴纳的保证金及相关信息，缴纳的保证金可以修改，比如商家入驻第一年缴纳5w，第二年为10w，不同商家缴纳的保证金是不同的。聊了挺久。 秒杀场景 秒杀的流程 限流怎么做的 token存在哪？（限流的程序放在哪） 数据库与缓存的一致性问题 redis减库存使用的什么命令？判断是什么命令？ 订单延时取消怎么做？ 延时队列怎么实现？考察原理 场景秒杀 一般项目的秒杀流程，是如何处理高并发的？ redis减库存成功但是已经超时，用户重新请求怎么处理？ 限流怎么设置（分布式，系统总qbs1000，怎么设置？） 系统设计：微信步数排行榜（如何存储，如何查询出排行榜） 接上题，假设微信1个小时上传一次步数，当用户查看排行榜时，拥有100个好友的时候怎么做，5000个好友呢？ 接上题，5000个好友的时候，都查询出来吗？ 智力题：一个圆形的棋盘，棋盘没有方格（即棋子可以随意摆放），棋子也是圆形的，两人交替落子，只要棋盘还能放得下棋子就可以落子，最后谁的棋子多谁赢，问先手如何落子能赢。 生产者给消息队列发送消息的时候，消息队列反馈的ack丢失，怎么办？ 生产者没收到ack，重发消息，会重复减库存吗？ 问：看到你的简历上面写了用过varnish做缓存构建CDN，能介绍一下他的实现原理吗？ 答：varnish提供了两种缓存机制，既可以将缓存放入文件中，也可以在内存中进行缓存。如果接收到了客户端请求，会根据请求去检查本地是否有对应缓存，如果有就返回给客户端，如果没有，就转发请求给后端服务，并对响应的静态资源进行缓存。 问：如果让你去实现varnish，你会考虑哪种数据结构？ 答：因为是缓存，所以首先要保证高效的读写（这里我联想到了数据库55555），所以我可能会选择使用平衡二叉树这样的数据结构来保存数据。 追问：这样的数据结构在我看来不是最优解，有没有想过使用哈希表来进行实现？ 答：（这里犯了迷糊，反问面试官哈希表是不是指数组+链表） 追问：你认为的哈希表是什么？ 答：哈希表的核心是哈希函数，通过哈希函数将键值对中的键进行映射，通过一些数据结构来进行保存。 追问：你聊到了哈希函数，那我们知道有哈希函数就不可避免地会产生哈希冲突，那你有了解过怎么解决哈希冲突吗？ 答：我所了解到地解决哈希冲突方式有两种，第一种就是使用数组+链表这样地存储方式，如果产生了哈希冲突，我们还是将键值对放进数组的对应位置，只不过这个位置上存储的是一个链表，我们可以利用头插法或者尾插法将键值对插入到链表中去进行保存；第二种是当检测到哈希冲突的时候，我们从当前位置开始往后检测，直到检测到一个空位进行保存。（忘了两种方法名字叫什么了） 追问：那你认为，使用哈希表和使用二叉树来实现，哪种效率更高？ 答：使用哈希表时，采用数组+链表这种数据结构的话，查找和插入效率都是O(1)，在极端情况下，查找效率可能会退化为O(n)，使用二叉树的话， 其插入和查找效率都是在对数级，因此，在哈希冲突发生概率不大的情况下使用哈希表效率要高一些 场景题：如何设计一个秒杀系统？ mq削峰、顺序消费、服务降级、代理；面试官又问如何防止超量下单，（懵了，说了个锁+固定数量的令牌桶，又说了我项目里类似的设计；面试官又问碰到下单不支付怎么办，答设置一个超时时间；继续问还可能有什么问题，想不出来，最后从可靠性上说了个异步的持久化 ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#场景题"},{"categories":["interview"],"content":" 其他缓存的使用策略和从底层数据库开始往上各个层级中缓存的使用（mysql的缓存、mybatis、java的haspmap、redis） 缓存更新策略 常见的负载均衡算法 一致性哈希的一致性是什么意思？ 正向代理和反向代理 微服务拓扑图 git如何避免代码冲突？如何退回代码？ MongoDB想对指定 id 的某一个 document 进行自增，怎么实现（$inc 就行，但我忘记了，说了在业务层的实现方式） 对称加密和非对称加密区别 前端鉴权方案统一介绍一下，项目里用的是哪一种，各自的缺陷和改善策略（有后端鉴权吗） jwt JWT 的工作原理吗，JWT 和 Session、Cookie 有什么关系吗，JWT 不依赖 Cookie 那一套实现吗 权限模型怎么做的， 使用token做安全认证，OAuth2授权认证，数据脱敏 压测主要测啥？（多线程测试最大并发量）怎么判断系统稳定？ 目前开视频用的是那种？ 登录流程？（token认证） josn格式 在微信小程序使用ajax与后端交互过程中，当发送post请求传输参数给后端时，后端SpringBoot会出现不支持的媒体类型这样的错误，根据官文，需要在请求头中加入‘Content-Type’字段，后来的解决方案是请求头加入’Content-Type’字段，SpringBoot对每个请求的参数封装成Bean接收请求参数。 设计，架构，容灾等等。 grpc底层原理，和其它rpc的区别，http2的原理、protobuf的编码问题（varint、zigzag，你项目里是如何设计服务注册中心的（一般来说可以用etcd实现，我讲了下我们项目的实现方法）、为什么grpc用http不用tcp（……）、你觉得直接用tcp有什么问题，哪个效率会更高 dubbo github远程分支推错到别人的分支了怎么办 channel的底层实现？ 如果不用go，怎么应对高并发的http请求 项目搭建在哪 QUIC协议 部署的过程中有什么问题 hdfs存储原理和mr (1)关于线程池设计问题(抽象了很多场景，应该怎么去设计最合适的线程池) (2)关于限流场景的设计 (3)日志模块的设计 5、token放在哪个位置？（前端放到请求体里面吧） mq如何消峰 1.介绍秒杀系统功能 2.整体QPS多少？ 3.有正常订单吗？ 4.整体订单数据存在mysql里是吧？ 5.秒杀倒计时如何实现？ 6.数据库表如何设计？ 7.秒杀表索引如何设计？除了主键ID还有其他索引吗？有unique的key吗 介绍一下项目中自己负责的部分和技术应用、难点（感觉自己答得非常拉胯。。。大家有项目的还是要好好准备一下，不但加分，而且说得好还能把流程往自己熟悉的方向引导） 了解ngnix的正向代理和反向代理吗？ 先问的redis 是用来做什么的， 然后到rocketMQ是做什么的， 然后选rocketMQ是为什么， 问了如果要做一个限流器，会用什么方式（我没答出来：一开始的思路是有延时队列的成分， 他给的回答是用redis，key值有时效性这个特点，可以来保证1秒内100qps这种情况，如果有需求的话，也可以是0.1秒内保证30qps这样。）然后问了，redis 过期的逻辑，主从数据通讯的方式，然后到数据落地的方式。 ","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#其他-1"},{"categories":["interview"],"content":" ————————————————————————————大数据方面 1.spark streaming和flink的区别 2.hbase的数据结构 3.LSM树为什么要用布隆过滤器 4.LSM树和B+树做比较 5.HBase的memStore的刷写 6.HBase的大合并和小合并 7.Hbase的HFile的格式 8.Hbase为什么适合写 9.Hbase的大读小写问题（这个压根没听过，应该都记错了，反正是个它会产生的问题，我听都没听过的一个东西） 10.Kafka怎么保证有序性、不丢失、不重复的，生产者怎么做消费者怎么做都讲 11.Kafka设置ack = -1时一定会保证消息不丢失吗 12.如果ISR集合中的所有副本全部挂了会发生什么 13.spark streaming消费kafka的两种方式 Java 1.为什么密码一般都要用char数组来存，而不是String呢 2.String在JVM中的存放形式是怎么样的 3.手写单例 4.为什么要加volatile 5.这里不用volatile会发生什么 6.指令重排会影响什么 7.HashMap、TreeMap、LinkedHashMap的区别，底层都是什么 8.为什么要遗弃hashtable 9.我现在向TreeMap和LinkedHashMap依次插入B,C,A，你遍历打印都会得到什么 10.Java出现了OOM问题时，我怎么去定位它是哪里出现的问题 11.讲一下Spring MySQL 1.说说你知道的索引 2.联合索引的最左匹配 3.我现在给你一个（a,b,c）联合索引，我where a = 1 and c = 2索引怎么走的，where a = 1 and b like怎么走索引，什么时候索引失效 4.讲一下binlog的组织格式 计网 1.tcp和udp的区别 2.tcp怎么实现可靠的 3.tcp校验码怎么做的 4.说说你知道的校验码都有哪些 5.http状态码204、401、405、407、301、302 6.ping用过吗，说一下ping的数据报格式，字节数 大流量：水平拆分，分布式，代理层，hash 流量徒增： ![image-20221201162134475](/Users/shengquan/Library/Application Support/typora-user-images/image-20221201162134475.png) ![image-20221201162238909](/Users/shengquan/Library/Application Support/typora-user-images/image-20221201162238909.png) ![image-20221201162643218](/Users/shengquan/Library/Application Support/typora-user-images/image-20221201162643218.png) ![image-20221201162800057](/Users/shengquan/Library/Application Support/typora-user-images/image-20221201162800057.png) ![image-20221201162832473](/Users/shengquan/Library/Application Support/typora-user-images/image-20221201162832473.png) HA（高可用） 对于订单，金额，直接磁盘，对于评论，浏览记录，可以缓存。 https://mp.weixin.qq.com/s/sqkYBM-4l4qFFPkjY_zCJA 给定一个机器，cpu是一核，跑一个程序会有线程安全的问题吗？ 1）超线程技术，一个核心可以对应两个线程，也就是说它可以同时运行两个线程。Intel 酷睿i7 4770K是四核心 八线程 2）单核cpu仍然存在线程安全问题，因为如果操作不是原子操作，你无法控制cpu在什么时机切换线程 \\4. 解释下什么是线程安全 \\5. cpu调度去执行其他线程时把栈存起来，栈存起来会涉及线程安全吗 进程或线程切换，将cpu寄存器中上下文保存在任务自己的堆栈里（PCB或TCB）。若其他任务修改了其中变量的值，则栈里的值失效，线程不安全。 6.多线程操作全局变量有线程安全问题，还有其他情况吗 hashMap（put后一个线程写操作覆盖前一个线程），单例（实例化多个单例对象） \\7. Java里对上述情况（6），做了哪些操作来避免线程安全问题 cs-Notes \\8. 操作系统层面，如何管理内存，具体的如虚拟内存？ \\9. 实际电脑16g内存，有无可能分配出32g内存给程序用 \\10. 平常比较熟悉的数据结构 \\18. 北京上海都有机房，刷抖音，在上海走上海机房，在北京走北京机房，网络中哪个阶段哪个协议实现 \\20. 算法题：求一个数的平方根 【三面】 \\1. 自我介绍 \\2. 反射 \\5. synchronized和reentrantlock \\6. 公平锁和不公平锁如何实现 \\7. CPU调度算法 \\8. Linux常用命令，统计一个文件夹下有多少文件 \\10. 浏览器自动补全的实现有哪些方法 不太熟，大概描述了一下，提了一嘴 Python（简历上写了熟悉 Python），小姐姐说没关系，说下 Python 是怎么做的 \\4. hashmap（说了 go 的 map 和 redis 的 hash 结构） \\5. redis rehash 过程 rehash 过程中添加数据，查询数据怎么办？（就是问渐进式 rehash，刚好没看到，瞎猜了半天） hash 冲突用的什么方法解决的？查询时间？最坏时间？ 你说链地址法冲突到一条链上会退化成 O(n)，它不好为什么要用？为什么不用其他的？ 没太明白她的意思，我只是说最坏情况可没说它不好。。然后只能说它们各有优缺点吧 应该再说一下链地址法的主要优势的 \\7. 一道没见过的算法题 给出一个分子式，比如：HMg2(H2ON3)3N2，计算这个分子式中每个原子出现了多少次，输出一个map，比如上面的分子式中：map[string]int {“H”: 7, “Mg”: 2,“O”: 3, …} 都以大写字母开头，后面跟 0 个或者 1 个小写字母，比如 Mg, H 单个原子后面跟 0 个或者 1 个数字表示它出现的次数，比如 Mg2 表示 Mg 出现 2 次，数字范围 2-9 分子式中可能有括号，括号后面可能跟 0 个或者 1 个数字表示整个括号内的原子出现的次数，比如 (N3Ag)2 表示 N出现 6 次，Ag 出现 2 次 4. 括号可以嵌套 输入是合法的 上来就遇到这么长的题让我很慌，加上之前 redis 被问到不会，这里感觉都要停止思考了。看了半天说想办法从后往前把数字乘进去去掉括号再处理，问她思路有没有问题，得到肯定回答才松了一口气，然后说了下具体方法，理清之后面试官把括号去掉了，然后说时间不够了写下简化版代码吧 \\1. gmp \\2. 协程的优势 \\3. 进程线程区别 \\4. 进程地址空间有哪些划分 \\5. 进程间通信 \\6. 共享内存是怎么回事？映射到实际物理内存的虚拟地址在地址空间的哪一部分（我猜在堆区） \\7. 虚拟内存 \\8. 页面置换算法（说了局部算法和全局算法） \\9. LRU 实现思路 \\19. 扒项目（另一个爬虫项目） \\20. 代理服务的默认端口？（第一次听说代理还有默认端口） \\21. 页面解析用的什么？ \\22. 爬虫比较困难的场景？ \\23. 纯js渲染的页面怎么爬？ \\24. （第一个项目）压测怎么做的？其他一些可以优化的点 \\25. 力扣原题，舒服：力扣33. 搜索旋转排序数组 \\26. 反问 二面面试官超级 nice，各种引导，问到我不会了就说ok没问题，全程给我信心，越面越顺 晚上另一个hr小哥哥加我微信约了三面时间，之前联系我的小姐姐不见了，唉 【三面】30min \\1. 扒项目（收获什么的） \\2. 我看你项目用了 mongodb，mongodb 存储索引知道吗？和 mysql 比有哪些优势？（回答 mongodb 并不熟，只是毕设想用用新东西，优点就知道非结构化扩展容易，速度快） \\3. mysql 存储引擎 \\8. 进程通信方式 \\9. io多路复用的几种方法（不熟，就提了下名字） \\10. cookie session \\11. 拥塞控制 \\12. 力扣原题，舒服：力扣15. 三数之和 三面面试官应该是某个部门老大，面相和蔼，问了30分钟就结束了，有点慌，没想到结束后10分钟hr就发来微信约hr面了。 面试官:本次面试将持续30~45分钟(实际约45分钟) 1.自我介绍（学校，专业，姓名，应聘职位，专业知识，项目简介） 2.tcp/udp的区别（八股文） 3.tcp的拥塞控制（八股文） 4.进程与线程（八股文） 5.常见的排序算法及时间复杂度（非典型八股文，刚结束的一学期上过算法课，凭借记忆讲述） 6.算法题：a. 合并三个有序数组，– 执行两次两路合并 b. 最长非重复子串– 秒给双指针+哈希表的思路，面试官问是否之前做过这道题？ 但是写的时候，由于第一次面试太过紧张，左指针的更新方式写错了，绕了半天没改对，以为GG 7.反问：a. 问部门负责什么？ 答：UG部门，你知道UG吗？教育部门下的，负责用户拉增（什么玩意儿？U净？那不是洗衣机嘛？） b.从您的","date":"2023-08-12","objectID":"/interview/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#heading"},{"categories":["interview"],"content":" 分布式对象存储项目 数据去重算法怎么做的？怎么判断具体的数据怎么重的？复杂度？哈希表存储在内存？内存爆满怎么办？用redis做缓存，如果redis缓存中key过期数据不存在，是否存储到数据服务？O(n)判断？ 断点续传怎么实现的？ ","date":"2023-08-12","objectID":"/interview/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#分布式对象存储项目"},{"categories":["interview"],"content":" 计算机网络和操作系统 进程和线程有什么区别？一个进程有什么数据段？同一个线程有哪些数据段可以共享的？你觉得栈区会共享吗？栈区和堆区有什么区别？ 进程的通信方式？哪些方式比较快？为什么共享内存比较快？管道为啥慢？ 版本号对比，version1和version2.大于返回1，小于返回-1，其他返回0.001和0001比较的时候都视为1；1.0.0和1.0是相等的返回0 直接给的main函数，没有其他东西 6.tcp为什么安全 7.tcp的超时重传机制 8.golang的GC 9.三色标记法的灰色、黑色有什么区别 10.为什么区分灰色和黑色，灰色存在的意义？ 11.写屏障是什么？ 12.进程、线程、协程的区别 13.什么时候用线程，什么时候用协程 算法：最大岛屿数量 7.代码题：1）K 个一组翻转链表，非递归和递归实现，如1-\u003e2-\u003e3-\u003e4-\u003e5-\u003e6-\u003e7-\u003e8-\u003eNULL，k=3，变为3-\u003e2-\u003e1-\u003e6-\u003e5-\u003e4-\u003e8-\u003e7-\u003eNULL 2）给定一个数组，判断可以积水的容量，如{ 5，2，1，4，3 } ，积水容量为5， 42. 接雨水 二面面试官小哥哥人也超级好，不嫌弃我菜愿意和我一起讨论，代码题我思路错了还会举例子告诉我这方法可能行不通，最后经他一步步引导发现其实就是双指针，感觉之前好像还做过这题，但一开始看到代码题的时候思路完全偏了 ","date":"2023-08-12","objectID":"/interview/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#计算机网络和操作系统"},{"categories":["interview"],"content":" 2.实现带timeout的read接口，原来的 ssize_t read(int fd, void * buf, size_t count) 改为ssize_t read(int fd, void * buf, size_t count, int timeout)，可以调用原来的read函数（其实就是封装一下原来的read函数，一开始没理解面试官意思懵了很久） 3.c++11新特性哪些对你很实用，auto，lambda，std::move std::string byte = “xxx” auto s = byte 问auto是拷贝还是引用，会推导成什么类型 1、使用过线程池吗？有什么参数？怎么设置参数？为什么要这样设置？具体场景呢？ 2、进程切换具体切换的是什么？线程切换呢？ 3、能讲一讲NIO吗？它的非阻塞具体在哪里？ 4、了解过AIO吗？讲一讲 5、Netty是用来做什么的？为什么说它高性能？具体讲一下 6、你觉得TCP协议有什么缺陷吗？（应该是一个开放性问题？） 9、算法题 3. 无重复字符的最长子串 变式：求至多有k个不同字符 10、反问环节 3、项目介绍 4、你的项目里面用到了redis，具体谈一谈为什么？ 5、为什么不用mysql？ 6、redis是线程安全的吗？并发环境下，redis跟mysql哪个好？如何去做选择？ 7、redis实现点赞功能是线程安全的吗？如何实现的？ 8、redis持久化策略？mysql持久化方法？ 12、redis事务与mysql事务的区别是什么？ 13、Linux内核了解过吗？ 14、内存是怎么分配的？ 15、 redis内存满了怎么办？ 16、redis集群如何扩容？如何分片？客户端如何直到分片之后，该去寻找哪一个key。 17、虚拟内存和物理内存？为什么要用虚拟内存技术？ 18、算法：最长递增子序列（********300）,acm模式，写完之后，面试官问执行流程，口述debug过程。 19、算法提问，你的算法找到的递增序列是唯一的吗？ 20、时间复杂度，空间复杂度，为什么要使用二分查找，你说你的算法用了动态规划，是怎么体现的？ 21、有什么要问我的？ 我的反问： 1、你们部门是主要写golang吗，我技术栈主要是java，会不会有影响， 答：没事可以学 2、问面试表现？ 答：没什么特别的感受，觉得还行，还好。 3、问什么时候出结果？ 答：以往都是三个工作日，具体要问hr。 后记：一次非常哈人的面试，总结下来就是全程在问数据库，我都怀疑我面的是数据库部门， redis集群的一些东西基本都没答全。 字节面经10次有9次出现的TCP一点没问，准确来说是计网一点没问，而且所有的问题都是从项目出发的，很苦恼唉 问的操作系统的内存分配也没答上来，说了半天，快表慢表和段页式存储，结果面试官说偏了，不过没关系。唯一自信的就是算法题，因为之前做过类似的，其实十分钟就写出来了，但是又花了一点时间假装没写出来，自己思考了一下代码流程和时间复杂度什么的，果然后面面试官追着问这些。 一面 约60min 项目： 项目热编译如何实现？ Go： Slice扩容机制 Sync包mutex实现 GPM调度与垃圾回收 网络： 7层网络模型 应用层协议了解哪些 传输层协议了解哪些 TCP/UDP区别 TCP如何使传输可靠 算法： 前缀树实现（主要是因为我项目有前缀树相关的东西） 前缀树系列及题解：https://labuladong.github.io/algo/2/23/61/ 算法1:https://www.nowcoder.com/discuss/post/353159649622958080 算法1想了半天没思路，面试官说换道题 算法2:股票买卖问题：https://labuladong.github.io/algo/3/28/96/， 我做的是最简单版，然后问了限制交易数量的思路 算法2 A了 总结：二面纯项目 + 3道题，算法做的不是很好，项目也没有说很清楚 面完想了想算法1的两个解法：1.回溯，直接每个数都拼一拼，返回小于n的最大数；2.贪心 + 二分，这个算法边界条件比较多 linux查看进程 linux查看线程 top命令信息（要求详细） 进程与线程与协程（三个的区别） 线程之间共享哪些信息（页表，全局变量，常量）说我没说完整 跳跃表插入过程(要求详细) http长连接实现细节(要求详细) redis的数据结构 bitMap的好处 redis存在高并发问题吗？（不考虑日志同步） UUID和自增ID各自优缺点（至少说四点） ","date":"2023-08-12","objectID":"/interview/:2:1","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#heading-1"},{"categories":["interview"],"content":" Redis数据结构 zset数据结构 压缩列表 跳表 大K问题 ","date":"2023-08-12","objectID":"/interview/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#redis-1"},{"categories":["interview"],"content":" Java线程池 线程池参数,线程池流程 线程池拒绝策略 ","date":"2023-08-12","objectID":"/interview/:4:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#java"},{"categories":["interview"],"content":" 算法长度最小的子数组 ","date":"2023-08-12","objectID":"/interview/:5:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#算法"},{"categories":["interview"],"content":" Redisredis的事务 分布式锁 项目里redis用来干嘛的 ","date":"2023-08-12","objectID":"/interview/:6:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#redis-2"},{"categories":["interview"],"content":" 计网TCP的拥塞控制 输入一个url会发生什么 三次握手为什么不能是两次 四次挥手为什么不能是三次 三次握手安全吗(syn泛洪攻击) 如何用短连接建立和长链接的映射 限流方式(令牌桶 漏桶) ","date":"2023-08-12","objectID":"/interview/:7:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#计网"},{"categories":["interview"],"content":" 算法链表排序 spring的bean是单例吗 什么情况下使用非单例 java怎么实现线程私有数据 线程池和ThreadLocal的底层原理 手写订阅发布模式 java里常见的GCroot TCP和IP分别是那两层的 网络层和传输层分别解决了什么问题 查看80端口被那个进程占用(没答出来我麻了) 起了个进程看服务怎么起来 算法 二叉树的最近公共祖先 总结:一二面感觉都问的很常规,并不是所有问题都答出来了,三面感觉是面试官随心问,想到啥问啥,估计是个leader,三面面试体验都很好. 写面经也是为了我和兄弟们攒人品,我兄弟一直运气不好两次碰到的面试官都是感觉态度特别差也没有反问环节,心态有点小炸,要是有大佬知道这是个什么情况求解答.. .tcp为什么安全 7.tcp的超时重传机制 8.golang的GC 9.三色标记法的灰色、黑色有什么区别 10.为什么区分灰色和黑色，灰色存在的意义？ 11.写屏障是什么？ 12.进程、线程、协程的区别 13.什么时候用线程，什么时候用协程 算法：最大岛屿数量 项目 介绍一下自己最熟悉的项目？ 项目使用的技术栈？项目的微服务是怎么划分的？ 项目的签到功能是怎么实现的？ 项目的搜索附近的人功能是怎么实现的？ Java基础 final、finally、finalize的区别？ 异常有哪些分类？ Error 和 Exception都是谁的子类？ JUC 线程和进程有什么区别？ 有多少种实现线程的方法？ ThreadLocal是什么? ThreadLocal的实现原理？ 使用ThreadLocal有什么问题吗？如何解决？ JVM 讲一下JVM内存结构？ 垃圾回收算法了解多少？ Redis 单线程的Redis的QPS是多少？ 单线程的Redis为什么这么快？ Redis的持久化机制？ Redis切片集群？数据和实例之间的如何进行映射？ Redis扩容之后，哈希槽的位置是否发生变化？ Redis缓存和数据库不一致解决方法？ 设计模式 了解哪些设计模式？ 单例模式有几种实现方式？ 单例模式最常用的实现方式是哪种？为什么？ 数据结构 讲一下冒泡排序和快速排序的区别，从平均时间，最好，最好，稳定性上来说？ 算法 LeetCode 543. 二叉树的直径 ","date":"2023-08-12","objectID":"/interview/:8:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#算法-1"},{"categories":["interview"],"content":" 二面（11月23日，45min左右）自我介绍 实习经历（20min） 介绍一下实习期间做的项目？ 对实习项目做了提问。 Redis 对redis的数据结构是否熟悉？ 讲一下Sorted set的底层数据结构实现？ 什么是缓存穿透？ 什么是缓存击穿？ 什么是缓存预热？ Redis如何实现分布式锁？ 计网 说说OSI七层模型？ 用户输入网址到显示对应页面的全过程？ DNS 的解析过程？ HTTP有多少版本？ HTTP/1.1和HTTP/2.0的主要区别是什么？ 目前使用最广泛的是哪个HTTP版本？ 什么是幂等？幂等方法了解哪些？ 除了Get方法之外还了解其他幂等方法吗？ 一个TCP连接可以发送多少次HTTP请求? 算法 LeetCode 15. 三数之和 （带输入输出） 反问 是否要学习大数据相关知识？ 之后的面试流程？ 字节后端日常实习一面 \\3. 跳表了解吗？ \\4. 快表了解吗 \\5. TCP流量拥塞控制怎么控制的，快重传讲解一下 \\6. TCP怎么保证能够面向连接（不是三次握手） \\7. 三次握手，四次握手讲一下，怎么处理半连接攻击 \\8. 怎么判断链表里有没有环 \\9. 算法：贪心，给若干段子区间，找到最少子区间，使得right-left\u003e给定的某个值。 空类占几个字节；字节对齐的好处；Malloc的原理 项目中的博客网站登录认证逻辑 Session、cookie和token CSRF攻击 Sql注入攻击 项目数据库的表组成 Go的channel了解吗，可以存储什么类型的数据 Channel的作用是什么 Channel的底层实现 Go的协程调度模型 创建一个goroutine时会给它分配什么数据 DNS的机理 DNS用的是TCP还是UDP http和https分别描述一下过程 常见的排序算法及其复杂度 描述一下快排和归并的过程 操作系统的系统调用是什么 为什么要分用户态和内核态 场景题：长链转短链系统 算法题：接雨水 线程和协程的区别 用户态和内核态 Go的channel支持多协程访问吗，底层是怎么实现的 除了channel还有什么方法进行并发 Channel和锁的应用场景有什么区别 使用shell命令取出文件中的第一万至两万行 介绍项目 点赞表怎么实现的 点赞表不断增长怎么办 介绍项目 了解过哪些大数据组件 算法题：k级链表反转 算法题：力扣53-最大子数组和 如果用户短时间内一直按点赞键，怎么处理 恶意用户大量发送请求怎么处理 （答了个ban掉ip地址被说不行） 算法题：函数fn()会以P概率返回0，(1-P)概率返回1，写一个函数f()将fn()封装起来，以等概率返回0和1 操作系统有几层cache 寄存器和内存之间的cache有什么作用 你觉得内存和磁盘之间有cache吗？ 说说LRU的数据结构设计 如果想改用LFU，可以怎么在LRU的数据结构上进行修改 代码题：打印给定的vector list的所有组合形式 举例：vector\u003cvector \u003e v{{1,2},{3},{4,5}} 输出： 1 3 4 1 3 5 2 3 4 2 3 5 hr告诉我三面是leader面，本来以为会很难的，结果出的题目都挺简单，面完后面试官也是马上告诉我通过了 从10.08投出第一份简历开始，长达一个月的找实习终于结束了，感觉确确实实学到了许多东西吧，希望后面的实习一 JAVA源码 HASHMAP底层机制 TCP的细节，怎么建立连接的，拥塞控制，流量控制的区别 JVM的垃圾回收，全过程，新生代，老年代，balabala的细节 进程间通信 .写一道算法题，贪心，应该是leetcode原题 浏览器输入一个网址经过的过程 这个过程中涉及到的网络安全的问题了解吗 ​ https ​ ddos 平时用linux吗 非常详细地讲一下ConcurrentHashMap的扩容流程 削峰和超卖怎么解决 一致性与回滚 final关键词的用法 进程之间的通信方式 哪种通信方式最快，为什么 其他通信方式主要消耗的时间消耗在哪 内核态和用户态的区别 kill -9原理 代码：判断一个树是否是完全二叉树 两个人轮流抛硬币，先抛到正面的赢，第一个人先抛赢的概率 一个概率生成器构造等概率器 ","date":"2023-08-12","objectID":"/interview/:9:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#二面11月23日45min左右"},{"categories":["interview"],"content":" 网络 osi 七层模型描述一下。 描述每一个层，大概干什么作用，有什么协议即可。同理可以扩展5层，5层是把哪些合并了等等。 当时复习没注意这个点，网络层传输层还说反了，答得不是很好。 tcp udp有哪些区别？对应哪些应用场景？ 这个建议好好读计算机网络自顶向下，说的挺清楚的。 最起码的有链接无连接，tcp的一些特性（可靠数据传输、拥塞机制、流量控制），比如应用场景 实时通信，比如报文头区别等等，可以涉及很多。 tcp udp 哪个传输效率更高？ 效率更高这个我无从下手，当时就说 咱们评判效率标准是什么？比如我是追求传输的快？还是追求质量？按照我的框架下给出对应的答案。 能不能基于udp完成可靠数据传输呢？ 这个问题就是顺着我说的质量，接着往下问的。应用层上可以做到的，书上也会讲到。 ","date":"2023-08-12","objectID":"/interview/:10:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#网络"},{"categories":["interview"],"content":" 多线程 进程 线程 协程的区别 ​ 这个是因为我的简历上有go语言，协程，所以问了这个问题。 多进程 多线程的区别 ​ 本科老师教授过openmp和mpi，我就按照这两个的区别回答了一下。其实网上面经回答应该也挺好的，没有固定答案，可能是看个人思考吧。 ​ 比如多个之间如何合作，共享变量怎么办，消息通信等等。java的也可以聊聊thread local，锁啊，进程通信（ip+port）等等。 ","date":"2023-08-12","objectID":"/interview/:11:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#多线程"},{"categories":["interview"],"content":" 算法 最大栈最大栈，最大队列。和剑指offer的题目应该类似吧。 最大栈就是新建一个额外的栈，保存最大值；最大队列这样干的不是最好，得有一些操作，反正当时是没想到。 然后灵机一动，讨了个巧，用两个栈 实现一个队列，原来o(n)，用两个栈的话最多也就o(2n)=o(n)，符合要求，实现出来了。 ","date":"2023-08-12","objectID":"/interview/:12:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#算法-最大栈"},{"categories":["interview"],"content":" redis 谈一谈常用的数据结构。 其实就是5个基本的，string，list，set，hash，zset。大概说说用途。 还有几个有意思的结构，hyperloglog，这个涉及到伯努利试验，桶分布等等，我觉得本科同学学过概率论的真的可以好好研究下，说出来很加分的。 以及geo 地理位置的结构。 顺着string也可以提bloom过滤器，应用场景，黑名单，顺着还可以下击穿穿透雪崩等等等等，只是串联起来 什么都能说了。 五大数据结构怎么实现的，有了解过吗？ 没看过源码，直说了。 提到了跳表，有没有替代方案？ zset用到跳表，大概讲讲跳表怎么回事，降低了查询时间啊，以及mysql为什么不用跳表而是b+树，两个的区别等等，可以说很多也是。 redis物理集群怎么搭建，怎么部署 有了解吗？ 只要是集群，就要意识到，要么主从那种高可靠集群，解决单点故障，要么解决压力过大的沙丁分片。有了这个框架什么都好说了，比如二者区别，大概是什么意思等等。 redis分布式锁有了解吗？ 这个建议好好看看，有很多权衡的点。 首先结论是，redisson 都帮我们解决实现了，他解决 有许多需要考量的点，概括上来讲可以包括： 【basic】本地锁 1、死锁 2、重复锁 3、正确的删除 4、性能问题 5、可靠性问题 6、红锁和红锁的缺点。 redis有许多开源的 偏集群的方案，有了解吗？ 不了解。但是只要是集群，就可以从AKF这个角度去考虑，那就可以提到redis在AKF上的考量。同时集群有集群理论，比如CAP BASE理论等等。 redis集群在cap关注的是哪两点呢？ p分区容错性一定是有的；集群的话，比如主从，信息可能同步不上来，不一致；所以AP。 base理论，和CAP 提出了什么新鲜玩意？ 阐述一下base理论是什么，比如一致性，就可以说 强一致性、弱一致性、最终一致性，kafka特殊的一致性（ISR,OSR）等等，很多。 ","date":"2023-08-12","objectID":"/interview/:13:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#redis-3"},{"categories":["interview"],"content":" zookeeper zk在CAP上是怎么的一个选择。 马上意识到选举过程200ms，是没法干其他事情的，所以在这个时间是不可用的，CP。那zk和eureka都可以作为注册中心，eureka在掉的时候有自我保护机制，心跳等等，保证可用但不是一致的；同样还可以说zk的目录树结构，隔离等等。 PAXOS协议有具体了解吗？ 讲自己知道的就行，比如背后论文的故事，大概流程，角色等等。 除了PAXOS，业界常用的RAFT有了解吗？ 没具体了解，后续会了解一下。 zk的脑裂问题听过吗？ 当时答得不太对，正确的是指集群里面，因为一些问题 产生两个主，不知道听谁的，具体见下一面，下一面面试官问到了。 ","date":"2023-08-12","objectID":"/interview/:14:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#zookeeper"},{"categories":["interview"],"content":" 算法 层次遍历层次遍历改一下，一行从左往右，一行从右往左这样遍历。 对垃圾回收的了解(自我发挥) 死锁的四个条件和避免死锁条件 算法题: 一棵二叉树, 将其中序遍历转成双链表的形式, 只可以使用树中结点的左右儿子指针, 不可以开新空间 ","date":"2023-08-12","objectID":"/interview/:15:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#算法-层次遍历"},{"categories":["interview"],"content":" 一面 技术面LC：纯数字字符串拆分成所有可能的ip 64匹马，每8匹可以进行一次比赛，如果要取前4名需要比几轮？ ","date":"2023-08-12","objectID":"/interview/:16:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#一面-技术面"},{"categories":["interview"],"content":" 二面 技术面LC：递增的气温 LC：z型遍历树 1000瓶水，其中1瓶有毒，如果在1轮中需要测出哪瓶有毒，需要几只小鼠？ 如果2轮呢？ ","date":"2023-08-12","objectID":"/interview/:17:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#二面-技术面"},{"categories":["interview"],"content":" 掰巧克力问题问题：一块N * M大小的巧克力，每次掰一块的一行或一列，全部掰成 1 * 1 大小的巧克力需要掰多少次？ 回答：N * M - 1次；不管怎么掰，每次只能把一个大块掰成两个小块，即每次掰只能增加1块巧克力； 那么将1块巧克力掰成N * M块小巧克力就需要掰N * M - 1次。 ","date":"2023-08-12","objectID":"/interview/:18:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#掰巧克力问题"},{"categories":["interview"],"content":" 辩论赛问题问题：1000个人参加辩论赛，1对1进行辩论，淘汰输掉的一方，问需要安排多少场比赛才能角出冠军？ 回答：每场辩论赛只能淘汰一个人，要淘汰999个人则需要安排999场比赛。 ","date":"2023-08-12","objectID":"/interview/:19:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#辩论赛问题"},{"categories":["interview"],"content":" 在24小时里面时针分针秒针可以重合几次24小时中时针走2圈，而分针走24圈，时针和分针重合24-2=22次， 而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次 ","date":"2023-08-12","objectID":"/interview/:20:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#在24小时里面时针分针秒针可以重合几次"},{"categories":["interview"],"content":" N只蚂蚁走树枝，问总距离或者总时间问题：放N只蚂蚁在一条长度为M树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间为多少？ 回答：这个其实就一个诀窍：蚂蚁相碰就往反方向走，可以直接看做没有发生任何事：大家都相当于独立的，A蚂蚁与B蚂蚁相碰后你可以看做没有发生这次碰撞，这样无论是求时间还是距离都很简单了。 ","date":"2023-08-12","objectID":"/interview/:21:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#n只蚂蚁走树枝问总距离或者总时间"},{"categories":["interview"],"content":" 旅馆的1元钱问题问题：有三个人去住旅馆，住三间房，每一间房10元，于是他们一共付给老板30，第二天，老板觉得三间房只需要25元就够了于是叫小弟退回5给三位客人，谁知小弟贪心,只退回每人1，自己偷偷拿了2，这样一来便等于那三位客人每人各花了九元，于是三个人一共花了27，再加上小弟独吞了不2，总共是29。可是当初他们三个人一共付出30那么还有$1呢？ 回答：他们所消费的27元里已经包括小弟贪污的2元了，再加退还的3元=30元；这30元现在的分布是：老板拿25元，伙计拿2元，三人各拿1元，正好 ","date":"2023-08-12","objectID":"/interview/:22:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#旅馆的1元钱问题"},{"categories":["interview"],"content":" 砝码称轻重问题：有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问至少要用天平称几次才能将轻的那个找出来？ 回答：2次 问题：十组砝码每组十个，每个砝码都是10g重，但是现在其中有一组砝码每个都只有9g重，现有一个能显示克数的秤，最少称几次能找到轻的那组？ 回答：1次 问题：有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？ 回答：至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个； 问题：有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？ 回答：将砝码分组1~10，第一组拿一个，第二组拿两个以此类推。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组。 ","date":"2023-08-12","objectID":"/interview/:23:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#砝码称轻重"},{"categories":["interview"],"content":" 高楼扔鸡蛋问题项目的表结构 linux常用命令 redis为什么快 2.根据我的实习项目对我进行提问，问的较为仔细，需要对自己的项目有较深的理解 3.OSI7层网络了解吗？说说具体有哪些层，并且每一层起到什么作用？互相之间如何协作？ 4.应用层，传输层，网络层，数据链路层都有哪些协议？它们都起到了什么作用？ 5.MAC地址在传输过程中会改变吗？ 6.CSMA/CD协议作用于哪一层？如何工作的？如何降低碰撞几率的？ 7.TCP三次握手，四次挥手聊一聊？ 8.进程，线程，协程了解吗？说说他们的特性和区别。 9.select，poll，epoll的区别？ 10.进程间的通信方式有哪些？共享存储的优点和缺点分别是什么？消息队列与管道相比有什么优势？ 11.JDK8默认使用的垃圾收集器有哪些？新生代为什么普遍采用复制算法？老年代为什么普遍采用标记清除算法？ 12.虽迟但到的算法题环节： （1）接雨水 （2）链表每k个进行反转 用redis怎么做的分布式锁？线程取到锁之后的业务判断是什么？ 2 用setnx做分布式锁的缺点？ 获得锁和设置锁的持有时间不是原子性会有什么问题？如何解决。 3 zk能解决吗 进程挂了如何解决？ 4 锁的持有时间你给了多少？为什么这么给 5 java中做同步控制的锁 6 volatile的作用 能像锁一样保证原子性吗 7 synchronized锁静态方法和实例方法有何区别？ 8 ==和equals区别 9 equals和hashcode的区别 hashcode相等equals一定相等吗 反之呢 10 遇到过内存泄漏吗 11 泛型的底层原理 12 tcp和udp区别 13 为什么需要端口号 14 tcp怎么确定每次传多少 15 假如接收窗口和发送窗口最小值有10K 我会把这10k全部发走吗 16 tcp包很大 到ip层要分两个包发 那我这两个ip包都要包含tcp头部吗 17 场景题：有一台服务器10个核 在上面运行一个采集1w台交换机信息的程序 每采集一台需要有1s的网络io 这个io是同步阻塞 为了提高采集效率 那么我设置5个进程还是10个进程还是20个进程 1 在项目设计过程中 有没有考虑过消息的实时性 存到哪 怎么输送到对端 消息的存储 协议选型 基于哪些评判去做？ 2 项目分布式锁的使用场景 技术实现 架构设计是怎么设计的 3 项目中zk用来干嘛的 4 锁的持有时间少于业务时间如何 获得锁的线程崩溃怎么办 5 gc算法 标记清除里面 标记是怎么标记（什么样的标记 什么样的不标记 标记遍历的时候是BFS和DFS 6 堆中是用哪种gc算法 为什么选择分代收集 7 二叉树的pq结点的最近公共祖先 和 重排链表的题 10min一道 8 mysql底层架构 索引怎么存储 查询是怎么运用的索引的 以及我们能做的索引优化 9 B+树和B树的区别 从查询方式来说有什么区别 10 聚簇索引结点的形式 非聚簇索引第一遍查到的是什么值 os的内存管理方式 进程之间通信方式 客户端 服务器端通信 socket编程会涉及到哪些函数 使用过哪些锁 fork函数的原理 是干嘛的 返回值的意义 大端小端存储分别是什么意思 如何编程去判断是大端还是小端 讲讲缺页中断 innodb和myisam的区别 存储的叶子结点分别是什么 主机1主机2 主机2提供一个800服务 说一下主机1请求该服务的一个过程 dns的两种实现方式 主机1 往 主机2发送过程中 ip地址和mac地址的一个变化过程 tcp三次握手讲一下 四次挥手时为什么要等待2msl时间 如果说服务器端请求断开连接请求时 来了一个新连接 旧数据来到了新连接会发生什么问题 io多路复select和epoll的区别 时间复杂度分别是多少 tcp报文比较大 分为两个ip数据报 这两个ip数据报的哪些字段会不同 每个分完的ip数据报都要有tcp头部吗 traceroute的原理 用了icmp的哪个报文 算法题 1亿个数找最大的10000个数 讲两种 讲了堆排和外排 又让我讲用归并怎么做这题 搜索旋转排序数组 2.也是针对项目进行提问，相较于一面更为深入，例如会问 3.TCP和UDP区别是什么？TCP依据什么来保证可靠性？TCP是面向什么进行传输？ 4.HTTPS和HTTP的区别？HTTPS协议链接建立流程是什么？HTTPS中的S代表什么？介于拿两层之间起作用？对于应用层透明吗？ 5.数据链路层为网络层提供了哪些服务？ARP协议是哪一层的协议？ 6.ICMP报文能起到哪些作用？分别是如何起作用的？ 7.虚拟内存了解吗？有什么作用？ 18.智力题 有36匹马，6赛道，每条赛道之间的名次不可知，只能获知单条赛道马的名次，问最少比多少次能知道前三名？ 19.算法题 （1）LRU（后面又让改成带过期时间的LRU，我使用的惰性删除） （2）查找旋转数组（时间复杂度要求O(logn)） 3.HashMap如何是如何实现的呢？JDK8HashMap的散列算法能不能从源码层面来介绍一下？为什么扩容是两倍呢？自己手写实现过HashMap吗？ 4.我看之前答垃圾收集器答的蛮好的，你能介绍一下CMS垃圾收集器的优缺点吗？为什么CMS会将serial old作为后备垃圾回收器？ 5.对象只会被分配到堆吗？（答：不是，还有可能会栈上分配） 6.什么时候会进行栈上分配？ 7.ThreadLocal的作用？如何实现？会不会出现内存泄漏？如何避免内存泄漏？ 8.Spring AOP 的作用？如何实现的？ 9.Spring 自动注入如何实现？（这个涉及的方面就比较多，讲了好久） 10.了解SSD的原理吗？（答：不知道，只知道磁盘，所以就讲了下磁盘存储原理和寻道算法） 11.操作系统是如何判定内存访问越界的？ 12.访问越界后操作系用会如何进行处理？ 13.用户态转换到核心态的过程？ 14.进程切换过程？线程切换过程？ 15.当我们ping的时候发送的是什么包？ 16.TCP协议头部长度是使用哪个字段？如何计算的？ 17.TCP如何实现流量控制和拥塞控制？ 18.TCP的滑动窗口移动流程你能具体讲讲吗？ 20.智力题 （1） 一个桶能存储5升水，一个桶能存储3升水，如何操作能量出4升水？ （2）两根质地不均匀的木头，从一端烧到另一端需要60分钟，如何操作能准确量出15分钟？ 21.算法题 你之前说了解析器，那我现场出一道算法题吧，我会输入一个SQL语句，你需要将where后面的查询条件解析为一棵规则树 例如：where (a == b and c == d) or (e == f or (g == h)) 我需要生成一棵树，结构为 or - and - a == b - c == d - or - e == f - g == h ","date":"2023-08-12","objectID":"/interview/:24:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#高楼扔鸡蛋问题"},{"categories":["interview"],"content":" 一、项目1.微服务注册与发现机制？ 2.服务之间的通信？ 3.负载均衡实现方式？原理？ Java的notify()底层实现原理？ 3.equals与==与hashcode 4.equals没有重写，调用时会调用hashcode方法吗？ 5.Threadlocal原理？ 6.Threadlocal和 synchronized的比较，优缺点？应用场景？ 10.虚拟机与docker对比，各自的用途和优缺点 11.docker与k8s的区别 12.docker的COPY指令和ADD指令区别 13.普通的二叉树寻找第k小的方法？时间复杂度？优化？ 14.线程的上下文是什么？栈容量是多少？ 15.介绍一下零拷贝 16.虚拟地址空间的作用？进程独占or全局共享？ 17.页表存储的位置？内存不够了怎么办（多级页表与局部性原理）？ 18.linux io模型 一面谈项目比较多，二面三面八股多 4、OpenAPI和rpc区别 6、Docker有什么认识 7、用户态和内核态是什么，如何切换 8、HTTP有哪些常用头部 9、cookie和session 10、cookie如何设置 11、cookie有哪些参数 12、HTTP状态码 13、GET和POST 14、POST能模拟GET吗 15、Redis持久化方式 16、Redis的rehash如何实现 21、项目中redis使用场景 22、Nginx理解 0.你用了reactor模式，那reactor模式的工作线程是异步还是同步IO呢?同步IO异步IO定义是什么 （工作线程是用线程池实现的，reactor半同步半反应堆所以应该是同步?定义是内核返回给应用程序的是就绪的还是完成事件） 1.项目中用了epoll，说说Epoll和select，poll的区别 （答:在内核表里创建一项，边沿模式，返回的已就绪数组不用轮询） 2.epoll底层数据怎么管理组织的呢 （答:噢，select是传入三个数组分别代表可读可写异常事件，epoll是都在一个event里注册，然后检测revents） 3.TCP,UDP的区别,一般通讯软件是用什么 （被误导了，本来想分开文本和视频的结果面试官补充说了一句不管什么文本还是图像视频，我就说都用udp…然后面试官说通讯软件不会单一地用哪一个，文本tcp视频音频udp…） 4.我看你用了小根堆定时器挺感兴趣，小根堆定时器怎么工作的（只提到了LRU…细节部分忘光了…） 5.线程池里用了请求队列，有什么办法避免锁的消耗 （答:无锁编程cas，面试官说没什么太大问题,不过你可以了解下无锁队列……） 6.聚焦索引和非聚焦索引（一个叶子节点是数据页，另一个是键值） 7.聚焦索引和非聚焦索引多少个(1个和很多?然后面试官说聚焦索引存放主键唯一，sql其余所有索引都是非聚焦索引…) 6.sql查找某一列最大值（我居然没答MAX函数答了个orderby….） 7.redis数据结构，排行榜用哪一个实现 8.跳表skiplist什么实现的，查询复杂度多少，原理(只知道跳表隔一层会有两个节点，缩短了链表长度…) 9.两道题:简单的前序遍历和多线程交替打印 我连前序都没写出来…完全不知道我在干什么，多线程还差一点一小时到了考官和我说了拜拜，然后语重心长地跟我说字节很看重写题和代码编写的逻辑思维能力，我还要加强…… 总结:单单看书东西真的不入脑，再加上表述能力差直接寄，然面试官感觉人挺好了，问的题目也非常简单了.，唉，话说做题我真的完全不行，每一次题目数字一出来我就开始脑壳发热了居然连简单题都做不出来… ……以为挂了居然收到了二面通知……卧槽，这二面会问啥啊 4.14 二面 虚函数是什么?运行多态有什么好处？ epoll底层怎么实现的? epoll的ET模式和水平模式区别。 binlog干什么用的? 说一下MySQL隔离级别哪几种，对应解决的问题是什么? 说说对Redis的理解，把能想到的都说一说。 为什么Redis单线程还那么快? 算法题: 1.查询有两个order的用户 2.二叉树的最大宽度(问我时间复杂度多少) 如何把问题交给上级 redis具体为什么以及怎么优化论坛项目中网站的性能？ ​ redis单实例还是多实例部署的？ ​ 有调研过多实例部署的方式吗？ ​ 多实例部署的优势？可以解决什么样的问题？（不会。面试官：IO密集型进行分散IO，内存的存储容量增加） ​ 如何保证key到达的一个redis实例 ​ 敲下www.douyin.com中间发生什么？越详细越好 ​ 根域名服务器查的是哪个解析的结果？ ​ 顶级呢？ ​ TCP三次握手和状态变化？ ​ 第二次握手的状态转化可以再详细讲一下吗？ ​ http请求报文格式 ​ 常见的http头部有哪些？ ​ http缓存有了解过吗？ ​ 那你思考一下，缓存一个大的页面（很多年不会变），缓存时应该记录哪些信息呢？ ​ nginx可以提供什么样的功能有了解过吗？ ​ es倒排索引原理 ​ kafka生产消费模式 ​ 怎么确保消费被消费了可以丢弃掉？ s 需要分布式锁的场景，然后又说锁的性能不好，怎么设计可以在无锁的情况下满足分布式锁的业务需求 分布式事务(经常被问到) 1、两阶段提交(2PC) 第一阶段:事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是 否可以提交. 第二阶段:事务协调器要求每个数据库提交数据。 优点: 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。(其实也不能 100%保证强一致) 缺点: 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如果分布 式系统跨接口调用，目前 .NET 界还没有实现方案。 2、补偿事务(TCC) 针对每个操作，都要注册一个与其对应的确认和补偿(撤销)。Try、Confirm、Cancel 优点: 跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些 缺点: 缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式， 所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。 3、本地消息表(异步确保) 核心思想是将分布式事务拆分成本地事务进行处理，消息生产方，需要额外建一个消息表， 并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据 库里面。然后消息会经过 MQ 发送到消息的消费方。如果消息发送失败，会进行重试发送。 优点: 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET 中 有现成 的解决方案。 缺点: 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。 4、MQ 事务消息 RocketMQ 支持，RabbitMQ 和 Kafka 都不支持，一次发送消息和一次确认消息，生产方需 要实现一个 check 接口(确认消息或者回滚) 优点: 实现了最终一致性，不需要依赖本地数据库事务。 缺点: 实现难度大，主流 MQ 不支持，没有.NET 客户端，RocketMQ 事务消息部分代码也未 开源。 5、Sagas 事务模型 长时间运行的事务，该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者 叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中 实现失败，那么 Sagas 工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。 输入一个 URL 按下回车发生了什么? 像 DNS 服务器请求解析域名对应的 IP 地址 建立 HTTP 连接，因为应用层的 HTTP 协议是基于网络层的 TCP 协议的，因此需要建立 TCP ","date":"2023-08-12","objectID":"/interview/:25:0","series":["学习笔记"],"tags":["面试"],"title":"Interview","uri":"/interview/#一项目"},{"categories":["项目"],"content":" 零、Reading list","date":"2023-08-10","objectID":"/parkmate/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Parkmate","uri":"/parkmate/#零reading-list"},{"categories":["项目"],"content":" OAuth2.0http://www.ruanyifeng.com/blog/2019/04/github-oauth.html http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html http://www.ruanyifeng.com/blog/2019/04/github-oauth.html ","date":"2023-08-10","objectID":"/parkmate/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Parkmate","uri":"/parkmate/#oauth20"},{"categories":["项目"],"content":" 一、OAuth2.0","date":"2023-08-10","objectID":"/parkmate/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Parkmate","uri":"/parkmate/#一oauth20"},{"categories":["项目"],"content":" A. 具体实现流程（授权码模式","date":"2023-08-10","objectID":"/parkmate/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Parkmate","uri":"/parkmate/#a-具体实现流程授权码模式"},{"categories":["项目"],"content":" 1. 前端将用户引导到gitee认证页面上https://gitee.com/oauth/authorize?client_id={client_id}\u0026redirect_uri={redirect_uri}\u0026response_type=code client_id是应用注册的时候创建的，redirect_uri是回调到后端的地址 ","date":"2023-08-10","objectID":"/parkmate/:1:1","series":["学习笔记"],"tags":["面试"],"title":"Parkmate","uri":"/parkmate/#1-前端将用户引导到gitee认证页面上"},{"categories":["项目"],"content":" 2. 用户在gitee认证页面上进行授权后用户浏览器会被重定向到redirect_uri(大概是controller层的某个接口)，并且带有code参数，后端可以获得code参数，这里，用户可以看到code，这也是为什么不直接返回access token的原因 获得的code可以配合grant_type、client_id、redirect_uri（起到一个校验的作用和，看看和之前的授权也面试不是一个）、client_secret来获取access_token 然后用access_token来获得用户的信息 ","date":"2023-08-10","objectID":"/parkmate/:1:2","series":["学习笔记"],"tags":["面试"],"title":"Parkmate","uri":"/parkmate/#2-用户在gitee认证页面上进行授权后"},{"categories":["项目"],"content":" 3. 为什么不直接返回code？这里没有直接返回access_token是因为code的返回会经过用户浏览器，可能被截取，而授权码模式需要client_secret+code来获取access_token，并且发生在授权服务器和应用服务器之间，不会涉及到用户浏览器，更为安全。 Ref：gitee doc｜code demo ","date":"2023-08-10","objectID":"/parkmate/:1:3","series":["学习笔记"],"tags":["面试"],"title":"Parkmate","uri":"/parkmate/#3-为什么不直接返回code"},{"categories":["项目"],"content":" 二、Canalcanal模拟slave读取master的binlog，并且声称具体的数据，通过配置文件，可以将canal同步到的结果发送到rabbitmq中，然后从springboot中使用相关注解获得消息并且消费（根据id删除缓存） i ","date":"2023-08-10","objectID":"/parkmate/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Parkmate","uri":"/parkmate/#二canal"},{"categories":["项目"],"content":" 负一、问题nacos gateway 和openfeign的矛盾 redis resttemplate的定制RedisConfig redis为什么存储用户信息的时候需要使用虚拟persionId作为key而不是直接使用token？ ","date":"2023-08-10","objectID":"/parkmate/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Parkmate","uri":"/parkmate/#负一问题"},{"categories":["rpc"],"content":" 一、环境配置安装 brew install protobuf protoc --proto_path=/Users/shengquan/Downloads/CS/Program/Java/Raft_KV_Platform/src/main/proto/ --java_out=/Users/shengquan/Downloads/CS/Program/Java/Raft_KV_Platform/src/main/java/ --grpc-java_out=/Users/shengquan/Downloads/CS/Program/Java/Raft_KV_Platform/src/main/java/ raft.proto ","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#一环境配置"},{"categories":["rpc"],"content":" 二、","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#二"},{"categories":["rpc"],"content":" gRPC 核心的设计思路 1. gRPC 与 ThriftRPC 区别 共性：支持异构语言的RPC。 区别： 1. 网络通信 Thrift TCP 专属协议 GRPC HTTP2 2. 性能角度 ThriftRPC 性能 高于 gRPC 3. gRPC 大厂背书（Google),云原生时代 与其他组件合作的顺利。所以gRPC应用更广泛。 gRPC的好处 高效的进行进程间通信。 支持多种语言 原生支持 C Go Java实现。C语言版本上扩展 C++ C# NodeJS Python Ruby PHP.. 支持多平台运行 Linux Android IOS MacOS Windows。 gPRC序列化方式采用protobuf，效率高。 使用Http2协议 大厂的背书 ","date":"2023-07-30","objectID":"/grpc/:1:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#grpc-核心的设计思路"},{"categories":["rpc"],"content":" http2 回顾 Http1.x协议 Http1.0协议 请求响应的模式 短连接协议（无状态协议） 传输数据文本结构 单工 无法实现服务端推送 变相实现推动（客户端轮训的方式） Http1.1协议 请求响应的模式 有限的长连接 升级的方式WebSocket 双工 实现服务器向客户端推送。 总结Http1.x协议 共性 传输数据文本格式 可读性好的但是效率差。 本质上Http1.x协议无法实现双工通信。 资源的请求。需要发送多次请求，建立多个连接才可以完成。 HTTP2.0协议 Http2.0协议是一个二进制协议，效率高于Http1.x协议，可读性差。 可以实现双工通信。 一个请求 一个连接 可以请求多个数据。【多路复用】 Http2.0协议的三个概念 数据流 stream 消息 message 帧 frame 参看图 其他的相关概念 数据流的优先级，可以通过为不同的stream设置权重，来限制不同流的传输顺序。 流控 client发送的数据太快了，server处理不过来，通知client暂停数据的发送。 ","date":"2023-07-30","objectID":"/grpc/:2:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#http2"},{"categories":["rpc"],"content":" Protobuf 文件格式 .proto UserService.proto OrderService.proto 版本设定 syntax = \"proto3\"; 注释 1. 单行注释 // 2. 多行注释 /* */ 与Java语言相关的语法 #后续protobuf生成的java代码 一个源文件还是多个源文件 xx.java option java_multiple_files = false; #指定protobuf生成的类 放置在哪个包中 option java_package = \"com.example\"; #指定的protobuf生成的外部类的名字（管理内部类【内部类才是真正开发使用】） option java_outer_classname = \"UserServce\"; 逻辑包【了解】 # 对于protobuf对于文件内容的管理 package xxx; 导入，复用其他proto文件中定义的Message UserService.proto OrderService.proto import \"xxx/UserService.proto\"; 基本类型 .proto Type Notes C++ Type Java Type Python Type[2] Go Type double double double float *float64 float float float float *float32 int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32 int int *int32 int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64 long int/long[3] *int64 uint32 Uses variable-length encoding. uint32 int[1] int/long[3] *uint32 uint64 Uses variable-length encoding. uint64 long[1] int/long[3] *uint64 sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int *int32 sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long[3] *int64 fixed32 Always four bytes. More efficient than uint32 if values are often greater than 228. uint32 int[1] int/long[3] *uint32 fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 256. uint64 long[1] int/long[3] *uint64 sfixed32 Always four bytes. int32 int int *int32 sfixed64 Always eight bytes. int64 long int/long[3] *int64 bool bool boolean bool *bool string A string must always contain UTF-8 encoded text. string String unicode (Python 2) or str (Python 3) *string bytes May contain any arbitrary sequence of bytes. string ByteString bytes []byte 枚举，枚举的值必须从0开始 enum SEASON{ SPRING = 0; SUMMER = 1; } 消息 Message message LoginRequest { string username = 1; singular string password = 2; int32 age = 3; } 编号 从1开始 到2^29-1 注意：19000 - 19999 不能用这个区间内的编号，因为他是protobuf自己保留的。 - singular : 这个字段的值 只能是0个或1个 （默认关键字） null \"123456\" - repeated message Result{ string content = 1; repeated string stutas = 2; //这个字段 返回值 是多个 等价于 Java List Protobuf getStatusList()--\u003eList } // 可以定义多个消息 message LoginRequest{ .... } message LoginResponse{ ... } 消息可以嵌套 message SearchResponse{ message Result{ string url = 1; string title = 2; } string xxx = 1; int32 yyy = 2; Result ppp = 3; } // message外部使用SearchResponse.Result message AAA{ string xxx = 1; SearchResponse.Result yyy = 2; } oneof [其中一个] message SimpleMessage{ oneof test_oneof{ string name = 1; int32 age = 2; } test_oneof xxx } 服务 service HelloService{ rpc hello(HelloRequest) returns(HelloResponse){} } // 里面是可以定义多个服务方法。 // 定义多个服务接口 // gPRC 服务 4个服务方式 。 ","date":"2023-07-30","objectID":"/grpc/:3:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#protobuf"},{"categories":["rpc"],"content":" 实战开始自动编译proto文件称java文件 https://github.com/grpc/grpc-java ———————————————————————————— ","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#实战开始"},{"categories":["rpc"],"content":" 一、核心思路","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#一核心思路"},{"categories":["rpc"],"content":" 1. 核心思路1. gRPC 核心的设计思路 1. 网络通信 ---\u003e gRPC自己封装网络通信的部分 提供多种语言的 网络通信的封装 （C Java[Netty] GO) 2. 协议 ---\u003e HTTP2 传输数据的时候 二进制数据内容。 支持双向流（双工）连接的多路复用。 3. 序列化 ---\u003e 基本文本 JSON 基于二进制 Java原生序列化方式 Thrift二进制的序列化 压缩二级制序列化。 protobuf (Protocol Buffers) google开源一种序列化方式 时间效率和空间效率是JSON的3---5倍。 IDL语言 4. 代理的创建 ---\u003e让调用者像调用本地方法那样 去调用远端的服务方法。 stub 2. gRPC的好处 1. 高效的进行进程间通信。 2. 支持多种语言 原生支持 C Go Java实现。C语言版本上扩展 C++ C# NodeJS Python Ruby PHP.. 3. 支持多平台运行 Linux Android IOS MacOS Windows。 4. gPRC序列化方式采用protobuf，效率高。 5. 使用Http2协议 6. 大厂的背书 ","date":"2023-07-30","objectID":"/grpc/:1:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#1-核心思路"},{"categories":["rpc"],"content":" 2. Http2.0协议1. 回顾 Http1.x协议 Http1.0协议 请求响应的模式 短连接协议（无状态协议） 传输数据文本结构 单工 无法实现服务端推送 变相实现推动（客户端轮训的方式） Http1.1协议 请求响应的模式 有限的长连接 升级的方式WebSocket 双工 实现服务器向客户端推送。 总结Http1.x协议 共性 1. 传输数据文本格式 可读性好的但是效率差。 2. 本质上Http1.x协议无法实现双工通信。 3. 资源的请求。需要发送多次请求，建立多个连接才可以完成。 2. HTTP2.0协议 1. Http2.0协议是一个二进制协议，效率高于Http1.x协议，可读性差。 2. 可以实现双工通信。 3. 一个请求 一个连接 可以请求多个数据。【多路复用】 3. Http2.0协议的三个概念 1. 数据流 stream 2. 消息 message 3. 帧 frame 参看图 4. 其他的相关概念 1. 数据流的优先级，可以通过为不同的stream设置权重，来限制不同流的传输顺序。 2. 流控 client发送的数据太快了，server处理不过来，通知client暂停数据的发送。 ","date":"2023-07-30","objectID":"/grpc/:2:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#2-http20协议"},{"categories":["rpc"],"content":" 3 Protocol Buffers [protobuf]1. protobuf 是一种与编程语言无关【IDL】,与具体的平台无关【OS】。他定义的中间语言，可以方便的在client 于 server中进行RPC的数据传输。 2. protobuf 两种版本 proto2 proto3,但是目前主流应用的都是proto3。 3. protobuf主要安装protobuf的编译器，编译器目的，可以把protobuf的IDL语言，转换成具体某一种开发语言。 ","date":"2023-07-30","objectID":"/grpc/:3:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#3-protocol-buffers-protobuf"},{"categories":["rpc"],"content":" 4 protobuf编译器的安装https://github.com/protocolbuffers/protobuf/releases windows 版本 1. 直接解压缩 方式在一个特定的目录下面 2. 直接配置环境变量 path protoc --version mac 版本 brew install protobuf protoc --version ","date":"2023-07-30","objectID":"/grpc/:4:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#4-protobuf编译器的安装"},{"categories":["rpc"],"content":" 5 protobuf IDEA的插件1. 2021.2版本后面的新版本 IDEA内置了Protobuf插件 2. 之前版本 可以选装第三方Protobuf插件 3. 二者不能共存。 ","date":"2023-07-30","objectID":"/grpc/:5:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#5-protobuf-idea的插件"},{"categories":["rpc"],"content":" 6. protobuf的语法详解 文件格式 .proto UserService.proto OrderService.proto 版本设定 syntax = \"proto3\"; 注释 1. 单行注释 // 2. 多行注释 /* */ 与Java语言相关的语法 #后续protobuf生成的java代码 一个源文件还是多个源文件 xx.java option java_multiple_files = false; #指定protobuf生成的类 放置在哪个包中 option java_package = \"com.suns\"; #指定的protobuf生成的外部类的名字（管理内部类【内部类才是真正开发使用】） option java_outer_classname = \"UserServce\"; 逻辑包【了解】 # 对于protobuf对于文件内容的管理 package xxx; 导入 UserService.proto OrderService.proto import \"xxx/UserService.proto\"; 基本类型 枚举 enum SEASON{ SPRING = 0; SUMMER = 1; } 枚举的值 必须是0开始 消息 Message message LoginRequest { string username = 1; singular string password = 2; int32 age = 3; } 编号 从1开始 到2^29-1，只有29位是因为还有5中wire types需要表示，5中方式需要3位来表示。 注意：19000 - 19999 不能用这个区间内的编号，因为他是protobuf自己保留的。 - singular : 这个字段的值 只能是0个或1个 （默认关键字） null \"123456\" - repeated message Result{ string content = 1; repeated string stutas = 2; //这个字段 返回值 是多个 等价于 Java List Protobuf getStatusList()--\u003eList } protobuf [grpc] 可以定义多个消息 message LoginRequest{ .... } message LoginResponse{ ... } 消息可以嵌套 message SearchResponse{ message Result{ string url = 1; string title = 2; } string xxx = 1; int32 yyy = 2; Result ppp = 3; } SearchResponse.Result message AAA{ string xxx = 1; SearchResponse.Result yyy = 2; } oneof [其中一个] message SimpleMessage{ oneof test_oneof{ string name = 1; int32 age = 2; } test_oneof xxx } message布局 一个 Protocol Buffers 的 message 在被序列化后的字节流中的布局大致如下： 每个字段都会被编码为一连串的字节。字段的编码以字段的 tag 开始，tag 是字段的编号和字段的 wire type 编码后的结果。tag 的编码也是一个 varint。 字段的 tag 之后是字段的值，其编码方式取决于字段的 wire type。例如，如果 wire type 是 0（Varint），那么字段的值就会被编码为 varint。如果 wire type 是 2（Length-delimited），那么字段的值将先是一个表示长度的 varint，后是指定长度的字节。 字段按照在 message 中声明的顺序出现。但是，由于 Protocol Buffers 支持向前和向后兼容性，所以字段可以在任何顺序出现，甚至可以出现多次（尽管这样会浪费空间）。 重复的字段（使用 “repeated” 关键字声明的）可以被编码为多···个连续的字段（每个字段都有自己的 tag 和值），或者被编码为一个字段（这个字段的 wire type 是 2，也就是 Length-delimited），这个字段的值是所有重复字段的值的串联。 对于嵌套的 message，其编码方式与顶层的 message 相同，都是 tag + value 的形式，只不过 value 的内容是内部的 message。 这样的编码方式可以确保即使消息定义发生改变，也可以正确地解析消息中的字段。如果字节流中有未知的字段（也就是在消息定义中不存在的字段），那么这些字段可以被安全地忽略或按原样保留，以便在转发时使用。 在 Protocol Buffers 中，每一个字段的类型都会被编码为一个 wire type，这用于表示该字段在字节流中的编码方式。Protobuf 定义了 5 种不同的 wire types： Varint（变长整数，wire type = 0）: 用于编码 bool、int32、int64、uint32、uint64、sint32、sint64、enum 等类型。 64-bit（64位固定长度，wire type = 1）: 用于编码 double、fixed64、sfixed64 等类型。 Length-delimited（长度有限的，wire type = 2）: 用于编码 string、bytes、embedded messages、packed repeated fields 等类型。 Start group（开始组，已废弃，wire type = 3）: 用于组的开始标记，但是这个类型已经在 Protocol Buffers v2 及以后的版本中废弃了。 End group（结束组，已废弃，wire type = 4）: 用于组的结束标记，但是这个类型也已经在 Protocol Buffers v2 及以后的版本中废弃了。 32-bit（32位固定长度，wire type = 5）: 用于编码 float、fixed32、sfixed32 等类型。 所以，wire type 不仅表示字段在字节流中的编码方式，还决定了该字段在序列化和反序列化过程中的处理方式。 服务 service HelloService{ rpc hello(HelloRequest) returns(HelloResponse){} } # 里面是可以定义多个服务方法。 # 定义多个服务接口 # gPRC 服务 4个服务方式 。 ","date":"2023-07-30","objectID":"/grpc/:6:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#6-protobuf的语法详解"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eio.grpc\u003c/groupId\u003e \u003cartifactId\u003egrpc-netty-shaded\u003c/artifactId\u003e \u003cversion\u003e1.52.1\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.grpc\u003c/groupId\u003e \u003cartifactId\u003egrpc-protobuf\u003c/artifactId\u003e \u003cversion\u003e1.52.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.grpc\u003c/groupId\u003e \u003cartifactId\u003egrpc-stub\u003c/artifactId\u003e \u003cversion\u003e1.52.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003c!-- necessary for Java 9+ --\u003e \u003cgroupId\u003eorg.apache.tomcat\u003c/groupId\u003e \u003cartifactId\u003eannotations-api\u003c/artifactId\u003e \u003cversion\u003e6.0.53\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cextensions\u003e \u003cextension\u003e \u003cgroupId\u003ekr.motd.maven\u003c/groupId\u003e \u003cartifactId\u003eos-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e1.7.1\u003c/version\u003e \u003c/extension\u003e \u003c/extensions\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.xolstice.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003eprotobuf-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e0.6.1\u003c/version\u003e \u003cconfiguration\u003e \u003cprotocArtifact\u003ecom.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier}\u003c/protocArtifact\u003e \u003cpluginId\u003egrpc-java\u003c/pluginId\u003e \u003cpluginArtifact\u003eio.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier}\u003c/pluginArtifact\u003e \u003c/configuration\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cgoals\u003e \u003cgoal\u003ecompile\u003c/goal\u003e \u003cgoal\u003ecompile-custom\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver\u003cHelloProto.HelloResponse\u003e responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#二第一个gprc的开发"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#435grpc的四种通信方式"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#436-gprc代理方式"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#5-gprc与springboot整合"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#51-grpc和springboot整合的思想"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#springboot与grpc整合的过程中-对于服务端做了什么封装"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#6-gprc的高级应用"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#61-拦截器"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#611-一元拦截器"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#612-流式拦截器"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#62-客户端重试"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#63-命名解析-nameresovler"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#631-consul"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#632-consul-java客户端开发注册中心"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#633-grpc中consul注册中心的开发"},{"categories":["rpc"],"content":" 二、第一个gPRC的开发项目结构 1. xxxx-api 模块 定义 protobuf idl语言 并且通过命令创建对应的代码 2. service 2. xxxx-server模块 1. 实现api模块中定义的服务接口 2. 发布gRPC服务 (创建服务端程序) 3. xxxx-clien模块 1. 创建服务端stub(代理) 2. 基于代理（stub) RPC调用。 api模块 1. .proto文件 书写protobuf的IDL 2. [了解]protoc命令 把proto文件中的IDL 转换成编程语言 protoc --java_out=/xxx/xxx /xxx/xxx/xx.proto 3. maven插件 进行protobuf IDL文件的编译，并把他放置IDEA具体位置。 pom.xml io.grpc grpc-netty-shaded 1.52.1 runtime io.grpc grpc-protobuf 1.52.1 io.grpc grpc-stub 1.52.1 org.apache.tomcat annotations-api 6.0.53 provided kr.motd.maven os-maven-plugin 1.7.1 org.xolstice.maven.plugins protobuf-maven-plugin 0.6.1 com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier} grpc-java io.grpc:protoc-gen-grpc-java:1.52.1:exe:${os.detected.classifier} compile compile-custom xxxx-server 服务端模块的开发 1. 实现业务接口 添加具体的功能 （MyBatis+MySQL) public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase { /* 1. 接受client提交的参数 request.getParameter() 2. 业务处理 service+dao 调用对应的业务功能。 3. 提供返回值 */ @Override public void hello(HelloProto.HelloRequest request, StreamObserver responseObserver) { //1.接受client的请求参数 String name = request.getName(); //2.业务处理 System.out.println(\"name parameter \"+name); //3.封装响应 //3.1 创建相应对象的构造者 HelloProto.HelloResponse.Builder builder = HelloProto.HelloResponse.newBuilder(); //3.2 填充数据 builder.setResult(\"hello method invoke ok\"); //3.3 封装响应 HelloProto.HelloResponse helloResponse = builder.build(); responseObserver.onNext(helloResponse); responseObserver.onCompleted();; } } 2. 创建服务端 （Netty) public class GprcServer1 { public static void main(String[] args) throws IOException, InterruptedException { //1. 绑定端口 ServerBuilder serverBuilder = ServerBuilder.forPort(9000); //2. 发布服务 serverBuilder.addService(new HelloServiceImpl()); //serverBuilder.addService(new UserServiceImpl()); //3. 创建服务对象 Server server = serverBuilder.build(); server.start(); server.awaitTermination();; } } xxx-client 模块 1. client通过代理对象完成远端对象的调用 public class GprcClient1 { public static void main(String[] args) { //1 创建通信的管道 ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext().build(); //2 获得代理对象 stub try { HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(managedChannel); //3. 完成RPC调用 //3.1 准备参数 HelloProto.HelloRequest.Builder builder = HelloProto.HelloRequest.newBuilder(); builder.setName(\"sunshuai\"); HelloProto.HelloRequest helloRequest = builder.build(); //3.1 进行功能rpc调用，获取相应的内容 HelloProto.HelloResponse helloResponse = helloService.hello(helloRequest); String result = helloResponse.getResult(); System.out.println(\"result = \" + result); } catch (Exception e) { throw new RuntimeException(e); }finally { managedChannel.shutdown(); } } } 注意事项 服务端 处理返回值时 responseObserver.onNext(helloResponse1); //通过这个方法 把响应的消息 回传client responseObserver.onCompleted(); //通知client 整个服务结束。底层返回标记 // client就会监听标记 【grpc做的】 requestObserver.onNext(helloRequest1); requestObserver.onCompleted(); 4.3.5gRpc的四种通信方式 四种通信方式 1. 简单rpc 一元rpc (Unary RPC) 2. 服务端流式RPC (Server Streaming RPC) 3. 客户端流式RPC (Client Streaming RPC","date":"2023-07-30","objectID":"/grpc/:0:0","series":["学习笔记"],"tags":["面试"],"title":"GRPC","uri":"/grpc/#634-grpc与springboot整合的高级应用"},{"categories":["数据结构与算法"],"content":" 科大讯飞非凡计划","date":"2023-07-22","objectID":"/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法"],"title":"笔试真题","uri":"/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/#科大讯飞非凡计划"},{"categories":["数据结构与算法"],"content":" 最多的好串 0708笔试算法解析小红定义一个字符串是“好串”，当且仅当该字符串的长度不小于2，且首尾相同。例如“arcaea”是好串。 小红拿到了一个字符串（该字符串不一定是好串），她准备把这个字符串切割成若干个好串，你可以帮小红求出好串的最多数量吗？ 输入描述 一个仅包含小写字母的字符串，长度不超过20w。 思路1. 将26位状态保存在一个int类型的变量中 int position = x - ‘a’; record |= 1 « position; if (record \u0026 1 « position) // 说明该位置有记录 ","date":"2023-07-22","objectID":"/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/:1:0","series":["学习笔记"],"tags":["数据结构与算法"],"title":"笔试真题","uri":"/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/#最多的好串-0708笔试算法解析"},{"categories":["数据库"],"content":"关于innodb 存储引擎以及mysql45讲，CMU的笔记 让然，还有相当硬核的阿里月报 ","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#"},{"categories":["数据库"],"content":" 零、基本用法判断等= 使用'' desc 降序（大的在前） Limit N offset M 第N-1开始M个即Limit N, M 解决空的问题，select () as xx对原语句进行包裹，作为临时表，或者使用 select ifnull ( (sentence), null) as xx ","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#零基本用法"},{"categories":["数据库"],"content":" 一、数据库整体框架（基本没写，别看）WALogging 查询优化：优化树（拆分条件，条件下拉，使用join，排序最严格的条件，下拉列选择）选择索引（有索引用索引，没索引用有序，无序遍历），loop算法 h 引擎层与服务层的交界：引擎层向服务层提供读写数据的接口 ##A. 数据库存储 Disk manage goals： 使用超过内存的空间 有序存储在稳定的工具上 减少IO 必要性：为什么不直接交给OS来做？因为需要针对内存进行优化。 使用OS的缺点： https://blog.toadworld.com/author/juan-carlos-olamendy https://blog.toadworld.com/2017/10/19/data-flushing-mechanisms-in-innodb 事务安全：OS可以随时刷新脏页，被别的书屋读取，而BPM可以把握什么时候写入 I/O 停顿：不是随时可以获得的,要等数据被加载，而优化可以预读， 错误处理：每次访问page都要进行checksum，而BPM只需要读如内存的时候进行一次checksum就好了 性能：OS 的page淘汰机制不具备很好的扩展性，尤其是SSD这种bandwidth很高的情况下， page table上的多线程竞争 page cache的单线程淘汰机制 TLB shootdown BPM可以管理： 正确的刷新脏页 预读取 缓冲置换方法 线程/进程 安排 ","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#一数据库整体框架基本没写别看"},{"categories":["数据库"],"content":" 1. File storageStorage manager 用于维护文件，制定scheduling来读写，以提定位页的时间和空间。文件以页的集合的形式存在。要管理数据读写，以及可用空间。 Pages 一定大小的block，基本不会混存，meta-data，log records，index，tuples。 Page ID -\u003eindirection layer -\u003e physical loaction DB page 16KBMySQL OS page 4KB Hardware page 4KB 页的存储结构 堆：无序，CRUD，支持迭代，offset=page size* page #，需要meta-data来维持page在哪些页中以及哪些有剩余空间。 directory pages来记录data page位置（因此要求同步），同时记录free space以及free page 树： 有序文件 hash文件 ","date":"2023-07-21","objectID":"/mysql/:0:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#1-file-storage"},{"categories":["数据库"],"content":" 2. Page Layoutpage header 记录meta-data，页大小，checksum，DBMS版本，事务能见度，鸭锁信息 如何存储tuple？ 面向tuple——slotted pages header 维护了# used slots以及最后一个slot的起始位置 Record ID page_id + offset/slot log-structured ","date":"2023-07-21","objectID":"/mysql/:0:2","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#2-page-layout"},{"categories":["数据库"],"content":" 3. Tuple LayoutTuple header： Visibility info (concurrency control) \u0026 Bit Map for NULL values. physically denormalize, 将tuple和相关的tuple（外键联系的）存在一个page上，可以减少IO， ","date":"2023-07-21","objectID":"/mysql/:0:3","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#3-tuple-layout"},{"categories":["数据库"],"content":" 4. disk- oriented 架构主要存储位置在磁盘上。 组件管理非易失性和易失性存储之间的数据移动。 ","date":"2023-07-21","objectID":"/mysql/:0:4","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#4-disk--oriented-架构"},{"categories":["数据库"],"content":" 5. 面向页的架构插入数据（mysql插入索引，插入叶子结点为目的。） 查看page directory 找到页中的free slot（） 读取到内存中 从slot array中找到empty space来放置（mysql，1/16的xx空间） 更新存在的数据 根据page directory找到页 取回到内存 使用slot array找到偏移量 覆盖 ","date":"2023-07-21","objectID":"/mysql/:0:5","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#5-面向页的架构"},{"categories":["数据库"],"content":" 6. LOG-STRUCTURED STORAGE面向页存储的选择 存储日志记录来包含改变。 记录包括了： record id（=page_id + offset/slot） 操作：删除则mark删除，添加则记录加入数据。 当日志页满了的时候，写入磁盘。日志有序且不可变。 读取：track，record id的最近更新位置。 日志压缩：保留最新纪录，维持顺序 存储日志的方式的问题：写频率较高，压缩困难 ","date":"2023-07-21","objectID":"/mysql/:0:6","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#6-log-structured-storage"},{"categories":["数据库"],"content":" 7. 数据表示DATA REPRESENTATION INTEGER/BIGINT/SMALLINT/TINYINT → C/C++ Representation float/real vs. numeric/decimal IEEE-754 Standard / Fixed-point Decimals VARCHAR/VARBINARY/TEXT/**BLOB ** → Header with length, followed by data bytes. → Need to worry about collations / sorting. TIME/DATE/**TIMESTAMP ** → 32/64-bit integer of (micro)seconds since Unix epoch MySQL源码 Large Value 不允许存超过一个页的tuple，这个时候引入 overflow storage pages（BLOB page）虽然不保证持久化和事务。 ","date":"2023-07-21","objectID":"/mysql/:0:7","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#7-数据表示"},{"categories":["数据库"],"content":" 8. 系统目录在内部目录中，存了表，列，索引，视图 用户与权限 内部统计 可以通过SELECT * FROM information_schema.tables;查看 ","date":"2023-07-21","objectID":"/mysql/:0:8","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#8-系统目录"},{"categories":["数据库"],"content":" B. 存储模型与压缩OLTP，一次少量read/update OLAP，大量复杂数据计算聚合 HTAP，混合OLTP和OLTP在一个数据库实例上 ","date":"2023-07-21","objectID":"/mysql/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#b-存储模型与压缩"},{"categories":["数据库"],"content":" C. 内存管理##D. Hash Table ","date":"2023-07-21","objectID":"/mysql/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#c-内存管理"},{"categories":["数据库"],"content":" 5. Tree index","date":"2023-07-21","objectID":"/mysql/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#5-tree-index"},{"categories":["数据库"],"content":" 6. Index Concurrency Control；","date":"2023-07-21","objectID":"/mysql/:4:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#6-index-concurrency-control"},{"categories":["数据库"],"content":" 7. Sorting \u0026 Aggreation Algorithms","date":"2023-07-21","objectID":"/mysql/:5:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#7-sorting--aggreation-algorithms"},{"categories":["数据库"],"content":" 8. Joins Algorithms","date":"2023-07-21","objectID":"/mysql/:6:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#8-joins-algorithms"},{"categories":["数据库"],"content":" 9. Query Execution","date":"2023-07-21","objectID":"/mysql/:7:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#9-query-execution"},{"categories":["数据库"],"content":" 10. Query Planning \u0026 Optimization","date":"2023-07-21","objectID":"/mysql/:8:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#10-query-planning--optimization"},{"categories":["数据库"],"content":" 11. Concurrency Control Theory","date":"2023-07-21","objectID":"/mysql/:9:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#11-concurrency-control-theory"},{"categories":["数据库"],"content":" 12. Two-phase locking Concurrency Control","date":"2023-07-21","objectID":"/mysql/:10:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#12-two-phase-locking-concurrency-control"},{"categories":["数据库"],"content":" 13. Timestamp Ordering Concurrency COntrol","date":"2023-07-21","objectID":"/mysql/:11:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#13-timestamp-ordering-concurrency-control"},{"categories":["数据库"],"content":" 14. Multi-Version Concurrency Control","date":"2023-07-21","objectID":"/mysql/:12:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#14-multi-version-concurrency-control"},{"categories":["数据库"],"content":" 15. Database Logging","date":"2023-07-21","objectID":"/mysql/:13:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#15-database-logging"},{"categories":["数据库"],"content":" 16. Database Recovery","date":"2023-07-21","objectID":"/mysql/:14:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#16-database-recovery"},{"categories":["数据库"],"content":" 17. Distributed Database","date":"2023-07-21","objectID":"/mysql/:15:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#17-distributed-database"},{"categories":["数据库"],"content":" 二、innodb存储引擎体系架构","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#二innodb存储引擎体系架构"},{"categories":["数据库"],"content":" A. MySQL整体结构连接池、管理服务和工具、SQL接口、解析器、优化器、执行器和缓冲池、可插拔引擎、文件系统、文件日志索引等 ","date":"2023-07-21","objectID":"/mysql/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#a-mysql整体结构"},{"categories":["数据库"],"content":" B. InnoDB体系架构5.5后作为默认的表存储引擎 支持ACID事务，行锁，MVCC，外键 有效使用内存（缓存）和CPU（多线程） 版本 功能 老版本InnoDB 支持ACID、行锁设计、MVCC InnoDB 1.0.x 增加了compress和dynamic页格式 InnoDB 1.1.x 增加了Linux AIO、多回滚段 InnoDB 1.2.x 增加了全文索引、在线索引 内存结构 缓冲池、重做日志缓冲 ","date":"2023-07-21","objectID":"/mysql/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#b-innodb体系架构"},{"categories":["数据库"],"content":" 内存-缓冲池 Why？innoDB基于磁盘存储的，且按照页的方式进行管理。 磁盘IO慢，为了提速，引入缓冲池，提高效率 如何保证数据不丢失？使用了checkpoint机制刷新回磁盘。 commit与checkpoint的关系 设置参数：innodb_buffer_pool_size,默认128MB 高并发访问下的性能问题 可以缓存热点数据（不可控）也可以放在第三方介质（可控） 缓冲池包括：数据页，undo页，索引页，插入缓冲，自适应哈斯索引，lock信息，数据字典信息，锁信息。 redo页在缓冲池外面，WHY？。 可以有多个缓冲池实例，每个page根据hash value平均分配到不同的缓冲池里，减少数据库内部的数据竞争。 innodb_buffer_pool_instances pool size小于1G的时候，pool_instances不生效 5.6版本开始，还可以通过information_schema架构下的表INNODB_BUFFER_POOL_STATS查看 缓冲池管理LRU算法 缓冲池中页的大小默认为16KB midpoint insertion strategy，读取后放在LRU列表的midpoint，innodb_old_blocks_pct默认值为37，即从尾短开始37%的位置 innodb_old_blocks_time，value默认是1000，即1000后放置到热端。 midpoint之前是new，之后是old free 列表 数据库刚启动时，lru列表是空的。页存放在free list中，当需要从缓冲池中分页的时候，首先从free list查找是否有空闲页，如果有责将其从free list中删除，并加入到lru list中。否则，根据LRU算法，淘汰末尾的页，分配给新的page。 从old到new的过程是page made young，没有进入new的过程是page not made young free buffers是free列表的page数量，即空闲的数量。 database pages就是LRU列表中页的数量。 free buffers+database pages 不等于buffer pool size，因为缓冲池中的页还可以被分配给锁信息，自适应哈希索引，插入缓存，数据字典信息等，不需要LRU维护。 buffer pool hit rate，越高越好，不应当小于95%，如果发生全表扫描，可能会污染LRU LRU包含了unzip_LRU，用于存放非16kb内存页，即1，2，4，8kb内存页 LRU数量包含了unzip_LRU数量 unzip_LRU：对于不同大小的页分别管理，如对需要从缓冲池中申请页为4KB的大小，其过程如下： 1）检查4KB的unzip_LRU列表，检查是否有可用的空闲页； 2）若有，则直接使用； 3）否则，检查8KB的unzip_LRU列表； 4）若能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表； 5）若不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。 当LRU list中数据被修改后，page变成了dirty page，即缓冲池和磁盘的数据不一致。通过checkpoint机制来刷新回磁盘。Flush list里面都是dirty page。 LRU用来管理缓冲池中page的可用性，而flush list用来管理刷新到磁盘，不影响。 ","date":"2023-07-21","objectID":"/mysql/:2:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#内存-缓冲池"},{"categories":["数据库"],"content":" 内存-缓冲池 Why？innoDB基于磁盘存储的，且按照页的方式进行管理。 磁盘IO慢，为了提速，引入缓冲池，提高效率 如何保证数据不丢失？使用了checkpoint机制刷新回磁盘。 commit与checkpoint的关系 设置参数：innodb_buffer_pool_size,默认128MB 高并发访问下的性能问题 可以缓存热点数据（不可控）也可以放在第三方介质（可控） 缓冲池包括：数据页，undo页，索引页，插入缓冲，自适应哈斯索引，lock信息，数据字典信息，锁信息。 redo页在缓冲池外面，WHY？。 可以有多个缓冲池实例，每个page根据hash value平均分配到不同的缓冲池里，减少数据库内部的数据竞争。 innodb_buffer_pool_instances pool size小于1G的时候，pool_instances不生效 5.6版本开始，还可以通过information_schema架构下的表INNODB_BUFFER_POOL_STATS查看 缓冲池管理LRU算法 缓冲池中页的大小默认为16KB midpoint insertion strategy，读取后放在LRU列表的midpoint，innodb_old_blocks_pct默认值为37，即从尾短开始37%的位置 innodb_old_blocks_time，value默认是1000，即1000后放置到热端。 midpoint之前是new，之后是old free 列表 数据库刚启动时，lru列表是空的。页存放在free list中，当需要从缓冲池中分页的时候，首先从free list查找是否有空闲页，如果有责将其从free list中删除，并加入到lru list中。否则，根据LRU算法，淘汰末尾的页，分配给新的page。 从old到new的过程是page made young，没有进入new的过程是page not made young free buffers是free列表的page数量，即空闲的数量。 database pages就是LRU列表中页的数量。 free buffers+database pages 不等于buffer pool size，因为缓冲池中的页还可以被分配给锁信息，自适应哈希索引，插入缓存，数据字典信息等，不需要LRU维护。 buffer pool hit rate，越高越好，不应当小于95%，如果发生全表扫描，可能会污染LRU LRU包含了unzip_LRU，用于存放非16kb内存页，即1，2，4，8kb内存页 LRU数量包含了unzip_LRU数量 unzip_LRU：对于不同大小的页分别管理，如对需要从缓冲池中申请页为4KB的大小，其过程如下： 1）检查4KB的unzip_LRU列表，检查是否有可用的空闲页； 2）若有，则直接使用； 3）否则，检查8KB的unzip_LRU列表； 4）若能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表； 5）若不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。 当LRU list中数据被修改后，page变成了dirty page，即缓冲池和磁盘的数据不一致。通过checkpoint机制来刷新回磁盘。Flush list里面都是dirty page。 LRU用来管理缓冲池中page的可用性，而flush list用来管理刷新到磁盘，不影响。 ","date":"2023-07-21","objectID":"/mysql/:2:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#why"},{"categories":["数据库"],"content":" 内存-缓冲池 Why？innoDB基于磁盘存储的，且按照页的方式进行管理。 磁盘IO慢，为了提速，引入缓冲池，提高效率 如何保证数据不丢失？使用了checkpoint机制刷新回磁盘。 commit与checkpoint的关系 设置参数：innodb_buffer_pool_size,默认128MB 高并发访问下的性能问题 可以缓存热点数据（不可控）也可以放在第三方介质（可控） 缓冲池包括：数据页，undo页，索引页，插入缓冲，自适应哈斯索引，lock信息，数据字典信息，锁信息。 redo页在缓冲池外面，WHY？。 可以有多个缓冲池实例，每个page根据hash value平均分配到不同的缓冲池里，减少数据库内部的数据竞争。 innodb_buffer_pool_instances pool size小于1G的时候，pool_instances不生效 5.6版本开始，还可以通过information_schema架构下的表INNODB_BUFFER_POOL_STATS查看 缓冲池管理LRU算法 缓冲池中页的大小默认为16KB midpoint insertion strategy，读取后放在LRU列表的midpoint，innodb_old_blocks_pct默认值为37，即从尾短开始37%的位置 innodb_old_blocks_time，value默认是1000，即1000后放置到热端。 midpoint之前是new，之后是old free 列表 数据库刚启动时，lru列表是空的。页存放在free list中，当需要从缓冲池中分页的时候，首先从free list查找是否有空闲页，如果有责将其从free list中删除，并加入到lru list中。否则，根据LRU算法，淘汰末尾的页，分配给新的page。 从old到new的过程是page made young，没有进入new的过程是page not made young free buffers是free列表的page数量，即空闲的数量。 database pages就是LRU列表中页的数量。 free buffers+database pages 不等于buffer pool size，因为缓冲池中的页还可以被分配给锁信息，自适应哈希索引，插入缓存，数据字典信息等，不需要LRU维护。 buffer pool hit rate，越高越好，不应当小于95%，如果发生全表扫描，可能会污染LRU LRU包含了unzip_LRU，用于存放非16kb内存页，即1，2，4，8kb内存页 LRU数量包含了unzip_LRU数量 unzip_LRU：对于不同大小的页分别管理，如对需要从缓冲池中申请页为4KB的大小，其过程如下： 1）检查4KB的unzip_LRU列表，检查是否有可用的空闲页； 2）若有，则直接使用； 3）否则，检查8KB的unzip_LRU列表； 4）若能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表； 5）若不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。 当LRU list中数据被修改后，page变成了dirty page，即缓冲池和磁盘的数据不一致。通过checkpoint机制来刷新回磁盘。Flush list里面都是dirty page。 LRU用来管理缓冲池中page的可用性，而flush list用来管理刷新到磁盘，不影响。 ","date":"2023-07-21","objectID":"/mysql/:2:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#如何保证数据不丢失"},{"categories":["数据库"],"content":" 内存-缓冲池 Why？innoDB基于磁盘存储的，且按照页的方式进行管理。 磁盘IO慢，为了提速，引入缓冲池，提高效率 如何保证数据不丢失？使用了checkpoint机制刷新回磁盘。 commit与checkpoint的关系 设置参数：innodb_buffer_pool_size,默认128MB 高并发访问下的性能问题 可以缓存热点数据（不可控）也可以放在第三方介质（可控） 缓冲池包括：数据页，undo页，索引页，插入缓冲，自适应哈斯索引，lock信息，数据字典信息，锁信息。 redo页在缓冲池外面，WHY？。 可以有多个缓冲池实例，每个page根据hash value平均分配到不同的缓冲池里，减少数据库内部的数据竞争。 innodb_buffer_pool_instances pool size小于1G的时候，pool_instances不生效 5.6版本开始，还可以通过information_schema架构下的表INNODB_BUFFER_POOL_STATS查看 缓冲池管理LRU算法 缓冲池中页的大小默认为16KB midpoint insertion strategy，读取后放在LRU列表的midpoint，innodb_old_blocks_pct默认值为37，即从尾短开始37%的位置 innodb_old_blocks_time，value默认是1000，即1000后放置到热端。 midpoint之前是new，之后是old free 列表 数据库刚启动时，lru列表是空的。页存放在free list中，当需要从缓冲池中分页的时候，首先从free list查找是否有空闲页，如果有责将其从free list中删除，并加入到lru list中。否则，根据LRU算法，淘汰末尾的页，分配给新的page。 从old到new的过程是page made young，没有进入new的过程是page not made young free buffers是free列表的page数量，即空闲的数量。 database pages就是LRU列表中页的数量。 free buffers+database pages 不等于buffer pool size，因为缓冲池中的页还可以被分配给锁信息，自适应哈希索引，插入缓存，数据字典信息等，不需要LRU维护。 buffer pool hit rate，越高越好，不应当小于95%，如果发生全表扫描，可能会污染LRU LRU包含了unzip_LRU，用于存放非16kb内存页，即1，2，4，8kb内存页 LRU数量包含了unzip_LRU数量 unzip_LRU：对于不同大小的页分别管理，如对需要从缓冲池中申请页为4KB的大小，其过程如下： 1）检查4KB的unzip_LRU列表，检查是否有可用的空闲页； 2）若有，则直接使用； 3）否则，检查8KB的unzip_LRU列表； 4）若能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表； 5）若不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。 当LRU list中数据被修改后，page变成了dirty page，即缓冲池和磁盘的数据不一致。通过checkpoint机制来刷新回磁盘。Flush list里面都是dirty page。 LRU用来管理缓冲池中page的可用性，而flush list用来管理刷新到磁盘，不影响。 ","date":"2023-07-21","objectID":"/mysql/:2:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#缓冲池管理"},{"categories":["数据库"],"content":" redo log 缓冲innodb_log_buffer_size 默认8MB 每秒都会从buffer到redo log，所以只要保证大小够1秒的就好 何时刷出到外部磁盘？ 1.Master Thread每一秒将重做日志缓冲刷新到重做日志文件； 2.每个事务提交时前，会将重做日志缓冲刷新到重做日志文件； 3.当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。 ","date":"2023-07-21","objectID":"/mysql/:2:2","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#redo-log-缓冲"},{"categories":["数据库"],"content":" 额外的内存池用于存放帧缓冲，缓冲控制对象，这些对象记录了如LRU，锁，等待等信息， ","date":"2023-07-21","objectID":"/mysql/:2:3","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#额外的内存池"},{"categories":["数据库"],"content":" 后台线程-Innodb的多线程模型master thread 核心线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等 Master thread loop(1.0.x)Master Thread具有最高的线程优先级别。 由多个循环（loop）组成 ​ 1. 主循环（loop) ​ 2. 后台循环（backgroup loop） ​ 3. 刷新循环（flush loop） ​ 4. 暂停循环（suspend loop）。 Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspendloop中进行切换。Loop被称为主循环，因为大多数的操作是在这个循环中，其中有两大部分的操作——每秒钟的操作和每10秒的操作。 每秒操作❑日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）； ❑合并插入缓冲 if IO 次数小于5； ❑至多刷新100个InnoDB的缓冲池中的脏页到磁盘 if innodb_max_dirty_pages_pct \u003e 90； ❑如果当前没有用户活动，则切换到background loop（可能）。 每10秒的操作❑合并至多5个插入缓冲（总是） ❑将日志缓冲刷新到磁盘（总是）； ❑删除无用的Undo页（总是）至多20条；1.2.x后，交给page cleaner thread ❑刷新100个或者10个脏页到磁盘（总是）。if buf_get_modified_ratio_pct \u003e 70, 刷新100哥 else if IO times \u003c 200 刷新100, else 刷新10 background loop，flush loop，suspend loop若当前没有用户活动（数据库空闲时）或者数据库关闭（shutdown），就会切换到这个循环。 执行以下操作： ❑删除无用的Undo页（总是）； ❑合并20个插入缓冲（总是）； ❑跳回到主循环（总是）； 不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。 若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend__loop，将Master Thread挂起，等待事件的发生。 InnoDB1.2.x 版本之前的Master ThreadInnoDB Plugin（从InnoDB1.0.x版本开始）提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：❑在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%；❑在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity。若用户使用了SSD类的磁盘，或者将几块磁盘做了RAID，当存储设备拥有更高的IO速度时，完全可以将innodb_io_capacity的值调得再高点，直到符合磁盘IO的吞吐量为止。 还有一个改变是：之前每次进行full purge操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size，该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改InnoDB 1.0.x版本在性能方面取得了极大的提高，其实这和前面提到的Master Thread的改动是密不可分的，因为InnoDB存储引擎的核心操作大部分都集中在Master Thread后台线程中。 InnoDB 1.2.x版本的Master Thread在InnoDB 1.2.x版本中再次对Master Thread进行了优化，由此也可以看出Master Thread对性能所起到的关键作用。在InnoDB 1.2.x版本中，Master Thread的伪代码如下：if InnoDB is idlesrv_master_do_idle_tasks();elsesrv_master_do_active_tasks();其中srv_master_do_idle_tasks()就是之前版本中每10秒的操作，srv_master_do_active_tasks()处理的是之前每秒中的操作。同时对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。 IO Thread在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（call back）处理。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。在Linux平台下，IO Thread的数量不能进行调整，但是在Windows平台下可以通过参数innodb_file_io_threads来增大IO Thread。从InnoDB 1.0.x版本开始，read thread和write thread分别增大到了4个，并且不再使用innodb_file_io_threads参数，而是分别使用innodb_read_io_threads和innodb_write_io_threads参数进行设置。 可以看到IO Thread 0为insert buffer thread。IO Thread 1为log thread。之后就是根据参数innodb_read_io_threads及innodb_write_io_threads来设置的读写线程，并且读线程的ID总是小于写线程。 SHOW VARIABLES LIKE'innodb_%io_threads'; SHOW ENGINE INNODB STATUS; SHOW VARIABLES LIKE'innodb_purge_threads'; ` Purge Thread 事务被提交后不需要undolog，那么需要PurgeThread来回收undo页 1.0 1.1 1.2 在master中，单独的，多个 Page cleaner 1.2.x 作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。 ","date":"2023-07-21","objectID":"/mysql/:2:4","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#后台线程-innodb的多线程模型"},{"categories":["数据库"],"content":" 后台线程-Innodb的多线程模型master thread 核心线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等 Master thread loop(1.0.x)Master Thread具有最高的线程优先级别。 由多个循环（loop）组成 ​ 1. 主循环（loop) ​ 2. 后台循环（backgroup loop） ​ 3. 刷新循环（flush loop） ​ 4. 暂停循环（suspend loop）。 Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspendloop中进行切换。Loop被称为主循环，因为大多数的操作是在这个循环中，其中有两大部分的操作——每秒钟的操作和每10秒的操作。 每秒操作❑日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）； ❑合并插入缓冲 if IO 次数小于5； ❑至多刷新100个InnoDB的缓冲池中的脏页到磁盘 if innodb_max_dirty_pages_pct \u003e 90； ❑如果当前没有用户活动，则切换到background loop（可能）。 每10秒的操作❑合并至多5个插入缓冲（总是） ❑将日志缓冲刷新到磁盘（总是）； ❑删除无用的Undo页（总是）至多20条；1.2.x后，交给page cleaner thread ❑刷新100个或者10个脏页到磁盘（总是）。if buf_get_modified_ratio_pct \u003e 70, 刷新100哥 else if IO times \u003c 200 刷新100, else 刷新10 background loop，flush loop，suspend loop若当前没有用户活动（数据库空闲时）或者数据库关闭（shutdown），就会切换到这个循环。 执行以下操作： ❑删除无用的Undo页（总是）； ❑合并20个插入缓冲（总是）； ❑跳回到主循环（总是）； 不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。 若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend__loop，将Master Thread挂起，等待事件的发生。 InnoDB1.2.x 版本之前的Master ThreadInnoDB Plugin（从InnoDB1.0.x版本开始）提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：❑在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%；❑在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity。若用户使用了SSD类的磁盘，或者将几块磁盘做了RAID，当存储设备拥有更高的IO速度时，完全可以将innodb_io_capacity的值调得再高点，直到符合磁盘IO的吞吐量为止。 还有一个改变是：之前每次进行full purge操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size，该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改InnoDB 1.0.x版本在性能方面取得了极大的提高，其实这和前面提到的Master Thread的改动是密不可分的，因为InnoDB存储引擎的核心操作大部分都集中在Master Thread后台线程中。 InnoDB 1.2.x版本的Master Thread在InnoDB 1.2.x版本中再次对Master Thread进行了优化，由此也可以看出Master Thread对性能所起到的关键作用。在InnoDB 1.2.x版本中，Master Thread的伪代码如下：if InnoDB is idlesrv_master_do_idle_tasks();elsesrv_master_do_active_tasks();其中srv_master_do_idle_tasks()就是之前版本中每10秒的操作，srv_master_do_active_tasks()处理的是之前每秒中的操作。同时对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。 IO Thread在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（call back）处理。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。在Linux平台下，IO Thread的数量不能进行调整，但是在Windows平台下可以通过参数innodb_file_io_threads来增大IO Thread。从InnoDB 1.0.x版本开始，read thread和write thread分别增大到了4个，并且不再使用innodb_file_io_threads参数，而是分别使用innodb_read_io_threads和innodb_write_io_threads参数进行设置。 可以看到IO Thread 0为insert buffer thread。IO Thread 1为log thread。之后就是根据参数innodb_read_io_threads及innodb_write_io_threads来设置的读写线程，并且读线程的ID总是小于写线程。 SHOW VARIABLES LIKE'innodb_%io_threads'; SHOW ENGINE INNODB STATUS; SHOW VARIABLES LIKE'innodb_purge_threads'; ` Purge Thread 事务被提交后不需要undolog，那么需要PurgeThread来回收undo页 1.0 1.1 1.2 在master中，单独的，多个 Page cleaner 1.2.x 作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。 ","date":"2023-07-21","objectID":"/mysql/:2:4","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#master-thread"},{"categories":["数据库"],"content":" 后台线程-Innodb的多线程模型master thread 核心线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等 Master thread loop(1.0.x)Master Thread具有最高的线程优先级别。 由多个循环（loop）组成 ​ 1. 主循环（loop) ​ 2. 后台循环（backgroup loop） ​ 3. 刷新循环（flush loop） ​ 4. 暂停循环（suspend loop）。 Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspendloop中进行切换。Loop被称为主循环，因为大多数的操作是在这个循环中，其中有两大部分的操作——每秒钟的操作和每10秒的操作。 每秒操作❑日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）； ❑合并插入缓冲 if IO 次数小于5； ❑至多刷新100个InnoDB的缓冲池中的脏页到磁盘 if innodb_max_dirty_pages_pct \u003e 90； ❑如果当前没有用户活动，则切换到background loop（可能）。 每10秒的操作❑合并至多5个插入缓冲（总是） ❑将日志缓冲刷新到磁盘（总是）； ❑删除无用的Undo页（总是）至多20条；1.2.x后，交给page cleaner thread ❑刷新100个或者10个脏页到磁盘（总是）。if buf_get_modified_ratio_pct \u003e 70, 刷新100哥 else if IO times \u003c 200 刷新100, else 刷新10 background loop，flush loop，suspend loop若当前没有用户活动（数据库空闲时）或者数据库关闭（shutdown），就会切换到这个循环。 执行以下操作： ❑删除无用的Undo页（总是）； ❑合并20个插入缓冲（总是）； ❑跳回到主循环（总是）； 不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。 若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend__loop，将Master Thread挂起，等待事件的发生。 InnoDB1.2.x 版本之前的Master ThreadInnoDB Plugin（从InnoDB1.0.x版本开始）提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：❑在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%；❑在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity。若用户使用了SSD类的磁盘，或者将几块磁盘做了RAID，当存储设备拥有更高的IO速度时，完全可以将innodb_io_capacity的值调得再高点，直到符合磁盘IO的吞吐量为止。 还有一个改变是：之前每次进行full purge操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size，该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改InnoDB 1.0.x版本在性能方面取得了极大的提高，其实这和前面提到的Master Thread的改动是密不可分的，因为InnoDB存储引擎的核心操作大部分都集中在Master Thread后台线程中。 InnoDB 1.2.x版本的Master Thread在InnoDB 1.2.x版本中再次对Master Thread进行了优化，由此也可以看出Master Thread对性能所起到的关键作用。在InnoDB 1.2.x版本中，Master Thread的伪代码如下：if InnoDB is idlesrv_master_do_idle_tasks();elsesrv_master_do_active_tasks();其中srv_master_do_idle_tasks()就是之前版本中每10秒的操作，srv_master_do_active_tasks()处理的是之前每秒中的操作。同时对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。 IO Thread在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（call back）处理。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。在Linux平台下，IO Thread的数量不能进行调整，但是在Windows平台下可以通过参数innodb_file_io_threads来增大IO Thread。从InnoDB 1.0.x版本开始，read thread和write thread分别增大到了4个，并且不再使用innodb_file_io_threads参数，而是分别使用innodb_read_io_threads和innodb_write_io_threads参数进行设置。 可以看到IO Thread 0为insert buffer thread。IO Thread 1为log thread。之后就是根据参数innodb_read_io_threads及innodb_write_io_threads来设置的读写线程，并且读线程的ID总是小于写线程。 SHOW VARIABLES LIKE'innodb_%io_threads'; SHOW ENGINE INNODB STATUS; SHOW VARIABLES LIKE'innodb_purge_threads'; ` Purge Thread 事务被提交后不需要undolog，那么需要PurgeThread来回收undo页 1.0 1.1 1.2 在master中，单独的，多个 Page cleaner 1.2.x 作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。 ","date":"2023-07-21","objectID":"/mysql/:2:4","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#loop10x"},{"categories":["数据库"],"content":" 后台线程-Innodb的多线程模型master thread 核心线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等 Master thread loop(1.0.x)Master Thread具有最高的线程优先级别。 由多个循环（loop）组成 ​ 1. 主循环（loop) ​ 2. 后台循环（backgroup loop） ​ 3. 刷新循环（flush loop） ​ 4. 暂停循环（suspend loop）。 Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspendloop中进行切换。Loop被称为主循环，因为大多数的操作是在这个循环中，其中有两大部分的操作——每秒钟的操作和每10秒的操作。 每秒操作❑日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）； ❑合并插入缓冲 if IO 次数小于5； ❑至多刷新100个InnoDB的缓冲池中的脏页到磁盘 if innodb_max_dirty_pages_pct \u003e 90； ❑如果当前没有用户活动，则切换到background loop（可能）。 每10秒的操作❑合并至多5个插入缓冲（总是） ❑将日志缓冲刷新到磁盘（总是）； ❑删除无用的Undo页（总是）至多20条；1.2.x后，交给page cleaner thread ❑刷新100个或者10个脏页到磁盘（总是）。if buf_get_modified_ratio_pct \u003e 70, 刷新100哥 else if IO times \u003c 200 刷新100, else 刷新10 background loop，flush loop，suspend loop若当前没有用户活动（数据库空闲时）或者数据库关闭（shutdown），就会切换到这个循环。 执行以下操作： ❑删除无用的Undo页（总是）； ❑合并20个插入缓冲（总是）； ❑跳回到主循环（总是）； 不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。 若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend__loop，将Master Thread挂起，等待事件的发生。 InnoDB1.2.x 版本之前的Master ThreadInnoDB Plugin（从InnoDB1.0.x版本开始）提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：❑在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%；❑在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity。若用户使用了SSD类的磁盘，或者将几块磁盘做了RAID，当存储设备拥有更高的IO速度时，完全可以将innodb_io_capacity的值调得再高点，直到符合磁盘IO的吞吐量为止。 还有一个改变是：之前每次进行full purge操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size，该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改InnoDB 1.0.x版本在性能方面取得了极大的提高，其实这和前面提到的Master Thread的改动是密不可分的，因为InnoDB存储引擎的核心操作大部分都集中在Master Thread后台线程中。 InnoDB 1.2.x版本的Master Thread在InnoDB 1.2.x版本中再次对Master Thread进行了优化，由此也可以看出Master Thread对性能所起到的关键作用。在InnoDB 1.2.x版本中，Master Thread的伪代码如下：if InnoDB is idlesrv_master_do_idle_tasks();elsesrv_master_do_active_tasks();其中srv_master_do_idle_tasks()就是之前版本中每10秒的操作，srv_master_do_active_tasks()处理的是之前每秒中的操作。同时对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。 IO Thread在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（call back）处理。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。在Linux平台下，IO Thread的数量不能进行调整，但是在Windows平台下可以通过参数innodb_file_io_threads来增大IO Thread。从InnoDB 1.0.x版本开始，read thread和write thread分别增大到了4个，并且不再使用innodb_file_io_threads参数，而是分别使用innodb_read_io_threads和innodb_write_io_threads参数进行设置。 可以看到IO Thread 0为insert buffer thread。IO Thread 1为log thread。之后就是根据参数innodb_read_io_threads及innodb_write_io_threads来设置的读写线程，并且读线程的ID总是小于写线程。 SHOW VARIABLES LIKE'innodb_%io_threads'; SHOW ENGINE INNODB STATUS; SHOW VARIABLES LIKE'innodb_purge_threads'; ` Purge Thread 事务被提交后不需要undolog，那么需要PurgeThread来回收undo页 1.0 1.1 1.2 在master中，单独的，多个 Page cleaner 1.2.x 作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。 ","date":"2023-07-21","objectID":"/mysql/:2:4","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#每秒操作"},{"categories":["数据库"],"content":" 后台线程-Innodb的多线程模型master thread 核心线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等 Master thread loop(1.0.x)Master Thread具有最高的线程优先级别。 由多个循环（loop）组成 ​ 1. 主循环（loop) ​ 2. 后台循环（backgroup loop） ​ 3. 刷新循环（flush loop） ​ 4. 暂停循环（suspend loop）。 Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspendloop中进行切换。Loop被称为主循环，因为大多数的操作是在这个循环中，其中有两大部分的操作——每秒钟的操作和每10秒的操作。 每秒操作❑日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）； ❑合并插入缓冲 if IO 次数小于5； ❑至多刷新100个InnoDB的缓冲池中的脏页到磁盘 if innodb_max_dirty_pages_pct \u003e 90； ❑如果当前没有用户活动，则切换到background loop（可能）。 每10秒的操作❑合并至多5个插入缓冲（总是） ❑将日志缓冲刷新到磁盘（总是）； ❑删除无用的Undo页（总是）至多20条；1.2.x后，交给page cleaner thread ❑刷新100个或者10个脏页到磁盘（总是）。if buf_get_modified_ratio_pct \u003e 70, 刷新100哥 else if IO times \u003c 200 刷新100, else 刷新10 background loop，flush loop，suspend loop若当前没有用户活动（数据库空闲时）或者数据库关闭（shutdown），就会切换到这个循环。 执行以下操作： ❑删除无用的Undo页（总是）； ❑合并20个插入缓冲（总是）； ❑跳回到主循环（总是）； 不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。 若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend__loop，将Master Thread挂起，等待事件的发生。 InnoDB1.2.x 版本之前的Master ThreadInnoDB Plugin（从InnoDB1.0.x版本开始）提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：❑在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%；❑在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity。若用户使用了SSD类的磁盘，或者将几块磁盘做了RAID，当存储设备拥有更高的IO速度时，完全可以将innodb_io_capacity的值调得再高点，直到符合磁盘IO的吞吐量为止。 还有一个改变是：之前每次进行full purge操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size，该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改InnoDB 1.0.x版本在性能方面取得了极大的提高，其实这和前面提到的Master Thread的改动是密不可分的，因为InnoDB存储引擎的核心操作大部分都集中在Master Thread后台线程中。 InnoDB 1.2.x版本的Master Thread在InnoDB 1.2.x版本中再次对Master Thread进行了优化，由此也可以看出Master Thread对性能所起到的关键作用。在InnoDB 1.2.x版本中，Master Thread的伪代码如下：if InnoDB is idlesrv_master_do_idle_tasks();elsesrv_master_do_active_tasks();其中srv_master_do_idle_tasks()就是之前版本中每10秒的操作，srv_master_do_active_tasks()处理的是之前每秒中的操作。同时对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。 IO Thread在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（call back）处理。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。在Linux平台下，IO Thread的数量不能进行调整，但是在Windows平台下可以通过参数innodb_file_io_threads来增大IO Thread。从InnoDB 1.0.x版本开始，read thread和write thread分别增大到了4个，并且不再使用innodb_file_io_threads参数，而是分别使用innodb_read_io_threads和innodb_write_io_threads参数进行设置。 可以看到IO Thread 0为insert buffer thread。IO Thread 1为log thread。之后就是根据参数innodb_read_io_threads及innodb_write_io_threads来设置的读写线程，并且读线程的ID总是小于写线程。 SHOW VARIABLES LIKE'innodb_%io_threads'; SHOW ENGINE INNODB STATUS; SHOW VARIABLES LIKE'innodb_purge_threads'; ` Purge Thread 事务被提交后不需要undolog，那么需要PurgeThread来回收undo页 1.0 1.1 1.2 在master中，单独的，多个 Page cleaner 1.2.x 作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。 ","date":"2023-07-21","objectID":"/mysql/:2:4","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#每10秒的操作"},{"categories":["数据库"],"content":" 后台线程-Innodb的多线程模型master thread 核心线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等 Master thread loop(1.0.x)Master Thread具有最高的线程优先级别。 由多个循环（loop）组成 ​ 1. 主循环（loop) ​ 2. 后台循环（backgroup loop） ​ 3. 刷新循环（flush loop） ​ 4. 暂停循环（suspend loop）。 Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspendloop中进行切换。Loop被称为主循环，因为大多数的操作是在这个循环中，其中有两大部分的操作——每秒钟的操作和每10秒的操作。 每秒操作❑日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）； ❑合并插入缓冲 if IO 次数小于5； ❑至多刷新100个InnoDB的缓冲池中的脏页到磁盘 if innodb_max_dirty_pages_pct \u003e 90； ❑如果当前没有用户活动，则切换到background loop（可能）。 每10秒的操作❑合并至多5个插入缓冲（总是） ❑将日志缓冲刷新到磁盘（总是）； ❑删除无用的Undo页（总是）至多20条；1.2.x后，交给page cleaner thread ❑刷新100个或者10个脏页到磁盘（总是）。if buf_get_modified_ratio_pct \u003e 70, 刷新100哥 else if IO times \u003c 200 刷新100, else 刷新10 background loop，flush loop，suspend loop若当前没有用户活动（数据库空闲时）或者数据库关闭（shutdown），就会切换到这个循环。 执行以下操作： ❑删除无用的Undo页（总是）； ❑合并20个插入缓冲（总是）； ❑跳回到主循环（总是）； 不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。 若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend__loop，将Master Thread挂起，等待事件的发生。 InnoDB1.2.x 版本之前的Master ThreadInnoDB Plugin（从InnoDB1.0.x版本开始）提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：❑在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%；❑在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity。若用户使用了SSD类的磁盘，或者将几块磁盘做了RAID，当存储设备拥有更高的IO速度时，完全可以将innodb_io_capacity的值调得再高点，直到符合磁盘IO的吞吐量为止。 还有一个改变是：之前每次进行full purge操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size，该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改InnoDB 1.0.x版本在性能方面取得了极大的提高，其实这和前面提到的Master Thread的改动是密不可分的，因为InnoDB存储引擎的核心操作大部分都集中在Master Thread后台线程中。 InnoDB 1.2.x版本的Master Thread在InnoDB 1.2.x版本中再次对Master Thread进行了优化，由此也可以看出Master Thread对性能所起到的关键作用。在InnoDB 1.2.x版本中，Master Thread的伪代码如下：if InnoDB is idlesrv_master_do_idle_tasks();elsesrv_master_do_active_tasks();其中srv_master_do_idle_tasks()就是之前版本中每10秒的操作，srv_master_do_active_tasks()处理的是之前每秒中的操作。同时对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。 IO Thread在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（call back）处理。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。在Linux平台下，IO Thread的数量不能进行调整，但是在Windows平台下可以通过参数innodb_file_io_threads来增大IO Thread。从InnoDB 1.0.x版本开始，read thread和write thread分别增大到了4个，并且不再使用innodb_file_io_threads参数，而是分别使用innodb_read_io_threads和innodb_write_io_threads参数进行设置。 可以看到IO Thread 0为insert buffer thread。IO Thread 1为log thread。之后就是根据参数innodb_read_io_threads及innodb_write_io_threads来设置的读写线程，并且读线程的ID总是小于写线程。 SHOW VARIABLES LIKE'innodb_%io_threads'; SHOW ENGINE INNODB STATUS; SHOW VARIABLES LIKE'innodb_purge_threads'; ` Purge Thread 事务被提交后不需要undolog，那么需要PurgeThread来回收undo页 1.0 1.1 1.2 在master中，单独的，多个 Page cleaner 1.2.x 作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。 ","date":"2023-07-21","objectID":"/mysql/:2:4","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#background-loopflush-loopsuspend-loop"},{"categories":["数据库"],"content":" 后台线程-Innodb的多线程模型master thread 核心线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等 Master thread loop(1.0.x)Master Thread具有最高的线程优先级别。 由多个循环（loop）组成 ​ 1. 主循环（loop) ​ 2. 后台循环（backgroup loop） ​ 3. 刷新循环（flush loop） ​ 4. 暂停循环（suspend loop）。 Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspendloop中进行切换。Loop被称为主循环，因为大多数的操作是在这个循环中，其中有两大部分的操作——每秒钟的操作和每10秒的操作。 每秒操作❑日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）； ❑合并插入缓冲 if IO 次数小于5； ❑至多刷新100个InnoDB的缓冲池中的脏页到磁盘 if innodb_max_dirty_pages_pct \u003e 90； ❑如果当前没有用户活动，则切换到background loop（可能）。 每10秒的操作❑合并至多5个插入缓冲（总是） ❑将日志缓冲刷新到磁盘（总是）； ❑删除无用的Undo页（总是）至多20条；1.2.x后，交给page cleaner thread ❑刷新100个或者10个脏页到磁盘（总是）。if buf_get_modified_ratio_pct \u003e 70, 刷新100哥 else if IO times \u003c 200 刷新100, else 刷新10 background loop，flush loop，suspend loop若当前没有用户活动（数据库空闲时）或者数据库关闭（shutdown），就会切换到这个循环。 执行以下操作： ❑删除无用的Undo页（总是）； ❑合并20个插入缓冲（总是）； ❑跳回到主循环（总是）； 不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。 若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend__loop，将Master Thread挂起，等待事件的发生。 InnoDB1.2.x 版本之前的Master ThreadInnoDB Plugin（从InnoDB1.0.x版本开始）提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：❑在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%；❑在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity。若用户使用了SSD类的磁盘，或者将几块磁盘做了RAID，当存储设备拥有更高的IO速度时，完全可以将innodb_io_capacity的值调得再高点，直到符合磁盘IO的吞吐量为止。 还有一个改变是：之前每次进行full purge操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size，该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改InnoDB 1.0.x版本在性能方面取得了极大的提高，其实这和前面提到的Master Thread的改动是密不可分的，因为InnoDB存储引擎的核心操作大部分都集中在Master Thread后台线程中。 InnoDB 1.2.x版本的Master Thread在InnoDB 1.2.x版本中再次对Master Thread进行了优化，由此也可以看出Master Thread对性能所起到的关键作用。在InnoDB 1.2.x版本中，Master Thread的伪代码如下：if InnoDB is idlesrv_master_do_idle_tasks();elsesrv_master_do_active_tasks();其中srv_master_do_idle_tasks()就是之前版本中每10秒的操作，srv_master_do_active_tasks()处理的是之前每秒中的操作。同时对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。 IO Thread在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（call back）处理。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。在Linux平台下，IO Thread的数量不能进行调整，但是在Windows平台下可以通过参数innodb_file_io_threads来增大IO Thread。从InnoDB 1.0.x版本开始，read thread和write thread分别增大到了4个，并且不再使用innodb_file_io_threads参数，而是分别使用innodb_read_io_threads和innodb_write_io_threads参数进行设置。 可以看到IO Thread 0为insert buffer thread。IO Thread 1为log thread。之后就是根据参数innodb_read_io_threads及innodb_write_io_threads来设置的读写线程，并且读线程的ID总是小于写线程。 SHOW VARIABLES LIKE'innodb_%io_threads'; SHOW ENGINE INNODB STATUS; SHOW VARIABLES LIKE'innodb_purge_threads'; ` Purge Thread 事务被提交后不需要undolog，那么需要PurgeThread来回收undo页 1.0 1.1 1.2 在master中，单独的，多个 Page cleaner 1.2.x 作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。 ","date":"2023-07-21","objectID":"/mysql/:2:4","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#io-thread"},{"categories":["数据库"],"content":" C. checkpointWrite Ahead Log策略，即先写日志，再改数据。先写BFIM再写AFIM。先AFIM，再提交。 作用：缩短恢复时间；缓冲池不够用时，将脏页刷新到磁盘；重做日志不可用时，刷新脏页，以减少redo log。 LSN，log sequence number，8btyes，页，checkpoint和redo log都有LSN innodb支持两种checkpoint： sharp checkpoint，发生在数据库关闭时； fuzzy checkpoint：上述中作用的三种情况，以及 master thread checkpoint：每秒或每10秒 FLUSH_LRU_LIST checkpoint：释放LRU空间，1.12 版本开始， page cleaner thread负责，innodb_lru_sacn_depth，默认保证有1024个page可用 page cleaner thread Async/Sync Flush Checkpoint:用于减少redo log。将写入redo log的LSN记为redo_LSN, 已经刷新回磁盘最新页的LSN记为checkpoint_LSN 于是可以知道从redo_lsn 到checkpoint_lsn的范围是没有写入到redo log的，如果其小于日志总文件大小的75%，则无所谓，75-90，触发异步刷新，90以上同步刷新。刷新到小于75 page cleaner thread Dirty page too much checkpoint： 保证缓冲池可用页，innodb_dirty_pages_pct 默认75 ","date":"2023-07-21","objectID":"/mysql/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#c-checkpoint"},{"categories":["数据库"],"content":" D. innodb五个关键特性❑插入缓冲（Insert Buffer）（减少IO次数，只对不唯一插入生效） ❑两次写（Double Write）（保证写入成功） ❑自适应哈希索引（Adaptive Hash Index） ❑异步IO（Async IO）（减少IO次数，连续多页读） ❑刷新邻接页（Flush Neighbor Page）（减少IO次数，连续多页写） ","date":"2023-07-21","objectID":"/mysql/:4:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#d-innodb五个关键特性"},{"categories":["数据库"],"content":" 插入缓冲对于非唯一非聚集索引的插入或更新操作 查看索引页是否在缓冲池中，如果在则直接插入，如果不在，先放在insert buffer对象中。然后在merge 缺点：如果发生宕机，不在缓冲池且至少在10s内发生了高并发，根据WAL，则需要根据log需要大量的时间回复。占用大量缓冲池内存，最多可以到50% innodb1.0.x开始引入change buffer，可以对插入，删除，修改都进行缓冲，即insert buffer，delete buffer，purge buffer。 实现细节insert buffer 是b+树， 非叶子结点： space 表空间ID 4byte marker 兼容性位置 1byte offset 偏移量 4byte 叶子结点： metadata：4 bytes IBUF_REC_OFFSET_COUNT：进入Insert Buffer的顺序 IBUF_REC_OFFSET_TYPE： IBUF_REC_OFFSET_FLAGS： 为了保证每次Merge Insert Buffer页必须成功，还需要有一个特殊的页用来标记每个辅助索引页（space，page_no）的可用空间。这个页的类型为Insert Buffer Bitmap。 什么时候Merge？ 辅助索引页被读取到缓冲池时 Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时；Insert Buffer Bitmap页用来追踪每个辅助索引页的可用空间，并至少有1/32页的空间 Master Thread。之前在分析Master Thread时曾讲到，在Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作，不同之处在于每次进行merge操作的页的数量不同。 merge 页选择：随机选择，更公平，如果页已经被删除，则直接丢弃。 ","date":"2023-07-21","objectID":"/mysql/:4:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#插入缓冲"},{"categories":["数据库"],"content":" 插入缓冲对于非唯一非聚集索引的插入或更新操作 查看索引页是否在缓冲池中，如果在则直接插入，如果不在，先放在insert buffer对象中。然后在merge 缺点：如果发生宕机，不在缓冲池且至少在10s内发生了高并发，根据WAL，则需要根据log需要大量的时间回复。占用大量缓冲池内存，最多可以到50% innodb1.0.x开始引入change buffer，可以对插入，删除，修改都进行缓冲，即insert buffer，delete buffer，purge buffer。 实现细节insert buffer 是b+树， 非叶子结点： space 表空间ID 4byte marker 兼容性位置 1byte offset 偏移量 4byte 叶子结点： metadata：4 bytes IBUF_REC_OFFSET_COUNT：进入Insert Buffer的顺序 IBUF_REC_OFFSET_TYPE： IBUF_REC_OFFSET_FLAGS： 为了保证每次Merge Insert Buffer页必须成功，还需要有一个特殊的页用来标记每个辅助索引页（space，page_no）的可用空间。这个页的类型为Insert Buffer Bitmap。 什么时候Merge？ 辅助索引页被读取到缓冲池时 Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时；Insert Buffer Bitmap页用来追踪每个辅助索引页的可用空间，并至少有1/32页的空间 Master Thread。之前在分析Master Thread时曾讲到，在Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作，不同之处在于每次进行merge操作的页的数量不同。 merge 页选择：随机选择，更公平，如果页已经被删除，则直接丢弃。 ","date":"2023-07-21","objectID":"/mysql/:4:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#实现细节"},{"categories":["数据库"],"content":" 两次写先通过memcopy函数复制到内存的doublewrite buffer 2MB, 然后 分两次复制到共享表空间的共享物理磁盘上，然后调用fsync函数同步磁盘，避免缓冲写带来的问题。 双写其实是备份了一个完整的page。如果直接写入数据文件，则可能写到一半宕机，则页被破坏。无法通过redolog恢复，因为redolog记录的是在页的某一个片段的数据，而如果整个页的部份发生损毁，那么即使记录了部份页的数据也不能恢复整个页 ","date":"2023-07-21","objectID":"/mysql/:4:2","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#两次写"},{"categories":["数据库"],"content":" 自适应哈希索引速度快 统计访问频率 访问了N次，访问了N=页中记录数量的/16 ","date":"2023-07-21","objectID":"/mysql/:4:3","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#自适应哈希索引"},{"categories":["数据库"],"content":" 异步IO1.速度快 2.判断访问页是否可以连续读取， 比如连续的三个页，一次读取48kb，减少IO次数 ","date":"2023-07-21","objectID":"/mysql/:4:4","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#异步io"},{"categories":["数据库"],"content":" 刷新邻接页刷新脏页的时候，这个页所在区的所有page，如果有脏页，一块刷新，好处是合并IO次数 ","date":"2023-07-21","objectID":"/mysql/:4:5","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#刷新邻接页"},{"categories":["数据库"],"content":" E. Innodb关闭启动与恢复 关闭：innodb_fast_shutdown:0,1,2 默认1 ❑0表示在MySQL数据库关闭时，InnoDB需要完成所有的full purge和merge insert buffer，并且将所有的脏页刷新回磁盘。这需要一些时间，有时甚至需要几个小时来完成。如果在进行InnoDB升级时，必须将这个参数调为0，然后再关闭数据库。 ❑1是参数innodb_fast_shutdown的默认值，表示不需要完成上述的full purge和merge insert buffer操作，但是在缓冲池中的一些数据脏页还是会刷新回磁盘。 ❑2表示不完成full purge和merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志都写入日志文件。这样不会有任何事务的丢失，但是下次MySQL数据库启动时，会进行恢复操作（recovery）。 ","date":"2023-07-21","objectID":"/mysql/:5:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#e-innodb关闭启动与恢复"},{"categories":["数据库"],"content":" E. Innodb关闭启动与恢复 关闭：innodb_fast_shutdown:0,1,2 默认1 ❑0表示在MySQL数据库关闭时，InnoDB需要完成所有的full purge和merge insert buffer，并且将所有的脏页刷新回磁盘。这需要一些时间，有时甚至需要几个小时来完成。如果在进行InnoDB升级时，必须将这个参数调为0，然后再关闭数据库。 ❑1是参数innodb_fast_shutdown的默认值，表示不需要完成上述的full purge和merge insert buffer操作，但是在缓冲池中的一些数据脏页还是会刷新回磁盘。 ❑2表示不完成full purge和merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志都写入日志文件。这样不会有任何事务的丢失，但是下次MySQL数据库启动时，会进行恢复操作（recovery）。 ","date":"2023-07-21","objectID":"/mysql/:5:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#关闭"},{"categories":["数据库"],"content":" 三、文件","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#三文件"},{"categories":["数据库"],"content":" 参数文件启动时先读取参数文件，可以看成key - value pair 有的是只读，有的是可以改 ","date":"2023-07-21","objectID":"/mysql/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#参数文件"},{"categories":["数据库"],"content":" 日志文件-错误日志（实用性辅助定位错误，log_error ","date":"2023-07-21","objectID":"/mysql/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#日志文件-错误日志实用性"},{"categories":["数据库"],"content":" 日志文件-慢查询日志（调优重要slow_query_log 默认不开启 按时间划分 long_query_time精确到微秒，大于该时间的会被记录 按是否使用索引划分 log_queries_not_using_indexes 这种情况下可能造成频繁的记录，导致slow log不断增大，可通过log_throttle_queries_not_using_indexes来进行限制每分钟可记录条数 ","date":"2023-07-21","objectID":"/mysql/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#日志文件-慢查询日志调优重要"},{"categories":["数据库"],"content":" 日志文件-查询日志（了解所有请求信息。 默认名为主机名.log general.log ","date":"2023-07-21","objectID":"/mysql/:4:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#日志文件-查询日志了解"},{"categories":["数据库"],"content":" 日志文件-二进制文件（最重要记录了所有修改操作（不包括show 和 select ","date":"2023-07-21","objectID":"/mysql/:5:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#日志文件-二进制文件最重要"},{"categories":["数据库"],"content":" 作用恢复（recovery）：某些数据的恢复需要二进制日志，例如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行point-in-time的恢复。 复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为slave或standby）与一台MySQL数据库（一般称为master或primary）进行实时同步。 审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击。 默认关闭：since 恢复可以用redo，如果是单机，不需要审计 log_bin = off OR log_bin = 文件名 分为log_name.index 和log_name.000001 参数 max_binlog_size 默认1GB binlog_cache_size 默认32KB，基于会话。存储uncommitted log record，大于该值时，写入临时文件， sync_binlog 每写多少次缓冲就同步到磁盘，如果为1则不使用缓冲，0则没有限制。 binlog_do_db 哪些需要二进制文件 binlog_ignore_db 忽略哪些库的日志 log_slave_update 从主服务器获取二进制文件并且入自己的二进制文件中去， 默认off，依然可以同步，但是只用不存，ON则会存入自己的二进制文件。 所以，当a-\u003eb-\u003ec的时候，b off，则c无法读取到a binlog_format 存储形式。statement，row，mixed。如果设置为ROW可以重复读，获得更高的并发性。 MIXED：默认采用STATEMENT格式进行二进制日志文件的记录，但是在一些情况下会使用ROW格式： 1）表的存储引擎为NDB，这时对表的DML操作都会以ROW格式记录。 2）使用了UUID()、USER()、CURRENT_USER()、FOUND_ROWS()、ROW_COUNT()等不确定函数。 3）使用了INSERT DELAY语句。 4）使用了用户定义函数（UDF）。 5）使用了临时表（temporary table）。 ","date":"2023-07-21","objectID":"/mysql/:5:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#作用"},{"categories":["数据库"],"content":" Socket文件（了解UNIX系统下，用UNIX域套接字方式。需要一个套接字文件，一般在/tmp目录下，名为mysql.sock。 ","date":"2023-07-21","objectID":"/mysql/:6:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#socket文件了解"},{"categories":["数据库"],"content":" pid文件（了解当MySQL实例启动时，会将自己的进程ID写入一个文件中——该文件即为pid文件。该文件可由参数pid_file控制，默认位于数据库目录下，文件名为主机名.pid ","date":"2023-07-21","objectID":"/mysql/:7:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#pid文件了解"},{"categories":["数据库"],"content":" MySQL表结构文件每个表都会有与之对应的表结构文件。frm为后缀。不需要修改，了解即可 ","date":"2023-07-21","objectID":"/mysql/:8:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#mysql表结构文件"},{"categories":["数据库"],"content":" 存储引擎文件-表空间文件默认12MB，自动扩展，ibdata1文件，默认表空间 innodb_data_file_path，设置了之后，所有表都存在这里，可以用两个文件组成表空间，通过放在不同的磁盘上，磁盘的负载被平均，提高性能。 innodb_file_per_table ，默认开启每个表都有独立表空间，.ibd，这里仅存data， index，插入缓冲BITMAP，其余信息依旧存在于ibdata1 ","date":"2023-07-21","objectID":"/mysql/:9:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#存储引擎文件-表空间文件"},{"categories":["数据库"],"content":" 存储引擎文件-重做日志文件in_logfile0 和in_logfile1，innodb至少有一个group，每个group至少有2个重做日志文件。 innodb_log_file_size，1.2之前4G，1.2扩大到512G innodb_log_files_in_group innodb_mirrored_log_groups innodb_log_group_home_dir 大小设置很关键，太大则恢复时间长，太小可能导致一个事物的日志需要多次切换重做日志文件，或者进而导致async checkpoint频繁发生，导致性能抖动 为什么不用redolog进行主从复制？ 二进制文件会记录所有日志记录，各种引擎的都会记录。而重做日志只记录innodb引擎的。 二进制文件关于事务的具体操作内容。而重做日志是记录了每个页的物理情况。 写入时间不同，二进制文件只在commit前写一次，重做日志不断写入。 先写入redo log buffer，再写入redo log文件。写入磁盘时，512bytes一组，一个扇区，原子性，因此不需要有double write ","date":"2023-07-21","objectID":"/mysql/:10:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#存储引擎文件-重做日志文件"},{"categories":["数据库"],"content":" 四、InnoDB存储引擎的表","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#四innodb存储引擎的表"},{"categories":["数据库"],"content":" A. innodb 逻辑存储结构根据主键顺序，称之为index organized table。如果没有主键，则选择非空唯一索引，不然，则自动创建6bytes pointer，_rowid ","date":"2023-07-21","objectID":"/mysql/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#a-innodb-逻辑存储结构"},{"categories":["数据库"],"content":" 表空间结构 如果启用了innodb_file_per_table的参数，需要注意的是每张表的表空间内存放的只是数据、索引和插入缓冲Bitmap页，其他类的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲（Double write buffer）等还是存放在原来的共享表空间ibdata1内。 共享表空间的undo不会被回收，但是会被标记为可用。 ","date":"2023-07-21","objectID":"/mysql/:1:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#表空间结构"},{"categories":["数据库"],"content":" 段数据段（叶子结点）、索引段（非叶子结点）、回滚段。 ","date":"2023-07-21","objectID":"/mysql/:1:2","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#段"},{"categories":["数据库"],"content":" 区1MB，连续页组成，每次申请4～5个区保证页的连续。 16KB一个页，64页/区 1.0.x key_block_size，压缩页，设置为2，4，8KB 1.2.x innodb_page_size，修改默认大小4，8KB 开启inndob_file_per_table 后，表默认大小96KB，为什么不是1MB？不会在一开始就使用连续的页，而是先使用32个页大小的碎片页，即数据来到0.5MB后，第二次申请区才会连续。 ","date":"2023-07-21","objectID":"/mysql/:1:3","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#区"},{"categories":["数据库"],"content":" 页innodb磁盘管理最小单位。 页的类型 ❑数据页（B-tree Node） ❑undo页（undo Log Page） ❑系统页（System Page） ❑事务数据页（Transaction system Page） ❑插入缓冲位图页（Insert Buffer Bitmap） ❑插入缓冲空闲列表页（Insert Buffer Free List） ❑未压缩的二进制大对象页（Uncompressed BLOB Page） ❑压缩的二进制大对象页（compressed BLOB Page） ","date":"2023-07-21","objectID":"/mysql/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#页"},{"categories":["数据库"],"content":" 行-compact格式（默认innodb按照行存储，与列存储区别？ 每页最多存放16KB/2 - 200，即2～7992行 Compact行记录格式的首部是一个非NULL变长字段长度列表，并且其是按照列的顺序逆序放置的，其长度为： ❑若列的长度小于255字节，用1字节表示； ❑若大于255个字节，用2字节表示。变长字段的长度最大不可以超过2字节，这是因在MySQL数据库中VARCHAR类型的最大长度限制为65535bytes,实际为65532，且是一列中所有变长字符串之和。对于大对象或者长字符串，如果一个page只能存放一个对象，为了使用B+树，则把大对象放在BLOB PAGE NULL标志位，行中有NULL值，则1。 记录头信息（record header），固定占用5字节（40位），每位的含义见表 最后的部分就是实际存储每个列的数据。需要特别注意的是，NULL不占该部分任何空间，即NULL除了占有NULL标志位，实际存储不占有任何空间。另外有一点需要注意的是，每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节的大小。若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。 行compact格式下，char要用20补齐 ","date":"2023-07-21","objectID":"/mysql/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#行-compact格式默认"},{"categories":["数据库"],"content":" 行- redundant（5.0之前的默认，被淘汰了。字段长度偏移列表，同样是按照列的顺序逆序放置的。若列的长度小于255字节，用1字节表示；若大于255字节，用2字节表示。 记录头信息（record header），不同于Compact行记录格式，Redundant行记录格式的记录头占用6字节（48位） ","date":"2023-07-21","objectID":"/mysql/:4:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#行--redundant50之前的默认被淘汰了"},{"categories":["数据库"],"content":" 数据页结构（了解 InnoDB数据页由以下7个部分组成，如图： File Header（文件头） Page Header（页头） Infimun和Supremum Records User Records（用户记录，即行记录） Free Space（空闲空间） Page Directory（页目录） File Trailer（文件结尾信息） 其中File Header、Page Header、File Trailer的大小是固定的，分别为38、56、8字节，这些空间用来标记该页的一些信息，如Checksum，数据页所在B+树索引的层数等。User Records、Free Space、Page Directory这些部分为实际的行记录存储空间，因此大小是动态的。 File Header用来记录页的一些头信息，由表中8个部分组成，共占用38字节。 Page Header，该部分用来记录数据页的状态信息，由14个部分组成，共占用56字节， Infimum和Supremum Record 在InnoDB存储引擎中，每个数据页中有两个虚拟的行记录，用来限定记录的边界。Infimum记录是比该页中任何主键值都要小的值，Supremum指比任何可能大的值还要大的值。这两个值在页创建时被建立，并且在任何情况下不会被删除。 User Record,Free Space,Page Directory和File Trailer User Record即实际存储行记录的内容。 Free Space很明显指的就是空闲空间，同样也是个链表数据结构。在一条记录被删除后，该空间会被加入到空闲链表中。 Page Directory（页目录）中存放了记录的相对位置（注意，这里存放的是页相对位置，而不是偏移量），有些时候这些记录指针称为Slots（槽）或目录槽（Directory Slots）。与其他数据库系统不同的是，在InnoDB中并不是每个记录拥有一个槽，而是一个槽中可能包含多个记录。B+树索引本身并不能找到具体的一条记录，能找到只是该记录所在的页。数据库把页载入到内存，然后通过Page Directory再进行二叉查找。只不过二叉查找的时间复杂度很低，同时在内存中的查找很快，因此通常忽略这部分查找所用的时间。 File Trailer只有一个FIL_PAGE_END_LSN部分，占用8字节。前4字节代表该页的checksum值，最后4字节和File Header中的FIL_PAGE_LSN相同。将这两个值与File Header中的FIL_PAGE_SPACE_OR_CHKSUM和FIL_PAGE_LSN值进行比较，看是否一致（checksum的比较需要通过InnoDB的checksum函数来进行比较，不是简单的等值比较），以此来保证页的完整性（not corrupted）。为了检测页是否已经完整地写入磁盘（如可能发生的写入过程中磁盘损坏、机器关机等） Named File Formates 机制，保证兼容性 InnoDB存储引擎将1.0.x版本之前的文件格式（file format）定义为Antelope，将之后版本支持的文件格式定义为Barracuda。新的文件格式总是包含于之前的版本的页格式。下图显示了Barracuda文件格式和Antelope文件格式之间的关系，Antelope文件格式有Compact和Redudant的行格式，Barracuda文件格式既包括了Antelope所有的文件格式，另外新加入了之前已经提到过的Compressed和Dynamic行格式。 compressed可以使用zlib算法压缩，对于BLOB，text，varchar进行有效存储 行溢出 一个页要至少存储两条记录（不然链表了），不然大数据存到BLOB Page。 varchar一行总和理论存储65535bytes，实际上65532. ","date":"2023-07-21","objectID":"/mysql/:5:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#数据页结构了解"},{"categories":["数据库"],"content":" 视图一条SQL记录。 可以通过view来修改数据。对于一个10列的表，可以选中想展示的3条，来进行数据封装。 不支持物化视图，但是可以提前定时查询，插入一张聚合表。 ","date":"2023-07-21","objectID":"/mysql/:6:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#视图"},{"categories":["数据库"],"content":" 分区表容量较大的时候，分区后查询速度较快。插入效率可能影响。不在引擎层完成。 如MyISAM，INNODB 5.1版本后可以分区！！！ 水平分区：一台服务器上（同行不同物理文件） 垂直分区：（同列不同物理文件）不太好用，如果选择了两个列在不同分区。 mysql调优的水平拆分 一个表变两个表，10条数据，5个在表1，5个在表2 垂直拆分：字段拆分，ID，name，age编程ID，name和ID，age。如果查询是分开查询，则拆分。如果需要join，考虑水平拆分。 分区类型： 假删除，删除标记，不真删。 需要整形或者转化为整形 range分区，主键范围，指定列的保存分区。null小于任何非null list分区，奇数一部分，偶数一部分。指定列的保存分区。 hash分区，均匀分布，指定hash列和hash表达式。null-\u003e0 key分区，不用自己指定表达式 5.5之后可以不转成整形。 常见： CREATE TABLE t columns_range( a INT, b DATETIME )ENGINE=INNODB PARTITION BY RANGE COLUMNS(B) PARTITION p0 VALUES LESS THAN('2009-01-01'), PARTITION p1 VALUES LESS THAN('2010-01-01'); 子分区维护成本很大。复合分区。可以使用拆分+分区。 mysql\u003e CREATE TABLE ts(a INT,b DATE)engine=innodb -\u003e PARTITION BY RANGE(YEAR(b)) -\u003e SUBPARTITION BY HASHTO DAYS(b)) -\u003e SUBPARTITIONS 2( -\u003e PARTITION PO VALUES LESS THAN(1990) -\u003e PARTITION P1 VALUES LESS THAN(2000) -\u003e PARTITION P2 VALUES LESS THAN MAXVALUE -\u003e ); ","date":"2023-07-21","objectID":"/mysql/:7:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#分区"},{"categories":["数据库"],"content":" 约束表建立时就进行约束定义，如： 利用ALTER TABLE命令来进行创建约束，对Unique Key（唯一索引）的约束 通过命令CREATE UNIQUE INDEX来建立。 对于主键约束而言，其默认约束名为PRIMARY。 而对于Unique Key约束而言，默认约束名和列名一样，当然也可以人为指定Unique Key约束的名字。 Foreign Key约束也是如此。 NOT NULL 字段的约束。 ENUM 和 SET 字段的约束。 触发器约束。 创建触发器的命令是CREATE TRIGGER，只有具备Super权限的MySQL数据库用户才可以执行这条命令。 ","date":"2023-07-21","objectID":"/mysql/:8:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#约束"},{"categories":["数据库"],"content":" 五、索引｜重点数据结构：B+树，hash table，Auxiliary table，R-tree index Oracle： ","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#五索引重点"},{"categories":["数据库"],"content":" A. B+树索引太多，需要维护，创建，时间空间，修改， 太少则查询效率低。 不能直接找到记录，可以找到记录所在页，读入内存后，通过page_directory进行二分查找。 高扇出性。一般2～4层。机械磁盘100 I/O per second 聚集索引、辅助索引都是B+树 ","date":"2023-07-21","objectID":"/mysql/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#a-b树"},{"categories":["数据库"],"content":" 使用经验已经知道数据库中存在两种类型的应用，OLTP和OLAP应用。在OLTP应用中，查询操作只从数据库中取得一小部分数据，一般可能都在10条记录以下，甚至在很多时候只取1条记录，如根据主键值来取得用户信息，根据订单号取得订单的详细信息，这都是典型OLTP应用的查询语句。在这种情况下，B+树索引建立后，对该索引的使用应该只是通过该索引取得表中少部分的数据。这时建立B+树索引才是有意义的，否则即使建立了，优化器也可能选择不使用索引。 对于OLAP应用，情况可能就稍显复杂了。不过概括来说，在OLAP应用中，都需要访问表中大量的数据，根据这些数据来产生查询的结果，这些查询多是面向分析的查询，目的是为决策者提供支持。如这个月每个用户的消费情况，销售额同比、环比增长的情况。因此在OLAP中索引的添加根据的应该是宏观的信息，而不是微观，因为最终要得到的结果是提供给决策者的。例如不需要在OLAP中对姓名字段进行索引，因为很少需要对单个用户进行查询。但是对于OLAP中的复杂查询，要涉及多张表之间的联接操作，因此索引的添加依然是有意义的。但是，如果联接操作使用的是Hash Join，那么索引可能又变得不是非常重要了，所以这需要DBA或开发人员认真并仔细地研究自己的应用。不过在OLAP应用中，通常会需要对时间字段进行索引，这是因为大多数统计需要根据时间维度来进行数据的筛选。 ","date":"2023-07-21","objectID":"/mysql/:1:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#使用经验"},{"categories":["数据库"],"content":" B. 聚集索引主键构造b+树 叶子结点是整行数据。 查询倾向采用聚集索引。因为可以在叶子结点直接找到数据。 对于范围查找a～d，先找到a，依次找到b，c，d 通过Recorder Header中最后的两个字节来判断下一条记录的位置，读取键值可得80 00 00 01，这就是主键为1的键值，80 00 00 01后的值00 00 00 04代表指向数据页的页号。同样的方式可以找到80 00 00 02和80 00 00 04这两个键值以及它们指向的数据页。通过以上对非数据页节点的分析，可以发现数据页上存放的是完整的每行的记录，而在非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量，而不是一个完整的行记录。因此这棵聚集索引树的构造大致如图：聚集索引的存储并不是物理上连续的，而是逻辑上连续的。这其中有两点：一是前面说过的页通过双向链表链接，页按照主键的顺序排序；另一点是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。 ","date":"2023-07-21","objectID":"/mysql/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#b-聚集索引"},{"categories":["数据库"],"content":" C. 辅助索引key index_name(cloum_name) 叶子结点：索引列value，和主键（为什么不直接存储位置？数据移动不需要修改辅助索引）。通过主键再去primary index查找。 那么重复的是什么数据结构？？？ ","date":"2023-07-21","objectID":"/mysql/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#c-辅助索引"},{"categories":["数据库"],"content":" D. 索引管理通过SHOW INDEX FROM table_name ❑Table：索引所在的表名。 ❑Non_unique：非唯一的索引，可以看到primary key是0，因为必须是唯一的 ❑Key_name：索引的名字，用户可以通过这个名字来执行DROP INDEX ❑Seq_in_index：索引中该列的位置，如果看联合索引idx_a_c就比较直观了。 ❑Column_name：索引列的名称。 ❑Collation：列以什么方式存储在索引中。可以是NULL。B+树索引总是A，即排序的。如果使用了Heap存储引擎，并且建立了Hash索引，这里就会显示NULL了。因为Hash根据Hash桶存放索引数据，而不是对数据进行排序。 ❑Cardinality：非常关键的值，表示索引中唯一值（即多少个不同的值）的数目的估计值。Cardinality表的行数应尽可能接近1，如果非常小，那么用户需要考虑是否可以删除此索引。 ❑Sub_part：是否是列的部分被索引。如果看idx_b这个索引，这里显示100，表示只对b列的前100字符进行索引。如果索引整个列，则该字段为NULL。 ❑Packed：关键字如何被压缩。如果没有被压缩，则为NULL。 ❑Null：是否索引的列含有NULL值。可以看到idx_b这里为Yes，因为定义的列b允许NULL值。 ❑Index_type：索引的类型。InnoDB存储引擎只支持B+树索引，所以这里显示的都是BTREE。Comment：注释。 ","date":"2023-07-21","objectID":"/mysql/:4:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#d-索引管理"},{"categories":["数据库"],"content":" 1. FIC 快速索引创建MySQL 5.5版本之前（不包括5.5）存在的一个普遍被人诟病的问题是MySQL数据库对于索引的添加或者删除的这类DDL操作，MySQL数据库的操作过程为： ❑首先创建一张新的临时表，表结构为通过命令ALTER TABLE新定义的结构（创建索引）。 ❑然后把原表中数据导入到临时表。 ❑接着删除原表。 ❑最后把临时表重名为原来的表名。 可以发现，若用户对于一张大表进行索引的添加和删除操作，那么这会需要很长的时间。更关键的是，若有大量事务需要访问正在被修改的表，这意味着数据库服务不可用。 FIC优化了辅助索引的创建、删除 创建：表加上s锁， 删除：辅助索引操作就更简单了，InnoDB存储引擎只需更新内部视图，并将辅助索引的空间（内存）标记为可用（你随时使用这块空间，我现在这块空间没人使用了），同时删除MySQL数据库内部视图上对该表的索引定义即可。 ","date":"2023-07-21","objectID":"/mysql/:4:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#1-fic-快速索引创建"},{"categories":["数据库"],"content":" 2. OSC（online schema change）了解Online Schema Change（在线架构改变，简称OSC）最早是由Facebook实现的一种在线执行DDL的方式，并广泛地应用于Facebook的MySQL数据库。所谓“在线”是指在事务的创建过程中，可以有读写事务对表进行操作，这提高了原有MySQL数据库在DDL操作时的并发性。Facebook采用PHP脚本来现实OSC，而并不是通过修改InnoDB存储引擎源码的方式。 实现OSC步骤如下： ❑init，即初始化阶段，会对创建的表做一些验证工作，如检查表是否有主键，是否存在触发器或者外键等。 ❑createCopyTable，创建和原始表结构一样的新表。 ❑alterCopyTable：对创建的新表进行ALTER TABLE操作，如添加索引或列等。 ❑createDeltasTable，创建deltas表，该表的作用是为下一步创建的触发器所使用。之后对原表的所有DML操作会被记录到createDeltasTable中。 ❑createTriggers，对原表创建INSERT、UPDATE、DELETE操作的触发器。触发操作产生的记录被写入到deltas表。 ❑startSnpshotXact，开始OSC操作的事务。 ❑selectTableIntoOutfile，将原表中的数据写入到新表。为了减少对原表的锁定时间，这里通过分片（chunked）将数据输出到多个外部文件，然后将外部文件的数据导入到copy表中。分片的大小可以指定，默认值是500 000。 ❑dropNCIndexs，在导入到新表前，删除新表中所有的辅助索引。 ❑loadCopyTable，将导出的分片文件导入到新表。 ❑replayChanges，将OSC过程中原表DML操作的记录应用到新表中，这些记录被保存在deltas表中。 ❑recreateNCIndexes，重新创建辅助索引。 ❑replayChanges，再次进行DML日志的回放操作，这些日志是在上述创建辅助索引中过程中新产生的日志。 ❑swapTables，将原表和新表交换名字，整个操作需要锁定2张表，不允许新的数据产生。由于改名是一个很快的操作，因此阻塞的时间非常短。上述只是简单介绍了OSC的实现过程，实际脚本非常复杂。由于OSC只是一个PHP脚本，因此其有一定的局限性。 ","date":"2023-07-21","objectID":"/mysql/:4:2","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#2-osconline-schema-change了解"},{"categories":["数据库"],"content":" 3. online ddl5.6开始 实现原理 InnoDB存储引擎实现Online DDL的原理是在执行创建或者删除操作的同时，将INSERT、UPDATE、DELETE这类DML操作日志写入到一个缓存中。待完成索引创建后再将重做应用到表上，以此达到数据的一致性。这个缓存的大小由参数innodb_online_alter_log_max_size控制，默认的大小为128MB。 允许辅助索引创建的同时，还允许其他诸如INSERT、UPDATE、DELETE这类DML操作 以下这几类DDL操作都可以通过“在线”的方式进行操作： ❑辅助索引的创建与删除 ❑改变自增长值 ❑添加或删除外键约束 ❑列的重命名通过新的ALTER TABLE语法， 用户可以选择索引的创建方式： 算法: COPY表示按照MySQL 5.1版本之前的工作模式，即创建临时表的方式。 INPLACE表示索引创建或删除操作不需要创建临时表。 DEFAULT表示根据参数old_alter_table来判断是通过INPLACE还是COPY的算法，该参数的默认值为OFF，表示采用INPLACE的方式 LOCK （1）NONE 执行索引创建或者删除操作时，对目标表不添加任何的锁，即事务仍然可以进行读写操作，不会收到阻塞。因此这种模式可以获得最大的并发度。 （2）SHARE 这和之前的FIC类似，执行索引创建或删除操作时，对目标表加上一个S锁。对于并发地读事务，依然可以执行，但是遇到写事务，就会发生等待操作。如果存储引擎不支持SHARE模式，会返回一个错误信息。 （3）EXCLUSIVE 在EXCLUSIVE模式下，执行索引创建或删除操作时，对目标表加上一个X锁。读写事务都不能进行，因此会阻塞所有的线程，这和COPY方式运行得到的状态类似，但是不需要像COPY方式那样创建一张临时表。 （4）DEFAULT DEFAULT模式首先会判断当前操作是否可以使用NONE模式，若不能，则判断是否可以使用SHARE模式，最后判断是否可以使用EXCLUSIVE模式。也就是说DEFAULT会通过判断事务的最大并发性来判断执行DDL的模式。 操作日志写入缓存，待完成索引创建后再将重做应用到表上。这个缓存的大小由参数innodb_online_alter_log_max_size控制，默认的大小为128MB。 用户更新的表比较大，并且在创建过程中伴有大量的写事务，如遇到innodb_online_alter_log_max_size的空间不能存放日志时，会抛出类似如下的错误：Error:1799SQLSTATE:HY000(ER_INNODB_ONLINE_LOG_TOO_BIG)Message:Creating index’idx_aaa’required more than’innodb_online_alter_log_max_size’bytes of modification log.Please try again.对于这个错误，用户可以调大参数innodb_online_alter_log_max_size，以此获得更大的日志缓存空间。 此外，还可以设置ALTER TABLE的模式为SHARE，这样在执行过程中不会有写事务发生，因此不需要进行DML日志的记录。需要特别注意的是，由于Online DDL在创建索引完成后再通过重做日志达到数据库的最终一致性，这意味着在索引创建过程中，SQL优化器不会选择正在创建中的索引。 ","date":"2023-07-21","objectID":"/mysql/:4:3","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#3-online-ddl"},{"categories":["数据库"],"content":" Cardnality抽样估计列中多少种不同的value Cardnality/row # 尽可能等于1 更新：表中有1/16的数据发生变化 OR 修改次数stat_modified_counter 对8个叶子结点采样。 取得叶子结点总数量 A，随机取8个叶子结点，记录8个页中不同value 的个数 P Cardnality～P*A/8 当执行SQL语句ANALYZE TABLE、SHOW TABLE STATUS、SHOW INDEX以及访问INFORMATION_SCHEMA架 构下的表TABLES和STATISTICS时会导致InnoDB存储引擎去重新计算索引的Cardinality值。若表中的数据量非 常大，并且表中存在多个辅助索引时，执行上述这些操作可能会非常慢。虽然用户可能并不希望去更新 Cardinality值。 些情况下可能会发生索引建立了却没有用到的情况，可能会出现Cardinality为NULL，致使优化器不选择 使用索引。这时最好的解决办法就是做一次ANALYZE TABLE的操作。因此在场景允许的情况下，建议在一个 非高峰时间，对应用程序下的几张核心表做ANALYZE TABLE操作，这能使优化器和索引更好地为你工作。 ","date":"2023-07-21","objectID":"/mysql/:4:4","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#cardnality"},{"categories":["数据库"],"content":" E. 联合索引多列索引 对于(a, b)的联合索引，支持a，支持ab，不支持b 对于b，正逆排序都无需重新排序。 ","date":"2023-07-21","objectID":"/mysql/:5:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#e-联合索引"},{"categories":["数据库"],"content":" F. 覆盖索引其实是覆盖了所有projection的列。 ","date":"2023-07-21","objectID":"/mysql/:6:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#f-覆盖索引"},{"categories":["数据库"],"content":" G. Multi-Range Read (MRR)5.6开始 目的：减少磁盘随机访问，将随机访问转化成顺序访问 对于range，ref，eq_ref的查询类型，则可以优化。 优势： 顺序访问。使用辅助索引时候，得到查询结果set，对主键排序，回到聚簇索引搜索，减少IO。 减少缓冲页被替换的次数 批量处理 工作原理 对于select和join操作 辅助索引键值放到缓存中，此时是按照辅助索引键值排序 按照主键排序 根据主键访问。 参数 启用通过参数optimizer_switch中的标记（flag）来控制。当mrr为on时，表示启用Multi-Range Read优化。 mrr_cost_based标记表示是否通过cost based的方式来选择是否启用mrr。若将mrr设为on，mrr_cost_based设为off，则总是启用Multi-Range Read优化。 例如，下述语句可以将Multi-Range Read优化总是设为开启状态：mysql＞SET@@optimizer_switch=‘mrr=on,mrr_cost_based=off’; ","date":"2023-07-21","objectID":"/mysql/:7:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#g-multi-range-read-mrr"},{"categories":["数据库"],"content":" H. ICP 优化 index condition pushdown5.6开始 作用于condition上。将where操作放在了存储引擎层。 减少了上层sql对于记录的索取 支持range、ref、eq_ref、ref_or_null类型的查询，当前支持MyISAM和InnoDB存储引擎。当优化器选择Index Condition Pushdown优化时，可在执行计划的列Extra看到Using index condition提示 example ","date":"2023-07-21","objectID":"/mysql/:8:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#h-icp-优化-index-condition-pushdown"},{"categories":["数据库"],"content":" I. Hash算法通过时间复杂度为O(1)来找到指定内存页。 对字典进行查找。 缓冲池的hash 表来说，池中每个page都有一个chain指针指向相同hash value的页。m应略大于2* pages # in buffer pool的质数 K = 表空间space_id « 20 + offset+space_id k%m 自适应哈希索引是数据库自身创建并且使用的，dba不能干预。 ","date":"2023-07-21","objectID":"/mysql/:9:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#i-hash算法"},{"categories":["数据库"],"content":" J. 全文检索 1.2.x倒排索引（inverted index） 它在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关联数组实现，其拥有两种表现形式： ❑inverted file index，其表现形式为{单词，单词所在文档的ID} ❑full inverted index，MySQL，其表现形式为{单词，(单词所在文档的ID，在具体文档中的位置)} 事务提交-\u003e分词写入FTS Index Cache（红黑树）-\u003e类似插入缓冲原理，到Auxiliary Table 如果宕机，下次全文检索的时候重新读取文档，分词 删除时候，只删除chach记录，不删除磁盘记录。将删除记录的FTS Document ID存在DELETED auxiliary table OPTIMIZE TABLE 会优化很多，比如cardinality统计 “mysql＞SET GLOBAL innodb_optimize_fulltext_only=1; mysql＞OPTIMIZE TABLEfts_a;” ","date":"2023-07-21","objectID":"/mysql/:10:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#j-全文检索-12x"},{"categories":["数据库"],"content":" 六、锁｜重点表锁行锁 LRU锁-\u003e线程锁｜主键ID自增-\u003e共享资源，上锁 latch，针对线程，时间短，分为mutex（互斥量）和rwlock（读写锁），无死锁检测 lock，对表，行，数据，有死锁检测 ","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#六锁重点"},{"categories":["数据库"],"content":" Innodb存储引擎中的锁行级锁： ❑共享锁（S Lock），允许事务读一行数据。 ❑排他锁（X Lock），允许事务删除或更新一行数据。 意向锁，表级锁，先意向锁，再行级锁。不会阻塞除全表扫描意外的任何请求 意义：当select * from table, 确保所有的行都没有被加x锁，但是为了快速确定，是否存在行级锁，可以直接查看IX lock 多粒度锁定，支持行级锁和表级锁同时存在。 在INFORMATION_SCHEMA架构下添加了表INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS ","date":"2023-07-21","objectID":"/mysql/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#innodb存储引擎中的锁"},{"categories":["数据库"],"content":" MVCC为什么？并发 非锁定读：读快照，即从undo日志完成。 在事务隔离级别READ COMMITTED和REPEATABLE READ（InnoDB存储引擎的默认事务隔离级别）下，InnoDB存储引擎使用非锁定的一致性读。然而，对于快照数据的定义却不相同。在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。 锁定读 ❑SELECT…FOR UPDATE ❑SELECT…LOCK IN SHARE MODE ","date":"2023-07-21","objectID":"/mysql/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#mvcc"},{"categories":["数据库"],"content":" 自增长与锁https://www.cnblogs.com/mengxinJ/p/14352038.html#_label1 AUTO-INC Locking，表锁机制，完成自增长value插入释放。 5.1.22提供latch，提供轻量级互斥量mutex，提高性能 innodb_autoinc_lock_mode： 0-\u003e AUTO-INC Locking 1-\u003e simple insert 则0， bulk insert（知道插入数量） 则用mutex，对内存中的计数器做累加操作，使用statement-based 复制。 2-\u003e 只用互斥量mutex，但是可能产生不连续的情况，，主从复制过程中出现id不一致，所以要使用row-based 复制 ","date":"2023-07-21","objectID":"/mysql/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#自增长与锁"},{"categories":["数据库"],"content":" 锁算法InnoDB存储引擎有3种行锁的算法，其分别是： ❑Record Lock：单个行记录上的锁 ❑Gap Lock：间隙锁，锁定一个范围，但不包含记录本身 ❑Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。其设计的目的是为了支持一些不需要使用幻读和不可重复读的场景。 Next-Key Lock-\u003erecord lock,索引value唯一的时候进行降级 example ","date":"2023-07-21","objectID":"/mysql/:4:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#锁算法"},{"categories":["数据库"],"content":" 四种读","date":"2023-07-21","objectID":"/mysql/:5:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#四种读"},{"categories":["数据库"],"content":" 脏读只在读未提交下，读到了未提交的数据。 ","date":"2023-07-21","objectID":"/mysql/:5:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#脏读"},{"categories":["数据库"],"content":" 幻读只在读提交，读到了新的tuple，结果数量不一致。 可以接受 Innodb 中通过next key lock来解决 ","date":"2023-07-21","objectID":"/mysql/:5:2","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#幻读"},{"categories":["数据库"],"content":" 不可重复读只在读提交，读到了新的colum，结果value不一致。 可以接受 Innodb 中通过next key lock来解决 ","date":"2023-07-21","objectID":"/mysql/:5:3","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#不可重复读"},{"categories":["数据库"],"content":" 死锁两种机制检测： 超时检测 时间过长则导致死锁存在时间较长，但是判断精准 时间短则死锁存在时间短，但是可能错杀。 timeout本身也是有等待的 且要考虑 The cost of aborting a transaction o All updates must be undone (recall the “A” in ACID) How long a transaction has been running? How long it will take a transaction to finish? How many deadlocks will be resolved if a particular transaction is aborted o Is the transaction in more than one cycle? How many times this transaction was already aborted due to deadlocks? innodb_lock_wait_timeout用来控制等待的时间（默认是50秒），innodb_rollback_on_timeout用来设定是否在等待超时时对进行中的事务进行回滚操作（默认是OFF 死锁检测： WFG 锁信息链表 事务等待链表 检测到后，选择回滚undo量最小的事务。 ","date":"2023-07-21","objectID":"/mysql/:6:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#死锁"},{"categories":["数据库"],"content":" 七、事务｜重点事务特性ACID redo log称为重做日志，用来保证事务的原子性和持久性。 undo log用来保证事务的一致性。（还有mvcc和回滚） 锁用来保证事物的隔离性。 ","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#七事务重点"},{"categories":["数据库"],"content":" A. redo log与bin logredo重做 innodb，redo log buffer + redo log file 通过force log at commit， 事务提交前保证刷入磁盘（顺序写，无序读，fsync操作）-\u003e事务提交 innodb_flush_log_at_trx_commit，默认1，fsync per commit 0-\u003emaster thread 的每秒操作 2-\u003e仅写入文件系统的缓存，不调用fsync。dbs宕机，os不宕机，则可以恢复。 可以批量提交减少fsync次数 redo innodb|bin log MySQL上层 redo log 物理页信息， binlog，POINT-IN-TIME恢复，主从复制 redo log 物理页变化，对页的修改｜事务进行中不断的被写入 binlog 逻辑日志，sql|提交后写入 ","date":"2023-07-21","objectID":"/mysql/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#a-redo-log与bin-log"},{"categories":["数据库"],"content":" B. redo log 结构log block 512bytes per block 磁盘扇区大小 512 bytes 原子写，不需要double write log block header 12bytes log body 492bytes log block tailer 8bytes log buffer管理log block， InnoDB 1.2版本之前，重做日志文件的总大小要小于4GB（不能等于4GB） InnoDB 1.2版本开始重做日志文件总大小的限制提高为了512GB。 重做日志格式 LSN LSN，写入日志的字节数，标记了重做日志写入总量，checkpoint位置，页的版本。 恢复 无论是否正常，都尝试进行恢复。因为是物理日志，所以比binlog快。以及顺序读和并行重做。从checkpoint后开始恢复 ","date":"2023-07-21","objectID":"/mysql/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#b-redo-log-结构"},{"categories":["数据库"],"content":" C. undo log回滚/MVCC 请求回滚 OR 事务失败 purge thread redo存放在重做日志文件中，与redo不同，undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment）。undo段位于共享表空间内。 逻辑日志。没办法物理日志，因为页的其他内容发生了变化。 增删改：undo log与redo log同时产生，回滚了之后，rodo log 也要记录回滚 ","date":"2023-07-21","objectID":"/mysql/:3:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#c-undo-log"},{"categories":["数据库"],"content":" D. undo log 结构InnoDB存储引擎有rollback segment，每个回滚段种记录了1024个undo log segment，而在每个undo log segment段中进行undo页的申请。 undo log结构在InnoDB存储引擎中，undo log分为： ❑insert undo log 指在insert操作中产生的undo log。 ❑update undo log 记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。 ","date":"2023-07-21","objectID":"/mysql/:4:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#d-undo-log-结构"},{"categories":["数据库"],"content":" E. Purge用于最终完成update 和delete操作 因为支持mvcc，所以如果删除了一个数据，则对于快照版本不复存在。 至于是否可以删除则通过Purge删除，如果没有被其他事物引用，则删除。 InnoDB存储引擎有一个history列表，它根据事务提交的顺序，将undo log进行链接 通过检索需要删除的undo log 的所在页的其他内容，可以减少IO次数 ","date":"2023-07-21","objectID":"/mysql/:5:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#e-purge"},{"categories":["数据库"],"content":" F. Group commit不同于批量提交，一次提交100个插入记录，通过用户语言。 而group commit是指一次fsync刷新确保多个事务被刷新 InnoDB存储引擎来说，事务提交时会进行两个阶段的操作： 1）修改内存中事务对应的信息，并且将日志写入重做日志缓冲。 2）调用fsync将确保日志都从重做日志缓冲写入磁盘。 1.2之前，开启binlog后group commit失效 1）当事务提交时InnoDB存储引擎进行prepare操作。 2）MySQL数据库上层写入二进制日志。（当前可以确保事务提交） 3）InnoDB存储引擎层将日志写入重做日志文件。 ​ a）修改内存中事务对应的信息，并且将日志写入重做日志缓冲。 ​ b）调用fsync将确保日志都从重做日志缓冲写入磁盘。 MySQL数据库内部使用了prepare_commit_mutex这个锁。但是在启用这个锁之后，步骤3）a）步不可以在其他事务执行步骤b）时进行，从而导致了group commit失效。 换而言之，Group commit只针对redo log，而binlog没有group commit 5.6 BLGC（bin log GC） 在MySQL数据库上层进行提交时首先按顺序将其放入一个队列中，队列中的第一个事务称为leader，其他事务称为follower，leader控制着follower的行为。 ❑Flush阶段，将每个事务的二进制日志写入内存中。 ❑Sync阶段，将内存中的二进制日志刷新到磁盘，若队列中有多个事务，那么仅一次fsync操作就完成了二进制日志的写入，这就是BLGC。 ❑Commit阶段，leader根据顺序调用存储引擎层事务的提交，InnoDB存储引擎本就支持group commit，因此修复了原先由于锁prepare_commit_mutex导致group commit失效的问题。 ","date":"2023-07-21","objectID":"/mysql/:6:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#f-group-commit"},{"categories":["数据库"],"content":" G. 事务的隔离级别SQL标准定义的四个隔离级别为： ❑READ UNCOMMITTED ❑READ COMMITTED ❑REPEATABLE READ ❑SERIALIZABLE 隔离级别越低，事务请求的锁越少或保持锁的时间就越短。 ❑在SERIALIABLE的事务隔离级别，InnoDB存储引擎会对每个SELECT语句后自动加上LOCK IN SHARE MODE，即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。 ❑InnoDB存储引擎默认支持的隔离级别是REPEATABLE READ，但是与标准SQL不同的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock锁的算法，读事务开始前的版本 ❑在READ COMMITTED的事务隔离级别下，除了唯一性的约束检查及外键约束的检查需要gap lock，InnoDB存储引擎不会使用gap lock的锁算法。MVCC 控制读取最新版本快照 ","date":"2023-07-21","objectID":"/mysql/:7:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#g-事务的隔离级别"},{"categories":["数据库"],"content":" H. 分布式事务分布式事就是要在分布式系统中实现事务，InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。 分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高。 XA事务 一个或多个资源管理器（Resource Managers） 一个事务管理器（Transaction Manager） 一个应用程序（Application Program）组成。 ❑资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。 ❑事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。 ❑应用程序：定义事务的边界，指定全局事务中的操作。在MySQL数据库的分布式事务中，资源管理器就是MySQL数据库，事务管理器为连接MySQL服务器的客户端。 2PC使用两段式提交（two-phase commit）的方式。 在第一阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器它们准备好提交了。 在第二阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。 TCC TCC 是 Try、Confirm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理 Try、确认 Confirm、撤销 Cancel。Try 操作做业务检查及资源预留，Confirm 做业务确认操作，Cancel 实现一个与 Try 相反的操作即回滚操作。 ","date":"2023-07-21","objectID":"/mysql/:8:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#h-分布式事务"},{"categories":["数据库"],"content":" I. 内部事务最为常见的内部XA事务存在于binlog与InnoDB存储引擎之间。由于复制的需要，因此目前绝大多数的数据库都开启了binlog功能。在事务提交时，先写二进制日志，再写InnoDB存储引擎的重做日志。对上述两个操作的要求也是原子的，即二进制日志和重做日志必须同时写入。若二进制日志先写了，而在写入InnoDB存储引擎时发生了宕机，那么slave可能会接收到master传过去的二进制日志并执行，最终导致了主从不一致的情况。 为了解决这个问题，MySQL数据库在binlog与InnoDB存储引擎之间采用XA事务。当事务提交时，InnoDB存储引擎会先做一个PREPARE操作，将事务的xid写入，接着进行二进制日志的写入。如果在InnoDB存储引擎提交前，MySQL数据库宕机了，那么MySQL数据库在重启后会先检查准备的UXID事务是否已经提交，若没有，则在存储引擎层再进行一次提交操作。 ","date":"2023-07-21","objectID":"/mysql/:9:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#i-内部事务"},{"categories":["数据库"],"content":" 八、数据备份备份方法划分 热备份 数据库运行中直接备份， ibbackup，官方提供。 1）记录备份开始时，InnoDB存储引擎重做日志文件检查点的LSN。 2）复制共享表空间文件以及独立表空间文件。 3）记录复制完表空间文件后，InnoDB存储引擎重做日志文件检查点的LSN。 4）复制在备份时产生的重做日志。 优点： ❑在线备份，不阻塞任何的SQL语句。 ❑备份性能好，备份的实质是复制数据库文件和重做日志文件。 ❑支持压缩备份，通过选项，可以支持不同级别的压缩。 ❑跨平台支持，ibbackup可以运行在Linux、Windows以及主流的UNIX系统平台上。 ibbackup对InnoDB存储引擎表的恢复步骤为： ❑恢复表空间文件。 ❑应用重做日志文件。 ibbackup提供了一种高性能的热备方式，是InnoDB存储引擎备份的首选方式。不过它是收费软件，并非免费的软件。 xtrabackup MySQL数据库本身提供的工具并不支持真正的增量备份，更准确地说，二进制日志的恢复应该是point-in-time的恢复而不是增量备份。而XtraBackup工具支持对于InnoDB存储引擎的增量备份，其工作原理如下：1）首选完成一个全备，并记录下此时检查点的LSN。2）在进行增量备份时，比较表空间中每个页的LSN是否大于上次备份时的LSN，如果是，则备份该页，同时记录当前检查点的LSN。 冷备份 数据库停止的情况下，复制物理文件即可 温备份 加读锁进行备份 备份MySQL数据库的frm文件，共享表空间文件，独立表空间文件（*.ibd），重做日志文件。另外建议定期备份MySQL数据库的配置文件my.cnf，这样有利于恢复的操作。 冷备的优点是： ❑备份简单，只要复制相关文件即可。 ❑备份文件易于在不同操作系统，不同MySQL版本上进行恢复。 ❑恢复相当简单，只需要把文件恢复到指定位置即可。 ❑恢复速度快，不需要执行任何SQL语句，也不需要重建索引。 冷备的缺点是： ❑InnoDB存储引擎冷备的文件通常比逻辑文件大很多，因为表空间中存放着很多其他的数据，如undo段，插入缓冲等信息。 ❑冷备也不总是可以轻易地跨平台。操作系统、MySQL的版本、文件大小写敏感和浮点数格式都会成为问题。 备份内容 逻辑备份 备份文件可读，一般由sql语句组成或者是表内实际数据组成 裸文件备份（热备份）直接复制物理文件，即可在运行中复制，也可以在停止时复制（用ibbackup、xtrabackup）。恢复时间比逻辑备份短 mysqldumpmysqldump的语法如下： shell＞mysqldump[arguments]＞fle_name如果想要备份所有的数据库，可以使用--all-databases选项：shell＞mysqldump--all-databases＞dump.sql如果想要备份指定的数据库，可以使用--databases选项:shell＞mysqldump--databases db1 db2 db3＞dump.sql2. SELECT...INTO OUTFILESELECT...INTO语句也是一种逻辑备份的方法，更准确地说是导出一张表中的数据。SELECT...INTO的语法如下：SELECT[column 1],[column 2]...INTOOUTFILE'file_name'[{FIELDS|COLUMNS}[TERMINATED BY'string'][[OPTIONALLY]ENCLOSED BY'char'][ESCAPED BY'char']][LINES[STARTING BY'string'][TERMINATED BY'string']]FROM TABLE WHERE...... 数据库内容 完全备份 增量备份 日志备份 ","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#八数据备份"},{"categories":["数据库"],"content":" MySQL主从同步","date":"2023-07-21","objectID":"/mysql/:1:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#mysql主从同步"},{"categories":["数据库"],"content":" 复制过程复制（replication）是MySQL数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用。总体来说，replication的工作原理分为以下3个步骤： 1）主服务器（master）把数据更改记录到二进制日志（binlog）中。 2）从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。 3）从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。 复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原。从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，复制执行中继日志。 ![image-20221128153702815](/Users/shengquan/Library/Application Support/typora-user-images/image-20221128153702815.png) ","date":"2023-07-21","objectID":"/mysql/:2:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#复制过程"},{"categories":["数据库"],"content":" 九、性能调优｜重点上游调优：添加代理层，数据库连接池，如hikari druid c3p0 dbcp jdbc 单表调优。 索引特性，存储结构，什么情况下使用，cardinility，使用explain，（extre可以展示MRR） 一个页至少放2条，高度， 多插入的调优。（批量插入；id自增； group commit） 多查询调优。索引，explain（），B+树（覆盖索引特性多理解，回表），严格约束字段的长度，能用数字就用数字，尤其是tinyint。（男女，0,1）（like，join）尽量用timestamp不要用data 不用*，无法避免走primary index，一定要用的话，用5.6，提供离散读和icp 覆盖索引， 查看执行计划 分区 ，更快的查询速度。 拆分表（水平拆分 ，需要带id进行查询、 垂直拆分=减少单表的字段量，单独业务查询） 版本调优 MRR（5.5-\u003e5.6，需要开启） ICP 服务器层面调优 测试（非压测环境，非预生产环境）环境开启慢查询日志。进行日常 、 上线前的测试。分析慢查询sql。 CPU / 磁盘 / 内存 / RAID 分布式调优 通过外置中间件调优 缓存（减少访问） 、 queue（削峰）、分布式、读写分离 表设计-\u003e内存页大小相关-\u003eb+树 索引设计 分区1024个分区和拆分。 拆分到不同的服务器，一致性hash。一个查询要多个mysql。用哪一个key来避免查询多个数据库。 时间判断：set profiling = 1; show profiles show profile for query #； show processlist ","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#九性能调优重点"},{"categories":["数据库"],"content":" SQL调优（单机）这是最常用、每一个技术人员都应该掌握基本的SQL调优手段（包括方法、工具、辅助系统等）。这里以MySQL为例，最常见的方式是，由自带的慢查询日志或者开源的慢查询系统定位到具体的出问题的SQL，然后使用explain、profile等工具来逐步调优，最后经过测试达到效果后上线。这方面的细节，可以参考MySQL索引原理及慢查询优化。 ","date":"2023-07-21","objectID":"/mysql/:0:1","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#sql调优单机"},{"categories":["数据库"],"content":" 架构层面的调优（分布式）这一类调优包括读写分离、多从库负载均衡、水平和垂直分库分表等方面，一般需要的改动较大，但是频率没有SQL调优高，而且一般需要DBA来配合参与。那么什么时候需要做这些事情？我们可以通过内部监控报警系统（比如Zabbix），定期跟踪一些指标数据是否达到瓶颈，一旦达到瓶颈或者警戒值，就需要考虑这些事情。通常，DBA也会定期监控这些指标值。 ","date":"2023-07-21","objectID":"/mysql/:0:3","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#架构层面的调优分布式"},{"categories":["数据库"],"content":" 连接池调优我们的应用为了实现数据库连接的高效获取、对数据库连接的限流等目的，通常会采用连接池类的方案，即每一个应用节点都管理了一个到各个数据库的连接池。随着业务访问量或者数据量的增长，原有的连接池参数可能不能很好地满足需求，这个时候就需要结合当前使用连接池的原理、具体的连接池监控数据和当前的业务量作一个综合的判断，通过反复的几次调试得到最终的调优参数。 如何保证事务结束后，对数据的修改永久的保存？ 方案1.事务提交前页面写盘 方案2. wal 如果存在内存上是可以用btree的，PMEM，断电保存 druid ","date":"2023-07-21","objectID":"/mysql/:0:5","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#连接池调优"},{"categories":["数据库"],"content":" 十、链接资源基于代价的慢查询优化建议 Disadvantages of MMAP: Not all operating systems support it (ahem Windows) Coarse locking. It’s difficult to allow many clients to make concurrent access to the file. Relying on the OS to buffer I/O writes leads to increased risk of data loss if the RDBMS engine crashes. Need to use a journaling filesystem, which may not be supported on all operating systems. Can only map a file size up to the size of the virtual memory address space, so on 32-bit OS, the database files are limited to 4GB (per comment from Roger Lipscombe above). Early versions of MongoDB tried to use MMAP in the primary storage engine (the only storage engine in the earliest MongoDB). Since then, they have introduced other storage engines, notably WiredTiger. This has greater support for tuning, better performance on multicore systems, support for encryption and compression, multi-document transactions, and so on. ","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#十链接资源"},{"categories":["数据库"],"content":" 十一、SQL题目group by class having count(student) \u003e= 5 ","date":"2023-07-21","objectID":"/mysql/:0:0","series":["学习笔记"],"tags":["面试"],"title":"Mysql","uri":"/mysql/#十一sql题目"},{"categories":["开源工作"],"content":" 模版项目申请书分为三个部分，技术方案、时间规划、项目经历 技术方案 1.请记住，技术方案越详细越有利于项目导师的理解和认可 ; 2.在技术方案中，学生应该重点展示出自己对开源项目的理解程度，可以从以下几点入手:根据自己的理解和前期项目学习储备来拆解目标开源项目，尽可能描述各个模块的功能:重点对项目发布的任务或需求进行分析，体现自己的思考和思路;具体描述自己的技术方案，比如自己的方案将会添加哪些模块，以及这些模块如何与现有模块通信 3.最好能为自己的方案找到一些可执行的依据，包括但不限于 :其他项目的成功经验; 论文等提供的理论依据 ","date":"2023-07-12","objectID":"/inlong/:0:0","series":["开源初探"],"tags":["开源","大数据","数据集成"],"title":"Inlong","uri":"/inlong/#模版"},{"categories":["开源工作"],"content":" Inlong一站式数据集成框架，将不同数据源的数据汇集（批量集成和实时集成）到目标端。 ","date":"2023-07-12","objectID":"/inlong/:0:0","series":["开源初探"],"tags":["开源","大数据","数据集成"],"title":"Inlong","uri":"/inlong/#inlong"},{"categories":["开源工作"],"content":" 架构![image-20230713005256473](/Users/shengquan/Library/Application Support/typora-user-images/image-20230713005256473.png) 数据链路 采集层：从各个数据源采集对应的数据，Agent 汇聚层：接收采集层的数据进行统一编码，做协议转换，大量的链接进行收敛，将采集层的数据进行统一处理，并且上报给缓存层，DataProxy 缓存层：MQ服务，支持TubeMQ，Pulsar，Kafka 分拣层：Sort on Flink，通过业务配置的流向，分拣到具体的服务当中；Sort standalone，非Flink版本； 需要自定义消费逻辑的时候，使用SDK进行消费；对接自己的离线/实时计算。 ","date":"2023-07-12","objectID":"/inlong/:1:0","series":["开源初探"],"tags":["开源","大数据","数据集成"],"title":"Inlong","uri":"/inlong/#架构"},{"categories":["开源工作"],"content":" 组件![image-20230713010058964](/Users/shengquan/Library/Application Support/typora-user-images/image-20230713010058964.png) ","date":"2023-07-12","objectID":"/inlong/:2:0","series":["开源初探"],"tags":["开源","大数据","数据集成"],"title":"Inlong","uri":"/inlong/#组件"},{"categories":["开源工作"],"content":" Demo![image-20230713010729918](/Users/shengquan/Library/Application Support/typora-user-images/image-20230713010729918.png) ","date":"2023-07-12","objectID":"/inlong/:3:0","series":["开源初探"],"tags":["开源","大数据","数据集成"],"title":"Inlong","uri":"/inlong/#demo"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List\u003cString\u003e generateParenthesis(int n) { List\u003cString\u003e res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List\u003cString\u003e res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable\u003cStatus\u003e { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue\u003cStatus\u003e queue = new PriorityQueue\u003cStatus\u003e(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#1-两数之和httpsleetcodecnproblemstwo-sum"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#2-两数相加httpsleetcodecnproblemsadd-two-numbers"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#3-无重复字符的最长子串httpsleetcodecnproblemslongest-substring-without-repeating-characters"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#4-寻找两个正序数组的中位数httpsleetcodecnproblemsmedian-of-two-sorted-arrays"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#5-最长回文子串httpsleetcodecnproblemslongest-palindromic-substring"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#10-正则表达式匹配httpsleetcodecnproblemsregular-expression-matching"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#11-盛最多水的容器httpsleetcodecnproblemscontainer-with-most-water"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#15-三数之和httpsleetcodecnproblems3sum"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#17-电话号码的字母组合httpsleetcodecnproblemsletter-combinations-of-a-phone-number"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#19-删除链表的倒数第-n-个结点httpsleetcodecnproblemsremove-nth-node-from-end-of-list"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#20-有效的括号httpsleetcodecnproblemsvalid-parentheses"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#21-合并两个有序链表httpsleetcodecnproblemsmerge-two-sorted-lists"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#22-括号生成httpsleetcodecnproblemsgenerate-parentheses"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#23-合并-k-个升序链表httpsleetcodecnproblemsmerge-k-sorted-lists"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#31-下一个排列httpsleetcodecnproblemsnext-permutation"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#32-最长有效括号httpsleetcodecnproblemslongest-valid-parentheses"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#33-搜索旋转排序数组httpsleetcodecnproblemssearch-in-rotated-sorted-array"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#34-在排序数组中查找元素的第一个和最后一个位置httpsleetcodecnproblemsfind-first-and-last-position-of-element-in-sorted-array"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#39-组合总和httpsleetcodecnproblemscombination-sum"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#42-接雨水httpsleetcodecnproblemstrapping-rain-water"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#46-全排列httpsleetcodecnproblemspermutations"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#48-旋转图像httpsleetcodecnproblemsrotate-image"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#49-字母异位词分组httpsleetcodecnproblemsgroup-anagrams"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#53-最大子数组和httpsleetcodecnproblemsmaximum-subarray"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#55-跳跃游戏httpsleetcodecnproblemsjump-game"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#56-合并区间httpsleetcodecnproblemsmerge-intervals"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#62-不同路径httpsleetcodecnproblemsunique-paths"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#64-最小路径和httpsleetcodecnproblemsminimum-path-sum"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#70-爬楼梯httpsleetcodecnproblemsclimbing-stairs"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#72-编辑距离httpsleetcodecnproblemsedit-distance"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#75-颜色分类httpsleetcodecnproblemssort-colors"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#76-最小覆盖子串httpsleetcodecnproblemsminimum-window-substring"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#78-子集httpsleetcodecnproblemssubsets"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#79-单词搜索httpsleetcodecnproblemsword-search"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#84-柱状图中最大的矩形httpsleetcodecnproblemslargest-rectangle-in-histogram"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#85-最大矩形httpsleetcodecnproblemsmaximal-rectangle"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#94-二叉树的中序遍历httpsleetcodecnproblemsbinary-tree-inorder-traversal"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#96-不同的二叉搜索树httpsleetcodecnproblemsunique-binary-search-trees"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#98-验证二叉搜索树httpsleetcodecnproblemsvalidate-binary-search-tree"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#101-对称二叉树httpsleetcodecnproblemssymmetric-tree"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#102-二叉树的层序遍历httpsleetcodecnproblemsbinary-tree-level-order-traversal"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#104-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#105-从前序与中序遍历序列构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#114-二叉树展开为链表httpsleetcodecnproblemsflatten-binary-tree-to-linked-list"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#136-只出现一次的数字httpsleetcodecnproblemssingle-number"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#121-买卖股票的最佳时机httpsleetcodecnproblemsbest-time-to-buy-and-sell-stock"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#124-二叉树中的最大路径和httpsleetcodecnproblemsbinary-tree-maximum-path-sum"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#128-最长连续序列httpsleetcodecnproblemslongest-consecutive-sequence"},{"categories":["数据结构与算法"],"content":"本系列题库链接 1. 两数之和思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1). 思路2. 使用HashMap保存访问过的数字。 2. 两数相加思路1. 用一个variable保存进位结果，在一个循环内完成 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int temp = 0; ListNode head = new ListNode(0); ListNode cursor = head; while (l1 != null || l2 != null || temp != 0) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int position = l1Val + l2Val + temp; temp = position / 10; position %= 10; ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0); ln.val = position; cursor.next = ln; cursor = cursor.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return head.next; } } 3. 无重复字符的最长子串思路1. 使用一个HashMap保存出现过的字符，然后使用双指针 4. 寻找两个正序数组的中位数思路1. 当在一个较小的数组m中选一个假定的中位数位分割线，那么在长的数组n中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] \u003c= n[j + 1] \u0026\u0026 n [j] \u003c= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。 5. 最长回文子串思路1. 双指针扩散，一次是基数一次是偶数。 10. 正则表达式匹配思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个’*‘多匹配，都是一个分叉点。 public class Solution { public boolean isMatch(String s, String p) { return isMatch(s, s.length(), p, p.length()); } private boolean isMatch(String s, int i, String p, int j) { if (j == 0) { return i == 0; } if (i == 0) { if (j \u003e 1 \u0026\u0026 p.charAt(j - 1) == '*') { return isMatch(s, i, p, j - 2); } else { return false; } } if (p.charAt(j - 1) == '*') { if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') { return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2); } else { return isMatch(s, i, p, j - 2); } } if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') { return isMatch(s, i - 1, p, j - 1); } return false; } } 思路2. 正经思路，动态规划。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 11. 盛最多水的容器思路1. 双指针，从两侧向中间逼近。 15. 三数之和思路1. 排序+双指针 17. 电话号码的字母组合思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先 19. 删除链表的倒数第 N 个结点思路1. 双指针，快指针走N步，再走慢指针 20. 有效的括号思路1. 建立括号配对，使用栈 21. 合并两个有序链表思路1. 递归或者迭代。 22. 括号生成思路1. 先生成，再检测 思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。 import java.util.ArrayList; import java.util.List; public class Solution { // 做减法 public List generateParenthesis(int n) { List res = new ArrayList\u003c\u003e(); // 特判 if (n == 0) { return res; } // 执行深度优先遍历，搜索可能的结果 dfs(\"\", n, n, res); return res; } /** * @param curStr 当前递归得到的结果 * @param left 左括号还有几个可以使用 * @param right 右括号还有几个可以使用 * @param res 结果集 */ private void dfs(String curStr, int left, int right, List res) { // 因为每一次尝试，都使用新的字符串变量，所以无需回溯 // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分 if (left == 0 \u0026\u0026 right == 0) { res.add(curStr); return; } // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节） if (left \u003e right) { return; } if (left \u003e 0) { dfs(curStr + \"(\", left - 1, right, res); } if (right \u003e 0) { dfs(curStr + \")\", left, right - 1, res); } } } 23. 合并 K 个升序链表思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java // 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll class Solution { class Status implements Comparable { int val; ListNode ptr; Status(int val, ListNode ptr) { this.val = val; this.ptr = ptr; } public int compareTo(Status status2) { return this.val - status2.val; } } PriorityQueue queue = new PriorityQueue(); public ListNode mergeKLists(ListNode[] lists) { for (List","date":"2023-07-11","objectID":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/:0:0","series":["学习笔记"],"tags":["数据结构与算法","leetcode"],"title":"LeetCode 热题 HOT 100","uri":"/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/#136-只出现一次的数字httpsleetcodecnproblemssingle-number-1"},{"categories":null,"content":"1、进群请先将群昵称修改为: 微信昵称_github id_姓名(可选)_公司名称(可选) 这种的，方便后面跟踪 Issues 和 PR 2、以下相关贡献资料供大家参考：2.1 首次贡献可以从这里开始: https://github.com/apache/seatunnel/contribute 找到感兴趣的 issue，参考 https://github.com/apache/seatunnel/issues/2828 完成第一次贡献。首次贡献的伙伴了解贡献流程即可，不建议提交大 PR 参考新手教程https://mp.weixin.qq.com/s/evYRsrpPb-MXEm4DqLdnvQ【SeaTunnel 连接器极简开发流程】https://mp.weixin.qq.com/s/8ivksAePmVZe2_2ldGi0AA 【新 API Connector 开发解析】https://mp.weixin.qq.com/s/qpO2SVRl9KAY-Ib2kaTDig 【Source 与 Sink API 设计解析】 2.2 寻找你感兴趣的 Issueshttps://github.com/apache/seatunnel/issues/3018 Connector ToDo 追踪列表https://github.com/apache/seatunnel/issues?q=is:open+is:issue+label:“help+wanted” 2.3 参考贡献指南https://seatunnel.apache.org/docs/contribution/setup 【搭建本地开发环境指南】https://seatunnel.apache.org/docs/contribution/coding-guide【代码贡献指南】 3、欢迎加入 Slack 沟通交流群: https://s.apache.org/seatunnel-slack 4、关注社区公众号：SeaTunnel 和 Twitter: https://twitter.com/ASFSeaTunnel 5、欢迎订阅社区开发邮件列表: dev-subscribe@seatunnel.apache.org ，重要的事情请请在邮件里讨论 6、欢迎关注社区 B 站: https://space.bilibili.com/1542095008 参与社区有非常多的方式，包括文档、翻译、布道、答疑、测试、以及代码等，此外也极其欢迎各种实践文章，文章内容包含不限于： 部署，原理，使用经验分享，源码分析等等。 seatunnel streampark kvrocks opendal https://github.com/oraeorae/GoDouYin https://github.com/lluckyboi/SimpleDouYin 涉及分布式问题，用mq 一个接口进行压测 限流、熔断 找一个项目，一个模块，想清楚各种场景 分库分表 秒杀 集成oetl进行可观测性 微服务 链路追踪 限流 日志组件 索引 缓存 加密 分布式一致性 功能测试 MQ提升性能和稳定性 使用zset存储关注关系，可能存在大k和数据持久化风险 事务保证数据一致性 密码加密 判断用户名重复 敏感词过滤 并发加速？ 火焰图验证性能 关注列表要有缓存加速 使用虚拟线程并发批量调用数据 对象存储 接口使用https 聊天消息使用rabbitmq 密码加盐 使用连接池 cdn加速静态资源 做压测 熔断降级 jaeger联路追踪 kafka+es日志分析 异步写入数据库 ![image-20231024124657340](/Users/shengquan/Library/Application Support/typora-user-images/image-20231024124657340.png) https://hdu-help.feishu.cn/docx/KuGidErAIogvWDxcn2VcTrfUntb ","date":"0001-01-01","objectID":"/1%E8%BF%9B%E7%BE%A4%E8%AF%B7%E5%85%88%E5%B0%86%E7%BE%A4%E6%98%B5%E7%A7%B0%E4%BF%AE%E6%94%B9%E4%B8%BA-%E5%BE%AE%E4%BF%A1%E6%98%B5%E7%A7%B0github-id%E5%A7%93%E5%90%8D%E5%8F%AF%E9%80%89_%E5%85%AC%E5%8F%B8%E5%90%8D%E7%A7%B0%E5%8F%AF%E9%80%89-%E8%BF%99%E7%A7%8D%E7%9A%84%E6%96%B9%E4%BE%BF%E5%90%8E%E9%9D%A2%E8%B7%9F%E8%B8%AA-issues-%E5%92%8C-pr/:0:0","series":null,"tags":null,"title":"","uri":"/1%E8%BF%9B%E7%BE%A4%E8%AF%B7%E5%85%88%E5%B0%86%E7%BE%A4%E6%98%B5%E7%A7%B0%E4%BF%AE%E6%94%B9%E4%B8%BA-%E5%BE%AE%E4%BF%A1%E6%98%B5%E7%A7%B0github-id%E5%A7%93%E5%90%8D%E5%8F%AF%E9%80%89_%E5%85%AC%E5%8F%B8%E5%90%8D%E7%A7%B0%E5%8F%AF%E9%80%89-%E8%BF%99%E7%A7%8D%E7%9A%84%E6%96%B9%E4%BE%BF%E5%90%8E%E9%9D%A2%E8%B7%9F%E8%B8%AA-issues-%E5%92%8C-pr/#"},{"categories":null,"content":"![image-20231027142546877](/Users/shengquan/Library/Application Support/typora-user-images/image-20231027142546877.png) ","date":"0001-01-01","objectID":"/int/:0:0","series":null,"tags":null,"title":"","uri":"/int/#"},{"categories":null,"content":" 用户登陆过程需要做哪些分析？ 功能测试 正常流程（正确账号密码，点击提交，验证能否正确登陆） 异常流程（错误的账号密码，点击提交，验证登陆失败，并提示相应错误信息） 登陆成功后能否正确跳转 用户名和密码，太短或太长的处理（边界值法） 用户名和密码，有特殊字符（比如空格）及其他非英文的情况 记住用户名，记住密码 登陆失败后，不记录密码 用户名和密码前后有空格的处理 密码是否是密文显示，使用“*”号或圆点等符号代替 验证码的辨认难度，考虑颜色（色盲使用者），刷新或换一个按钮是否好用 输入密码时，大写键盘开启时是否有提示信息 什么都不输入，点击提交按钮，检查提示信息 登陆token测试 界面测试 布局是否合理，按钮和表单是否整齐 按钮和表单高度和长度是否符合要求 界面风格是否符合UI设计稿 文字有无错别字 性能测试 打开登陆页面，需要的时间是否在需求要求的时间内 输入正确的账号密码，点击登陆，是否在需求时间内跳转成功 模拟大量用户同时登陆，检查一定压力下能否正常跳转 安全性测试 用户名或密码是否是通过加密方式，发送给后端服务器 用户名和密码应该在前端和后端做双重验证 防止CSRF攻击，是否存在token 用户名和密码的输入框，应该屏蔽SQL注入攻击 用户名和密码的输入框，应该禁止输入脚本（防止xss攻击） 防止暴力破解，检测是否有错误登陆的次数限制 是否支持多用户在同一机器上登陆 同一用户能否在多台机器上登陆 可用性测试 是否可以用全键盘操作，是否有快捷键 输入用户名，密码后按回车，是否可以登陆 输入框是否可以Tab切换 兼容性测试 不同浏览器下能否显示正常，且功能正常（IE,6,7,8,9,10,11,Firefox,Chrome,Safari）等 同种浏览器下不同版本能否显示正常且功能正常 不同的操作系统是否能正常工作（Windows, Mac） 移动设备上是否正常工作（iOS，Android） 本地化测试 不同语言环境下，页面的显示是否正确 120 600/m 9.30-6.30 2h 9.30， free宵夜+打车 200 ","date":"0001-01-01","objectID":"/int/:1:0","series":null,"tags":null,"title":"","uri":"/int/#用户登陆过程需要做哪些分析"},{"categories":null,"content":" 测试用例设计","date":"0001-01-01","objectID":"/int/:0:0","series":null,"tags":null,"title":"","uri":"/int/#测试用例设计"},{"categories":null,"content":" 测试用例的格式普遍是 Excel 或 Xmind。 Excel 优势是比较细化，可以突出更多的测试要素，适用于等价划分类等黑盒测试设计思路，也适用于输入输出的场景；缺点是结构化不直观，不好体现功能需求，用例数过于臃肿。 Xmind 优势是大部分只需要列出测试点，更加注重探索性测试，能够更好的去描述功能需求，结构化展示比较直观，比较契合产品PRD；缺点是不太适用于输入输出的场景，测试细节不好表达。 ","date":"0001-01-01","objectID":"/int/:0:1","series":null,"tags":null,"title":"","uri":"/int/#测试用例的格式"},{"categories":null,"content":" 测试用例优先级 高（优先执行）：产品基本的功能验证，即关键路径的测试用例，包括最常执行的功能、基本流程的输入（正向流程+正向数据）。 中（次级执行）：包括界面数据有效性校验、默认值、边界值。 低（最后执行）：建议执行的测试用例，包括不常执行的功能、异常流程的输入以及异常数据的输入。 ","date":"0001-01-01","objectID":"/int/:0:2","series":null,"tags":null,"title":"","uri":"/int/#测试用例优先级"},{"categories":null,"content":" 测试用例要素 用例标识（id）：唯一的标识号，用以区别其他测试用例 用例标题：表达测试用例的用途 优先级：高中低 前置条件：软硬件 输入 操作步骤 预期结果 作者（选填） ","date":"0001-01-01","objectID":"/int/:0:3","series":null,"tags":null,"title":"","uri":"/int/#测试用例要素"},{"categories":null,"content":" 测试方案设计应从哪些方面去考虑？无非是从以下方面去考虑，其中，功能测试我认为是最重要的一个环节。 功能测试（最重要） 文档测试 UI测试 接口测试 性能测试（压力、负载） 安全测试 稳定性测试（Monkey、遍历测试等） 异常测试（断网/弱网） 兼容性测试（安卓、IOS系统版本以及APP新老版本） 易用性测试 可用性测试 配置测试 ","date":"0001-01-01","objectID":"/int/:0:4","series":null,"tags":null,"title":"","uri":"/int/#测试方案设计应从哪些方面去考虑"},{"categories":null,"content":" 用例设计![image-20231027141836927](/Users/shengquan/Library/Application Support/typora-user-images/image-20231027141836927.png) ","date":"0001-01-01","objectID":"/int/:0:0","series":null,"tags":null,"title":"","uri":"/int/#用例设计"},{"categories":null,"content":" 测试理论基础","date":"0001-01-01","objectID":"/int/:0:0","series":null,"tags":null,"title":"","uri":"/int/#测试理论基础"},{"categories":null,"content":" 什么是软件测试？答：软件测试是在规定的条件下对程序进行操作，以发现错误，对软件质量进行评估。 ","date":"0001-01-01","objectID":"/int/:0:1","series":null,"tags":null,"title":"","uri":"/int/#什么是软件测试"},{"categories":null,"content":" 软件测试的目的是什么？答：软件测试的目的在于（1）发现软件的缺陷和错误（2）保证软件的质量，确保能够满足用户以及产品的需求。 （标重点）软件测试的目的是为了找bug，并不是验证软件没有bug。 ","date":"0001-01-01","objectID":"/int/:0:2","series":null,"tags":null,"title":"","uri":"/int/#软件测试的目的是什么"},{"categories":null,"content":" 黑盒与白盒的定义 白盒： 白盒测试是测试人员要了解程序结构和处理过程,按照程序内部逻辑测试程序,检查程序中的每条通路是否按照预定要求正确工作.它主要的针对被测程序的源代码。 不太需要关注程序功能 黑盒： 黑盒测试又称为功能测试或数据驱动测试）是把测试对象看作一个黑盒子。利用黑盒测试法进行动态测试时，需要测试软件产品的功能，不需测试软件产品的内部结构和处理过程。 ","date":"0001-01-01","objectID":"/int/:0:3","series":null,"tags":null,"title":"","uri":"/int/#黑盒与白盒的定义"},{"categories":null,"content":" 白盒测试用例设计常用方法答： 静态测试：不用运行程序的测试，如文档测试、代码检查等 动态测试：需要执行代码，接口测试、覆盖率分析、性能分析、内存分析等。 逻辑覆盖法：主要包括语句覆盖，判断覆盖，条件覆盖，判断/条件覆盖，条件组合覆盖，路径覆盖等。 六种覆盖标准发现错误的能力由弱到强的变化： 语句覆盖，每条语句至少执行一次。 判断覆盖，每个判断的每个分支至少执行一次。 条件覆盖，每个判段的每个条件应取到的各种可能的值。 判断/条件覆盖，同时满足判断覆盖条件覆盖。 条件组合覆盖，每个判定中各条件的每一种组合至少出现一次。 路径覆盖，使程序中每一条可能的路径至少执行一次。 ","date":"0001-01-01","objectID":"/int/:0:4","series":null,"tags":null,"title":"","uri":"/int/#白盒测试用例设计常用方法"},{"categories":null,"content":" 黑盒测试用例设计常用方法答：等价划分类，边界值分析，错误推测法、判定表分析法、因果图法、正交试验设计法、场景法、功能图分析法等。 等价类：等价类是指某个输入域的子集合.在该子集合中,各个输入数据对于揭露程序 中的错误都是等效的.因此,可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件,就可以用少量代表性的测试数据.取得较好的测试结果. 等价类划分可有两种不同的情况:有效等价类和无效等价类. 边界值分析法：边界值分析方法是对等价类划分方法的补充。测试工作经验告诉我,大量的错误是发生在输入或输出范围的边界上,而不是发生在输入输出范围的内部.因此针对各种边界情况设计测试用例,可以查出更多的错误.(内点，上点，离点) 错误猜测法：基于经验和直觉推测程序中所有可能存在的各种错误,从而有针对性的设计测试用例的方法. 判定表分析法：等价类未考虑输入条件之间的联系,相互组合等.无效类每个用例只出现一次，不能覆盖多个无效等价类并存的情况。不同的组合用二进制解决。(条件桩和动作桩) 因果图法：输入之间有相互的组合关系，且输入和输出之间有相互的制约和依赖关系，是判定表的复杂版，最终生成的就是判定表，根本上等价 正交表分析法：有时候，大量的参数的组合而引起测试用例数量上的激增，同时，这些测试用例并没有明显的优先级上的差距，而测试人员又无法完成这么多数量的测试，就可以通过正交表来进行缩减一些用例，从而达到尽量少的用例覆盖尽量大的范围的可能性。(打印机) 场景法：指根据用户场景来模拟用户的操作步骤，一般借助流程图来确定基本流和备选流(淘宝下单流程)。 状态图法：针对流程分析法不跨多个界面，状态图法保证每一个功能/状态的可达项都被覆盖，但对无效的路径无法覆盖(MP3). ","date":"0001-01-01","objectID":"/int/:0:5","series":null,"tags":null,"title":"","uri":"/int/#黑盒测试用例设计常用方法"},{"categories":null,"content":" 什么是灰盒测试？答：灰盒测试，是介于白盒测试与黑盒测试之间的一种测试，灰盒测试多用于集成测试阶段。目前互联网的测试大多数都是灰盒测试。 ","date":"0001-01-01","objectID":"/int/:0:6","series":null,"tags":null,"title":"","uri":"/int/#什么是灰盒测试"},{"categories":null,"content":" 列举出你所了解的软件测试方式答： 按照软件的生命周期划分：单元测试、集成测试、系统测试、回归测试、验收测试。 按照测试关注点划分：功能测试、性能测试、稳定性测试、易用性测试、安全性测试。 按照测试实施者划分：开发方测试（α测试）、用户测试（β测试）、第三方测试。 按照技术/测试用例设计划分：白盒测试、黑盒测试、灰盒测试。 按照分析方法划分：静态测试、动态测试。 按照测试执行方式划分：手工测试、自动化测试。 按照测试对象划分：程序测试、文档测试。 ","date":"0001-01-01","objectID":"/int/:0:7","series":null,"tags":null,"title":"","uri":"/int/#列举出你所了解的软件测试方式"},{"categories":null,"content":" 什么是单元测试答：完成最小的软件设计单元（模块）的验证工作，确保模块被正确编码。通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早发现和解决不易显现的错误。 ","date":"0001-01-01","objectID":"/int/:0:8","series":null,"tags":null,"title":"","uri":"/int/#什么是单元测试"},{"categories":null,"content":" 单元测试、集成测试、系统测试、验收测试、回归测试这几步最重要的是哪一步？答：这些测试步骤分别在软件开发的不同阶段对软件进行测试，我认为对软件完整功能进行测试的系统测试很重要，因为此时单元测试和集成测试已完成，系统测试能够对软件所有功能进行功能测试，能够覆盖系统所有联合的部件，是针对整个产品系统进行的测试，能够验证系统是否满足需求规格的定义，因此，我认为系统测试很重要。 ","date":"0001-01-01","objectID":"/int/:0:9","series":null,"tags":null,"title":"","uri":"/int/#单元测试集成测试系统测试验收测试回归测试这几步最重要的是哪一步"},{"categories":null,"content":" 集成测试和系统测试的区别，以及应用场景分别是什么？答： 区别： 执行顺序：先执行集成测试，待集成测试问题修复后，再做系统测试。 用例粒度：集成测试比系统测试用例更详细，集成测试对于接口部分也要重点写，而系统测试的用例更接近用户接受的测试用例。 应用场景： 集成测试：一般包含接口测试，对程序的提测部分进行测试。测试方法一般选用黑盒测试和白盒测试相结合。 系统测试：针对整个产品的全面测试，既包含各模块的验证性测试和功能性测试，又包含对整个产品的健壮性、安全性、可维护性及各种性能参数的测试。测试方法一般采用黑盒测试法。 ","date":"0001-01-01","objectID":"/int/:0:10","series":null,"tags":null,"title":"","uri":"/int/#集成测试和系统测试的区别以及应用场景分别是什么"},{"categories":null,"content":" 测试开发需要哪些知识？具备哪些能力？答： 需要的知识： 软件测试基础理论知识，如黑盒测试、白盒测试等； 编程语言基础，如C/C++、java、python等； 自动化测试工具，如Selenium、Appium等； 计算机基础知识，如数据库、Linux、计算机网络等； 测试卡框架，如JUnit、Pytest、Unittest等。 具备的能力： 业务分析能力、缺陷洞察能力、团队协作能力、专业技术能力、逻辑思考能力、问题解决能力、沟通表达能力和宏观把控能力。 ","date":"0001-01-01","objectID":"/int/:0:11","series":null,"tags":null,"title":"","uri":"/int/#测试开发需要哪些知识具备哪些能力"},{"categories":null,"content":" 请说一下手动测试与自动化测试的优缺点答： 手工测试缺点： 重复的手工回归测试，代价昂贵、容易出错。 依赖于软件测试人员的能力。 手工测试的优点： 测试人员具有经验和对错误的猜测能力。 测试人员具有审美能力和心理体验。 测试人员具有是非判断和逻辑推理能力。 自动化测试的缺点： 不能取代手工测试。 无法运用在测试复杂的场景 手工测试比自动化测试发现的缺陷更多。 对测试质量的依赖性极大。 自动化测试不能提高有效性。 比手动测试脆弱，需要维护成本。 工具本身并无想象力。 自动化测试的优点： 对程序的回归测试更方便。 可以运行更多更繁琐的测试。 可以执行一些手工测试困难或不可能进行的测试。 更好地利用资源。 测试具有一致性和可重复性。 测试的复用性。 增加软件的信任度。 ","date":"0001-01-01","objectID":"/int/:0:12","series":null,"tags":null,"title":"","uri":"/int/#请说一下手动测试与自动化测试的优缺点"},{"categories":null,"content":" 自动化测试的定义 前提条件 适用的测试类型答： 定义： 自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。通常，在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。 前提条件： 实施自动化测试之前需要对软件开发过程进行分析，以观察其是否适合使用自动化测试。通常需要同时满足以下条件： 适用的测试类型： 回答一： 回答二： ","date":"0001-01-01","objectID":"/int/:0:13","series":null,"tags":null,"title":"","uri":"/int/#自动化测试的定义-前提条件-适用的测试类型"},{"categories":null,"content":" 自动化测试的运用场景举例答： 线上巡检（UI+接口） 简单场景监控 稳定性测试（monkey+遍历测试） ","date":"0001-01-01","objectID":"/int/:0:14","series":null,"tags":null,"title":"","uri":"/int/#自动化测试的运用场景举例"},{"categories":null,"content":" 软件测试的核心竞争力是什么？答：早发现问题和发现别人无法发现的问题。 ","date":"0001-01-01","objectID":"/int/:0:15","series":null,"tags":null,"title":"","uri":"/int/#软件测试的核心竞争力是什么"},{"categories":null,"content":" 测试和开发要怎么结合才能使软件的质量得到更好的保障答：测试和开发可以按照V模型或W模型的方式进行结合。但应该按照W模型的方式进行结合比较合理。 V模型： 测试过程加在开发过程的后半段，比较被动。 W模型： 测试提前，甚至和开发是同步进行，测试不仅是程序，还包括需求和设计。W模型有利于尽早地全面的发现问题，降低软件开发的成本，风险前置。 ","date":"0001-01-01","objectID":"/int/:0:16","series":null,"tags":null,"title":"","uri":"/int/#测试和开发要怎么结合才能使软件的质量得到更好的保障"},{"categories":null,"content":" 怎么实施自动化测试（过程）答： 首先判断项目适不适合进行自动化测试。 对项目做需求分析。 制定测试计划和测试方案。 搭建自动化测试框架。 设计或编写测试用例。 执行自动化测试。 评估。 ","date":"0001-01-01","objectID":"/int/:0:17","series":null,"tags":null,"title":"","uri":"/int/#怎么实施自动化测试过程"},{"categories":null,"content":" 测试的相关流程答： 按W模型： 需求测试 -\u003e 概要设计测试 -\u003e 详细设计测试 -\u003e 单元测试 -\u003e 集成测试 -\u003e 系统测试 -\u003e 验收测试 我工作中实际测试流程： 需求评审 -\u003e 技术评审 -\u003e case评审 -\u003e 开发自测以及冒烟测试 -\u003e 整体提测（集成测试） -\u003e 回归测试 -\u003e 系统测试 -\u003e 验收测试 测试流程：了解用户需求–\u003e测试计划（测试范围，人力物力时间进度的安排）–\u003e编写测试用例–\u003e评审用例–\u003e搭建环境–\u003e测试包安排预测（冒烟测试）-正式测试-bug管理-测试结束出报告，决定是否上线–\u003e版本上线–\u003e面向用户 ","date":"0001-01-01","objectID":"/int/:0:18","series":null,"tags":null,"title":"","uri":"/int/#测试的相关流程"},{"categories":null,"content":" 测试项目具体工作是什么答： 搭建测试环境 撰写测试用例 执行测试用例 写测试计划、测试报告 测试并提交BUG 跟踪BUG修改情况 自动化测试 性能测试、压力测试、安全测试等其他测试 ","date":"0001-01-01","objectID":"/int/:0:19","series":null,"tags":null,"title":"","uri":"/int/#测试项目具体工作是什么"},{"categories":null,"content":" BUG分级答：两个维度去划分 按BUG严重程度划分等级： blocker：系统无法执行，崩溃，或严重资源不足，应用模块无法启动或异常退出，无法测试，系统不稳定。常见的：严重花屏、内存泄漏、用户数据丢失或破坏、系统崩溃/死机/冻结、模块无法启动或异常退出、严重的数值计算错误、功能设计与需求严重不符、服务器500等。 critical：影响系统功能或操作，主要功能存在严重缺陷，但不会影响到系统的稳定性。常见的有：功能未实现，功能错误、系统刷新错误、数据通讯错误、轻微的数值计算错误、影响功能及洁面的错别字或拼写错误。 major：界面、性能缺陷、兼容性。常见的有：操作界面错误、边界条件错误、提示信息错误，长时间操作无法提示、系统未优化、兼容性问题。 minor/trivial：易用性及建议性的问题。 按BUG处理优先级划分： immediate：马上解决 urgent：急需解决 high：高度重视，有时间马上解决 low：在系统发布前解决或确认可以不用解决 ","date":"0001-01-01","objectID":"/int/:0:20","series":null,"tags":null,"title":"","uri":"/int/#bug分级"},{"categories":null,"content":" 性能指标有哪些？ ","date":"0001-01-01","objectID":"/int/:0:21","series":null,"tags":null,"title":"","uri":"/int/#性能指标有哪些"},{"categories":null,"content":" APP性能指标有哪些？答：内存、CPU、流量、电量、启动速度、滑动速度、界面切换速度、与服务器交互的网络速度。 ","date":"0001-01-01","objectID":"/int/:0:22","series":null,"tags":null,"title":"","uri":"/int/#app性能指标有哪些"},{"categories":null,"content":" APP测试工具有哪些？接口测试：postman 性能测试：jmeter 抓包工具：chales、fiddler UI自动化：uiautomator2、appium、atx 稳定性测试：monkey、maxim、uicrawler、appcrawler 兼容性测试：wetest、testin 内存、cpu、电量测试：GT、soloPi 弱网测试：chales ","date":"0001-01-01","objectID":"/int/:0:23","series":null,"tags":null,"title":"","uri":"/int/#app测试工具有哪些"},{"categories":null,"content":" BUG的生命周期答： 复杂版： New（新的） Assigned（已指派） Open（打开的） Fixed（已修复） Pending Reset（待测试） Reset（再测试） Closed（已关闭） Reopen（再次打开） Pending Reject（拒绝中） Rejected（被拒绝的） Postponed（延期） 简单版： 创建bug 分配bug 修复完待测试 关闭 重新开启 无效 ","date":"0001-01-01","objectID":"/int/:0:24","series":null,"tags":null,"title":"","uri":"/int/#bug的生命周期"},{"categories":null,"content":" 什么是α测试和β 测试？答： α测试：在受控的环境下进行，由用户在开发者的场所进行，开发者指导用户测试，开发者负责记录发现的错误和使用中遇到的问题。 β 测试：在开发者不可控的环境下进行，由软件最终用户在一个或多个客户场所下进行，用户记录测试中遇到的问题，并定期上报给开发者。 ","date":"0001-01-01","objectID":"/int/:0:25","series":null,"tags":null,"title":"","uri":"/int/#什么是α测试和β-测试"},{"categories":null,"content":" 谈谈对敏捷的理解 简单谈四种开发模型： 传统的瀑布式开发，也就是从制定计划到需求分析到系统设计，到编码，到测试，到提交到运维大概这样的流程，要求每一个开发阶段都要做到最好。 迭代式开发，不要求每一个阶段的任务做的都是最完美的，而是明明知道还有很多不足的地方，却偏偏不去完善它，而是把主要功能先搭建起来为目的，以最短的时间，最少的损失先完成一个“不完美的成果物”直至提交。然后再通过客户或用户的反馈信息，在这个“不完美的成果物”上逐步进行完善。 螺旋开发，很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。 敏捷开发，相比迭代式开发两者都强调在较短的开发周期提交软件，但是，敏捷开发的周期可能更短，并且更加强调队伍中的高度协作。 谈敏捷测试： 敏捷开发也对应着有敏捷测试，测试环节贯穿整个迭代周期，从需求评审到发布上线，都离不开测试快速跟进。 测试左移：需求评审、用例设计、自测工具、静态代码扫描等； 测试中：业务测试，接口测试，性能测试等； 测试右移：稳定性测试，回归测试，灰度测试等 ","date":"0001-01-01","objectID":"/int/:0:26","series":null,"tags":null,"title":"","uri":"/int/#谈谈对敏捷的理解"},{"categories":null,"content":" 什么是压力测试？压力测试需要考虑哪些因素？答： 压力测试是在高负载情况下，对系统稳定性进行测试。在高负载的情况下，系统出现异常的概率要比正常负载时要高。高负载包含长时间运行、大数据、高并发等情况。 在做压力测试时，一般要考虑环境因素、性能指标、运行时间等要素。 压测环境最好和生产环境一致，假如要在生产环境进行压测，需要在凌晨等在线用户量极少的情况下进行。在生产环境测试时要做好数据隔离，生产环境需提供虚拟数据，采用虚拟账号，避免对真实线上用户造成影响。 性能指标包括，内存、CPU、吞吐量、QPS、网络流量、错误统计等，这些指标需要监控。 压测一般需要运行长时间，最好能够通过长时间的压测，绘制出曲线图，这样更容易观察到性能瓶颈。 ","date":"0001-01-01","objectID":"/int/:0:27","series":null,"tags":null,"title":"","uri":"/int/#什么是压力测试压力测试需要考虑哪些因素"},{"categories":null,"content":" web测试和APP测试的不同？ ","date":"0001-01-01","objectID":"/int/:0:28","series":null,"tags":null,"title":"","uri":"/int/#web测试和app测试的不同"},{"categories":null,"content":" 虚拟化虚拟化相关的开源项目源码，例如 KVM、QEMU、Firecracker 等； 虚拟化原理，例如 CPU/内存/IO 虚拟化、虚拟机热迁移等； ","date":"0001-01-01","objectID":"/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:0","series":null,"tags":null,"title":"","uri":"/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/#虚拟化"},{"categories":null,"content":" Typescript/React/GraphQL/NodeJShttps://developer.apple.com/tutorials/app-dev-training/using-stacks-to-arrange-views https://developer.apple.com/cn/maps/resources/ https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation ","date":"0001-01-01","objectID":"/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:0","series":null,"tags":null,"title":"","uri":"/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/#typescriptreactgraphqlnodejs"},{"categories":null,"content":" 分布式 完成过 MIT 6.824，MIT 6.828 等相关课程； 在各种编程竞赛中获得奖项，包括 ACM 等； 有 HDFS、CephFS、GlusterFS、Lustre 或其他分布式系统的开发经验。 完成过 MIT 6.824，MIT 6.828 或近似课程（学完大部分，做过大部分 Lab，Raft 建议读过原始 Paper，OS 方向建议读完深入理解计算机系统）； 阅读过 HDFS，Ceph，GlusterFS 或其他分布式存储系统的实现原理与源码（相关的原理 Paper 完整读过，看过代码能讲清楚基本 IO 流和数据生命周期）； 熟悉 LevelDB，RocksDB 等 KV 存储或 XFS, EXT3，EXT4 等单机文件系统的实现原理（BigTable 的 Paper 读过， 能描述基本 CRUD 流程和某一个关键特性的实现思路即可）。 BigTable-\u003eleveldb https://leveldb-handbook.readthedocs.io/zh/latest/basic.html#section-2 https://youngff.github.io/MyHearthStone/spring%20framework/spring-core/spring-defaultlistablebeanfactory/ 谈谈你对索引的理解：三种索引+重点B+树+b+树历史+为什么b+树+b+树+要不要分库分表？建立索引要注意什么？什么情况下会用到索引？ 从人文的角度去展示自己对技术的热爱，比如 1970年Rudolf Bayer提出的B+树，灵感源自平衡二叉树和 B 树，为外存设计，减少IO次数 索引页数量少 再平衡时，B+ 树算法调整的索引节点数量也很少 索引容量足够大:3 层索引可承载 2000 万行数据，4 层索引可承载 200 多亿行 索引页少，可以将所有索引全部载入内存，读取索引的磁盘 I/O 趋近于 0 MySQL的读级别的历史演变 2017 年的阿里巴巴 Java 开发手册上说，当单表行数超过 500 万行或单表容量超过 2GB 时，推荐进行分 库分表。 ","date":"0001-01-01","objectID":"/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:0","series":null,"tags":null,"title":"","uri":"/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/#分布式"}]