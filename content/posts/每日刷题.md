---
title: "LeetCode 热题 HOT 100"
date: 2023-07-11T02:03:11+10:00
lastmod: 2020-07-013T02:03:11+10:00
draft: false
authors: [Sad_man]
tags: [数据结构与算法, leetcode]
categories: [数据结构与算法]
series: [24届从零开始到找到工作]
series_weight: 1
---

本系列题库[链接](https://leetcode.cn/problem-list/2cktkvj/)



#### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

思路1. 先排序，然后双指针，时间复杂度为O(nlogn), 空间复杂度O(1).

```java

```

思路2. 使用HashMap保存访问过的数字。

```java

```



#### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

思路1. 用一个variable保存进位结果，在一个循环内完成

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int temp = 0;
        ListNode head = new ListNode(0); 
        ListNode cursor = head;
        while (l1 != null || l2 != null || temp != 0) {
            int l1Val = l1 == null ? 0 : l1.val;
            int l2Val = l2 == null ? 0 : l2.val;
            int position = l1Val + l2Val + temp;
            temp = position / 10;
            position %= 10;
            ListNode ln = l1 != null ? l1 : l2 != null ? l2 : new ListNode(0);
            ln.val = position;
            cursor.next = ln;
            cursor = cursor.next;
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }

        return head.next;
    }
}
```



#### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

思路1. 使用一个HashMap保存出现过的字符，然后使用双指针

```java

```



#### [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

思路1. 当在一个较小的数组`m`中选一个假定的中位数位分割线，那么在长的数组`n`中的分割位置也确定了。由此我们可以获得两个分割线两侧的四个数字m[i], m[i + 1], n[j], n[j + 1]. 如果m[i] <= n[j + 1] && n [j] <= m[i + 1]，那么就是中位数，如果不是调整分割线的位置。要注意的是处理奇偶数。

```java

```

#### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

思路1. 双指针扩散，一次是基数一次是偶数。

```java

```

#### [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

思路1. 因为是后出现的匹配前面的元素，所以可以倒序遍历。于是结果是一个树状的结构，对于每一个'*'多匹配，都是一个分叉点。

```java
public class Solution {
    public boolean isMatch(String s, String p) {
        return isMatch(s, s.length(), p, p.length());
    }

    private boolean isMatch(String s, int i, String p, int j) {
        if (j == 0) {
            return i == 0;
        }

        if (i == 0) {
            if (j > 1 && p.charAt(j - 1) == '*') {
                return isMatch(s, i, p, j - 2);
            } else {
                return false;
            }
        }

        if (p.charAt(j - 1) == '*') {
            if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') {
                return isMatch(s, i - 1, p, j) || isMatch(s, i, p, j - 2);
            } else {
                return isMatch(s, i, p, j - 2);
            }
        }

        if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
            return isMatch(s, i - 1, p, j - 1);
        }

        return false;
    }
}
```



思路2. 正经思路，动态规划。

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        boolean[][] f = new boolean[m + 1][n + 1];
        f[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p.charAt(j - 1) == '*') {
                    f[i][j] = f[i][j - 2];
                    if (matches(s, p, i, j - 1)) {
                        f[i][j] = f[i][j] || f[i - 1][j];
                    }
                } else {
                    if (matches(s, p, i, j)) {
                        f[i][j] = f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }

    public boolean matches(String s, String p, int i, int j) {
        if (i == 0) {
            return false;
        }
        if (p.charAt(j - 1) == '.') {
            return true;
        }
        return s.charAt(i - 1) == p.charAt(j - 1);
    }
}
```

#### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

思路1. 双指针，从两侧向中间逼近。

#### [15. 三数之和](https://leetcode.cn/problems/3sum/)

思路1. 排序+双指针

#### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

思路1. Step 1，使用建立从数字到字母的映射；Step 2，深度优先

#### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

思路1. 双指针，快指针走N步，再走慢指针

#### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

思路1. 建立括号配对，使用栈

#### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

思路1. 递归或者迭代。

#### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

思路1. 先生成，再检测

思路2. 深度优先，记录左右括号剩余数量，当左括号可用数量大于右括号的时候，结束。

```java
import java.util.ArrayList;
import java.util.List;

public class Solution {

    // 做减法

    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        // 特判
        if (n == 0) {
            return res;
        }

        // 执行深度优先遍历，搜索可能的结果
        dfs("", n, n, res);
        return res;
    }

    /**
     * @param curStr 当前递归得到的结果
     * @param left   左括号还有几个可以使用
     * @param right  右括号还有几个可以使用
     * @param res    结果集
     */
    private void dfs(String curStr, int left, int right, List<String> res) {
        // 因为每一次尝试，都使用新的字符串变量，所以无需回溯
        // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分
        if (left == 0 && right == 0) {
            res.add(curStr);
            return;
        }

        // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）
        if (left > right) {
            return;
        }

        if (left > 0) {
            dfs(curStr + "(", left - 1, right, res);
        }

        if (right > 0) {
            dfs(curStr + ")", left, right - 1, res);
        }
    }
}
```

#### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

思路1. 放在一个小顶堆中，每次取堆顶的链表li，并且将li.next放回堆内. Java

```java
// 关键点在于，如何实现Comparable接口，如何使用PriorityQueue，添加offer取出poll

class Solution {
    class Status implements Comparable<Status> {
        int val;
        ListNode ptr;

        Status(int val, ListNode ptr) {
            this.val = val;
            this.ptr = ptr;
        }

        public int compareTo(Status status2) {
            return this.val - status2.val;
        }
    }

    PriorityQueue<Status> queue = new PriorityQueue<Status>();

    public ListNode mergeKLists(ListNode[] lists) {
        for (ListNode node: lists) {
            if (node != null) {
                queue.offer(new Status(node.val, node));
            }
        }
        ListNode head = new ListNode(0);
        ListNode tail = head;
        while (!queue.isEmpty()) {
            Status f = queue.poll();
            tail.next = f.ptr;
            tail = tail.next;
            if (f.ptr.next != null) {
                queue.offer(new Status(f.ptr.next.val, f.ptr.next));
            }
        }
        return head.next;
    }
}
```

#### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

思路1. 想象将一个靠右的直角转换成靠左的直角。所以要从后往前找到第一个与终极形态不符的位置x，再从前往后找到第一个比x大的位置，即x的右侧比x大的最小值y，swap(x, y)，然后将y后的进行排序。

#### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

**错误**思路1. 使用3个variable来记录信息，left来记录有效括号左边的位置，value来记录当前是否合法。max来记录最长有效括号。关于判断value是否合法，遇到"("则value加1，遇到")"则value减1，当value小于0，则不合法，更新left到当前right位置。当前合法长度为循环中的right - left + 1 - value。

这种方式在遇到"()(()"的时候就会**变成笨蛋**.

思路1. 动态规划。

```java
class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
        int[] dp = new int[s.length()];
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                  // 如果左侧还有位置，并且这个位置是(
                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                  	// ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0)是为了查看在匹配到的左括号前是否有()
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = Math.max(maxans, dp[i]);
            }
        }
        return maxans;
    }
}

```

思路2. 栈

```java
class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
        Deque<Integer> stack = new LinkedList<Integer>();
        stack.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if (stack.isEmpty()) {
                  	// 记录左侧位置
                    stack.push(i);
                } else {
                    maxans = Math.max(maxans, i - stack.peek());
                }
            }
        }
        return maxans;
    }
}

```

思路3. 最爱滴双指针。

```java
class Solution {
    public int longestValidParentheses(String s) {
        int left = 0, right = 0, maxlength = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = Math.max(maxlength, 2 * right);
            } else if (right > left) {
                left = right = 0;
            }
        }
        left = right = 0;
      	// 解决了从前往后的便利中，无法探测到(()中()的问题，因为在这个过程中, left>right
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = Math.max(maxlength, 2 * left);
            } else if (left > right) {
                left = right = 0;
            }
        }
        return maxlength;
    }
}
```

#### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

思路1.找两次，即第一次找到k，第二次再找目标值。

思路2. 将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。
此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环. 

如何判断有序？从0到mid升序就是有序，即nums[0] < nums[mid]。

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if (n == 0) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
}

```

#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

思路1. 找到第一个target，找到第一个target+1.

```java
class Solution {
    //先找>=target的第一个
    //再找>target的第一个
    //我真是这辈子都不想看见这题
    public int[] searchRange(int[] nums, int target) {
        int l=search(nums,target);
        int r=search(nums,target+1);
        if(l==nums.length||nums[l]!=target)
            return new int[]{-1,-1};
        return new int[]{l,r-1};
    }
    //找>=target的第一个
    public int search(int[] nums,int target){
        int l=0,r=nums.length;
        while(l<r){
            int mid=(r+l)>>1;
            if(nums[mid]>=target) r=mid;
            else l=mid+1;
        }
        return l;
    }
}
```

#### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

思路1. 回溯法。结果是一颗树，根是target，每次向下都要减去当前入栈的value。

```java
public class Solution {

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        int len = candidates.length;
        List<List<Integer>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }

        Deque<Integer> path = new ArrayDeque<>();
        dfs(candidates, 0, len, target, path, res);
        return res;
    }

    /**
     * @param candidates 候选数组
     * @param begin      搜索起点
     * @param len        冗余变量，是 candidates 里的属性，可以不传
     * @param target     每减去一个元素，目标值变小
     * @param path       从根结点到叶子结点的路径，是一个栈
     * @param res        结果集列表
     */
    private void dfs(int[] candidates, int begin, int len, int target, Deque<Integer> path, List<List<Integer>> res) {
        // target 为负数和 0 的时候不再产生新的孩子结点
        if (target < 0) {
            return;
        }
        if (target == 0) {
            res.add(new ArrayList<>(path));
            return;
        }

        // 重点理解这里从 begin 开始搜索的语意
        for (int i = begin; i < len; i++) {
            path.addLast(candidates[i]);

            // 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是 i，这里非常容易弄错
            dfs(candidates, i, len, target - candidates[i], path, res);

            // 状态重置
            path.removeLast();
        }
    }
}
```

思路2. 思路1的基础上，强化剪枝。因为会出现树的结点value为负的时候，这种时候后面的都不用看了，因为后面的会更大，导致value更小。

```java
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.List;

public class Solution {

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        int len = candidates.length;
        List<List<Integer>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }

        // 排序是剪枝的前提
        Arrays.sort(candidates);
        Deque<Integer> path = new ArrayDeque<>();
        dfs(candidates, 0, len, target, path, res);
        return res;
    }

    private void dfs(int[] candidates, int begin, int len, int target, Deque<Integer> path, List<List<Integer>> res) {
        // 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况
        if (target == 0) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = begin; i < len; i++) {
            // 重点理解这里剪枝，前提是候选数组已经有序，
            if (target - candidates[i] < 0) {
                break;
            }
            
            path.addLast(candidates[i]);
            dfs(candidates, i, len, target - candidates[i], path, res);
            path.removeLast();
        }
    }
}
```

#### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

思路1. 双指针，每次移动较小的。最容易想的

思路2. 单调栈。我想知道所有接雨水是不是都能用双指针解决，如果是，就不看思路2了。

#### [46. 全排列](https://leetcode.cn/problems/permutations/)

思路1. 深度优先/回溯。使用一个数组，来标记是否使用过

```java
public class Solution {

    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        // 使用一个动态数组保存所有可能的全排列
        List<List<Integer>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }

        boolean[] used = new boolean[len];
        Deque<Integer> path = new ArrayDeque<>(len);

        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     Deque<Integer> path, boolean[] used,
                     List<List<Integer>> res) {
        if (depth == len) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < len; i++) {
            if (!used[i]) {
                path.addLast(nums[i]);
                used[i] = true;
                dfs(nums, len, depth + 1, path, used, res);
                used[i] = false;
                path.removeLast();
            }
        }
    }
}

作者：liweiwei1419
链接：https://leetcode.cn/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

上面这个好理解，那么下面这个呢？

```java
// 创建一个Solution类
class Solution {
    // 定义一个公开方法permute，参数是一个整型数组，返回值是一个整型二维列表
    public List<List<Integer>> permute(int[] nums) {
        // 初始化一个空的二维列表来存储结果
        List<List<Integer>> res = new ArrayList<List<Integer>>();

        // 将输入数组转化为一个ArrayList
        List<Integer> output = new ArrayList<Integer>();
        for (int num : nums) {
            output.add(num);
        }

        // 获取输入数组的长度
        int n = nums.length;
        // 调用回溯函数，从第0个元素开始处理
        backtrack(n, output, res, 0);
        // 返回最终的结果
        return res;
    }

    // 定义一个私有方法backtrack，参数是整型n，一个整型列表output，一个二维整型列表res，整型first
    public void backtrack(int n, List<Integer> output, List<List<Integer>> res, int first) {
        // 如果first等于n，说明所有的数都已经被处理过了
        if (first == n) {
            // 将当前列表output复制并添加到结果列表res中
            res.add(new ArrayList<Integer>(output));
        }
        // 使用一个for循环从first开始遍历到n
        for (int i = first; i < n; i++) {
            // 交换列表中的第first个元素和第i个元素，来动态维护当前的列表
            Collections.swap(output, first, i);
            // 递归调用backtrack，参数first+1，来处理下一个元素
            backtrack(n, output, res, first + 1);
            // 交换回列表中的第first个元素和第i个元素，以实现回溯
            Collections.swap(output, first, i);
        }
    }
}

```

这里没有使用used数组的奥秘是，使用了swap，这样的话，被使用了的数字被交换到了前面，后面的就都是没有被用过的了。

#### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

思路1. x,y对换，然后垂直对折。

#### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

思路1. 暴力求解。提取string的char[]，排序并生成一个string，这样相同字母组成的string都对应同一个map中的key。

思路2. 使用HashMap统计每一个字母出现次数，并且生成字符串，作为key

#### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

思路1. 动态规划？前缀和？**前缀和也可以不用dp数组！**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}
```

思路2. 线断树，我还不懂

```java
class Solution {
    public class Status {
        public int lSum, rSum, mSum, iSum;

        public Status(int lSum, int rSum, int mSum, int iSum) {
            this.lSum = lSum;
            this.rSum = rSum;
            this.mSum = mSum;
            this.iSum = iSum;
        }
    }

    public int maxSubArray(int[] nums) {
        return getInfo(nums, 0, nums.length - 1).mSum;
    }

    public Status getInfo(int[] a, int l, int r) {
        if (l == r) {
            return new Status(a[l], a[l], a[l], a[l]);
        }
        int m = (l + r) >> 1;
        Status lSub = getInfo(a, l, m);
        Status rSub = getInfo(a, m + 1, r);
        return pushUp(lSub, rSub);
    }

    public Status pushUp(Status l, Status r) {
        int iSum = l.iSum + r.iSum;
        int lSum = Math.max(l.lSum, l.iSum + r.lSum);
        int rSum = Math.max(r.rSum, r.iSum + l.rSum);
        int mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);
        return new Status(lSum, rSum, mSum, iSum);
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

从左往右，每次更新能到达的最远的位置

```java
public class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = Math.max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

#### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

思路1. 暴力求解，用bit数组保存区间。

思路2. 先排序，然后双指针

#### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

思路1. 深度优先？**NO！**dp数组记录。



```
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] f = new int[m][n];
        for (int i = 0; i < m; ++i) {
            f[i][0] = 1;
        }
        for (int j = 0; j < n; ++j) {
            f[0][j] = 1;
        }
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        return f[m - 1][n - 1];
    }
}
```

思路2. 计算

```java
class Solution {
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
}
```

#### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

思路1. 跟随上一题的思路，同样dp



下一任务点：柱状图中最大矩形
