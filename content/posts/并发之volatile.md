---
title: "并发之volatile"
date: 2023-12-07T23:46:52+08:00
draft: false
---

# volatile

## brief

围绕两句话展开：保证可见性、禁止指令冲排序。

volatile，保证所有线程看到这个变量的值是一致的。

为什么会不一致？因为多级缓存（L1、L2、L3），如果读到了，可以直接返回，所以读多写少的话性能很好。

缓存命中（读缓存行）、写命中（写缓存行）





## 可见性实现机制

对于volatile写操作，在汇编层面添加lock前缀的指令，做两件事1.缓存行写回内存；2.其他缓存行无效

lock，锁总线，先进的处理器会锁内存区域，改哪里锁哪里，并且使用缓存一致性协议阻止多处理器同时修改缓存。

其他处理器嗅探查看自己的缓存是否过期，如果过期，则自己的缓存行无效。

为此引出了一个volatile用法优化，有了一个相关的优化思路，比如如果有一个双向队列，要频繁的出队入队。强行padding到64字节，为了保证头尾节点不会被一起加载进缓存行，修改时不会互相锁定。（优化要求：频繁写，64字节的缓存行）

进而有一个神奇的注解，那就是@sun.misc.Contended

伪共享问题出现在以下场景：

1. 多个核心（或线程）在同一时间读写不同的变量。
2. 这些变量恰好位于同一个缓存行上。
3. 当一个核心修改它所在缓存行上的一个变量时，整个缓存行都被标记为无效。
4. 因此，其他核心在访问它们各自的变量时，需要从主内存重新加载整个缓存行，即使它们并没有真正共享任何数据。

而被@sun.misc.Contended标记的字段，会被填充到一个缓存行大小，避免伪共享。



## 禁止指令重冲排序

下面是基于**保守策略**的JMM内存屏障插入策略。·

在每个volatile写操作的前面插入一个StoreStore屏障，写volatile前其他写已经完成（完成指刷入主存）

在每个volatile写操作的后面插入一个StoreLoad屏障，写volatile后，修改可见（不是在volatile前面加内存屏障，因为volatile常见使用是单写+多线程读volatile，所以要在单后加而不是多前加）

在每个volatile读操作的后面插入一个LoadLoad屏障，读volatile后，再读其他的

在每个volatile读操作的后面插入一个LoadStore屏障，读volatile后，再写其他的

而new一个对象是写啊，会加上storestore以及storeload屏障，所以



非保守策略：按需求省略四个屏障中的几个



为什么是volatile和其他？

```java
// 2341和1234会产生不同的结果i== 0 || 1
class VolatileExample {
  int a=0;
	volatile boolean flag = false;
  public void writer() {
    a = 1;//1
		flag = true;// 2
	public void reader () {
    if (flag) {//3
    int i = a;//4
   }
}
    
写前不能冲排序，读后不能冲排序，写读不能重排序
·当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。
·当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。
·当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。

```

volatile的禁止指令重排序使用：双重检查锁。（为什么要双重检查？sychronized下推因为避免频繁的获得锁。为什么要用volatile？禁止指令重排序。

ps：双重检查锁之外，还有静态内部类，这里使用的是类加载的初始化期间，获得Class对象初始化的锁的线程进行创建对象。
