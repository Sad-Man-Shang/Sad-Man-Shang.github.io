---
title: "并发"
date: 2023-08-15T15:27:20+08:00
draft: true
authors: [Sad_man]
tags: [面试]
categories: [并发]	
series: [学习笔记]
series_weight: 1
---

# 零、ALL



# 一、初探并发编程

线程状态转换

![image-20230327044224075](/Users/shengquan/my_website/content/posts/并发.assets/image-20230327044224075-2084650.png)



——————

## jstack log

jps查看pid

jstack pid

可以得到当前类运行状态下的所有栈信息

## Thread源码

init()

一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的（sync）ID来标识这个child线程。至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。

start()

线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。



Thread.sleep

是否释放锁？ 不

是否对中断敏感 ？ 是

是否释放 CPU ： 是 





Object.wait

是否释放锁？ 是

是否对中断敏感 是

是否释放 CPU：是释放的。让出 CPU 时间片。进入等待队列。（sync时候，深入介绍。waitset， _cxq, entrylist）



Thread.join

是否释放锁？ 释放的是调用join方法的对象的锁

```java
synchronized(obj){
	thread.join(); //join不释放锁
}synchronized(thread){
	thread.join(); //join释放锁
}
```



是否对中断敏感 是

是否释放 CPU：是释放的。



## 线程间的通信方式

1. volitate 、synchronize、lock。（都保证可见性）
2. wait、notify、await() 、 signal
3. 管道输入、输出流  (示例代码：PipeInOut.java)	管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。
4. Thread.join() ： 隐式唤醒。等待其他线程执行完成，其他线程会发送唤醒信号。
5. ThradLocal() ---》支持子线程集成的一种形式。埋点。
6. 线程中断 中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep(long millis)方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。



# 二、synchronized 全解读｜重点

## A. synchronized的使用方法

javap -v Hello.class进行反编译

普通方法、静态方法、同步代码块



## B. 特性 与对象头

1. 有序性 （读读、读写、写读、写写 互斥）
2. 可见性 （可见性是指多个线程访问⼀个资源时，该资源的状态、值信息等对于其他线程都是可见的。 synchronized和volatile都具有可见性，其中synchronized对⼀个类或对象加锁时，⼀个线程如果要访问该类或对象必须先获得它的锁，⽽这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。）
3. 原子性 (本质上是线程互斥保证的原子性)
4. 可重入性 （代码示例 ThreadReIn.java）

### 对象头

32bits虚拟机

![image-20230513014619257](/Users/shengquan/my_website/content/posts/并发.assets/image-20230513014619257.png)

![image-20230513014626561](/Users/shengquan/my_website/content/posts/并发.assets/image-20230513014626561.png)



为什么mark word的一部分要在栈帧、objectmonitor的head之间流转呢？

这是因为 Java 采用了标记-清除式垃圾回收机制。在垃圾回收时,JVM 需要知道哪些对象被锁定了,不能回收。为了实现这个目的,Java 将对象的 mark word 中的锁信息提取出来,存储在:1. 对象所在的栈帧中 - 对应轻量级锁

2. ObjectMonitor 的 owner 字段中 - 对应重量级锁这样做的目的是为了让 GC 能准确地判断出哪些对象被锁定了。具体来说:1. 轻量级锁时,锁信息存储在栈帧中,这是因为轻量级锁是通过 CAS 操作对象的 mark word 来加锁的。为了让 GC 知道对象被轻量级锁锁定,就将 mark word 中的锁数据提取出来,存储到栈帧中,之后 CAS 操作将对象的 mark word 指向栈帧。这样 GC 在扫描对象时, seeing 对象的 mark word 指向栈帧,就知道该对象被轻量级锁锁定了。2. 重量级锁时,锁信息存储在 ObjectMonitor 的 owner 字段中。这是因为重量级锁是通过对象的 mark word 中指向 ObjectMonitor 来加锁的。为了让 GC 知道对象被重量级锁锁定,就将 mark word 中的锁数据提取出来,存储到 ObjectMonitor 的 owner 字段中,之后将对象的 mark word 指向 ObjectMonitor。这样 GC 在扫描到对象时,seeing 对象的 mark word 指向 ObjectMonitor,就知道该对象被重量级锁锁定了。所以总结来说,之所以要在栈帧、ObjectMonitor 的 owner 字段之间流转,主要是为了能准确地判断出被锁定的对象,帮助 GC 做准确的回收。这是 Java 采用标记-清除式 GC 所要解决的问题之一。通过这样的设计,Java 既实现了轻量级锁和重量级锁,又能准确地做垃圾回收,这显示出 Java 锁机制和 GC 之间的巧妙配合。

## C. 偏向锁

偏向锁使用的前提：

1. 至少JDK1.6 版本且开启了偏向锁配置。偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。
2. 被加锁的对象，没有真正、或者隐式的调用父类 Object 里边的hashcode方法。

开启偏向锁且无延迟的时候，markword末尾默认101

在之前调用了hashcode or identifyhashcode，则一次就升级成轻量级锁（即一次synchronized就00）



为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头：存储线程id

和栈帧中的锁记录里：线程有自己的栈帧，LOCK RECORD: 存储当前线程id

存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向

**当前线程的偏向锁****。：id**的匹配**

**如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word****中偏向锁的标识是否设置成1****（表示当前是偏向锁）：如果没有设置，则使用CAS****竞争锁；如果设置了，则尝试使用CAS****将对象头的**

**偏向锁指向当前线程： 其实是cas竞争替换 线程id。**





为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。



## D. 偏向锁的升级

![image-20230513022214943](/Users/shengquan/my_website/content/posts/并发.assets/image-20230513022214943.png)

偏向锁使用了一种等到竞争出现才释放锁的机制，一旦有竞争环境，偏向锁就会升级成轻量级锁。（不严谨）



偏向锁：  **1.** A线程获取偏向锁，并且A线程死亡退出。B线程争抢偏向锁，会直接升级当前对象的锁为轻量级锁。**这只是针对我们争抢了一次。**  2. A线程获取偏向锁，并且A线程没有释放偏向锁（），还在syhnc的代码块里边。B线程此时过来争抢偏向锁，会直接升级为重量级锁。  3. A线程获取偏向锁，并且A线程释放了锁，但是A线程并没有死亡还在活跃状态。B线程过来争抢，会直接升级为轻量级锁。  综上所述，当我们尝试第一次竞争偏向锁时，如果A线程已经死亡，升级为轻量级锁；如果A线程未死亡，并且未释放锁，直接升级为重量级锁；如果A线程未死亡，并且已经释放了锁，直接升级为轻量级锁。  

——————————下面的一般不说

4.A线程获取偏向锁，并且A线程没有释放偏向锁（），还在syhnc的代码块里边。B线程多次争抢锁，会在加锁过程中采用重量级锁；但是，一旦锁被释放，当前对象还是会以轻量级锁的初始状态执行。这块算是锁降级吗？不算。这个示例就是我们一些博客论坛里边的一些认为可以锁降级的示例。--- 锁升级是在线程运行过程中和争抢过程中的一种升级。这句话里一定要注意 中 这个字儿，很重要。我想请问，刚才我们演示的是在竞争中的锁降级吗？  

 

    5. A线程获取偏向锁，并且A线程释放了锁，但是A线程并没有死亡还在活跃状态。B线程过来争抢。部分争抢会升级为轻量级锁；部分争抢会依旧保持偏向锁。  



偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁（批量撤销？），最后唤醒暂停的线程。 （面试时使用）



批量重偏向

当我们的一个对象，Object 类，在经过默认 20次的争抢的情况下，会将后边的所有争抢从新偏向争抢的线程。1. 当B线程争抢第 18 次的时候，触发了批量重偏向的阈值；在第十八次以及以后的争抢里，jvm会将线程偏向线程b，因为jvm认为，这个对象更加适合线程B



批量撤销

如果基于批量重偏向的基础上，还在继续进行争抢达到40次，并且有第三条线程C加入了，这个时候会触发批量撤销。JVM会标记该对象不能使用偏向锁，以后新创建的对象，直接以轻量级锁开始。 这个时候，才是真正的完成了锁升级。



无竞争->弱竞争

真正的锁升级，是依赖于 class 的，而并不是依赖于 某一个 new出来的对象（偏向锁升级为轻量级锁）。

真正的锁升级，是依赖于当前new出来的对象的（轻量级锁升级为重量级锁）

轻量级锁升级为重量级锁：这个时候，只要我们的线程发生了竞争，并且CAS替换失败，就会发起锁膨胀，升级为重量级锁（针对的是一个对象实例）。



## E.Synchronized 锁升级 - 轻量级锁加锁与解锁

（1）轻量级锁加锁线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间（Lock Record记录），并将对象头中的Mark Word（前30位 （25位的hashcode，4位的分代年龄，1位是否为偏向锁））复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针（指向线程栈帧里边的Lock Record的指针）。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

（2）轻量级锁解锁轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word（Lock Record记录）替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。



轻量级膨胀到重量级锁（cas会操作10次，判定失败，那么就是重量级锁了）

![image-20230517033019534](/Users/shengquan/my_website/content/posts/并发.assets/image-20230517033019534.png)



轻量级锁---重量级锁： 

释放锁（前四步）并唤醒等待线程  1. 线程1 初始化monitor 对象；  2. 将状态设置为膨胀中（inflating）；  3. 将monitor里边的header属性，set称为对象的markword；（将自己lock record里边的存放的mark word的hashcode，分代年龄，是否为偏向锁 set 到 objectmonitor对象的header属性里）  4. 设置对象头为重量级锁状态（标记为改为00）；然后将前30位指向第1不他初始化的monitor 对象；（真正的锁升级是由线程1操控的）  

5.唤醒线程2；  

6.线程2 开始争抢重量级锁。（线程2就干了一件事儿，就是弄了一个临时的重量级锁指针吧？还不是最后的重量级锁指针。因为最后的重量级锁指针是线程1初始化的并且是线程1修改的。 而且，线程2被唤醒之后，还不一定能够抢到这个重量级锁。Sync是非公平锁。 线程2费力不讨好，但是线程2做了一件伟大的事情：他是锁升级的奠基者。）  

## F. 锁升级中，markword的转化过程

创建一个对象，此时对象里边没有hashcode，所以该对象可以使用我们的偏向锁，偏向锁不会考虑hashcode，他会直接将自己的线程id放到我们的markword里边，不需要考虑后续的替换问题。 所以呢，一旦我们的对象主动调用了Object的hashcode方法，我们的偏向锁就自动不可用了。如果我们的对象有了hashcode和分代年龄和是否为偏向锁（30位）。在轻量级锁的状态下，这30位会被复制到我们的轻量级锁线程持有者的栈帧里的lock record里边记录。与此同时，我们的对象的markword里边存放的是我们的指向轻量级锁线程持有者的栈帧的lock recod里。如果一直存在轻量级锁竞争，在未发生锁膨胀的前提下，一直会保持轻量级锁，A线程释放的时候，会将markword替换回对象的markword里边，B线程下次再从新走一遍displace mark word；一旦发生了轻量级膨胀为重量级锁。前提，A线程持有锁；B线程争抢。B线程将marikword里边A线程的指针替换成一个临时的（过度的）重量级锁指针，为了让A线程在cas往回替换markword的时候失败。A线程替换回markword失败后，会发起：1.初始化monitor对象；2. 将状态设置为膨胀中；3 将替换失败的 markword放到objectmonitro的head属性里； 4。改变markword的锁标志为10；将markword里的 30 位设置为指向自己第一步初始化的那个monitor对象；5唤醒B线程； 6以后这个对象只能作为重量级锁；Markword从未丢失。



## G. 死锁的产生条件与避免方式

死锁产生的四个必要条件：

互斥：一个资源每次只能被一个进程使用 (资源独立)。

请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放 (不释放锁)。

不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺 (抢夺资源)。

循环等待：若干进程之间形成一种头尾相接的循环等待的资源关闭 (死循环)。



如何避免？

2PL 一次获得所有锁，一旦释放，不能再申请

预防：2PL

检测：wait-for-graph，一旦发现成环，rolled back（cost、（开始）时间（预计结束）、可以解锁多少？、已经被absirt多少次了？）

超时：时间长，减少错误判断，但是死锁可能存在很久了，时间短，错误多，但是死锁存在时间短。





破坏” 互斥” 条件：系统里取消互斥、若资源一般不被一个进程独占使用，那么死锁是肯定不会发生的，但一般 “互斥” 条件是无法破坏的，因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏 “互斥” 条件。2. 破坏 “请求和保持” 条件：

方法 1：所有的进程在开始运行之前，必须一次性的申请其在整个运行过程各种所需要的全部资源。优点：简单易实施且安全。缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。

方法 2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到，已经使用完毕的资源，然后再去请求新的资源。这样的话资源的利用率会得到提高，也会减少进程的饥饿问题。

方法3. 破坏 “不剥夺” 条件：当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂的释放或者说被抢占了。

方法4. 破坏 “循环等待” 条件：可以通过定义资源类型的线性顺序来预防，可以将每个资源编号，当一个进程占有编号为 i 的资源时，那么它下一次申请资源只能申请编号大于 i 的资源。



现在我们介绍避免死锁的几个常见方法。·避免一个线程同时获取多个锁。·避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。·尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。·对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。



## objectmonitor的属性

header ： 重量级锁保存markword的地方

own: 指向我们持有锁的线程；对象的markword里边也保存了指向monitor的指针；

 _cxq 队列： 竞争队列。 A线程持有锁没有释放； B和C线程同时过来争抢锁，都被block了，此时会将B和C线程加入到 该队列。

EntryList队列：同步队列。A线程释放锁，B和C线程中会选定一个继承者（可以去争抢锁的这个线程），另外一个线程会被放入我们的EntryList队列里边。 

waitset：等待队列。Object wait的线程。A线程持有锁，BC线程过来竞争失败，进入cxq -- 下轮竞争会把 cxq里的线程移动到EntrylIst中。假设B线程竞争到了锁，然后B线程调用了 Object.Wait方法，这时候B线程进入waitset，并释放锁。C线程拿到了锁，然后唤醒B线程。B线程会从waitset里边出来，直接竞争锁。如果竞争失败进入cxq，继续轮回，如果竞争成功，ok了。



## 用户态与内核态

内核态：1. 系统中既有操作系统的程序，也有普通用户程序。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行！2. 内核态可以使用计算机所有的硬件资源！

用户态：不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！

当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为 3 级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3 状态不能访问 Ring0 的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为 0 级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。

用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过 write、send 等系统调用，这些系统调用会调用内核的代码。进程会切换到 Ring0，然后进入内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到 Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。



用户态切换到内核态的条件

当在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。用户态切换到内核态的 3 种方式

（1）系统调用这是用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。例如 fork（）就是执行了一个创建新进程的系统调用。系统调用的机制是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。

（2）异常当 cpu 在执行运行在用户态下的程序时，发生了一些没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。

（3）外围设备的中断当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令而转到与中断信号对应的处理程序去执行，如果前面执行的指令时用户态下的程序，那么转换的过程自然就会是 由用户态到内核态的切换。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。这三种方式是系统在运行时由用户态切换到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。从触发方式上看，切换方式都不一样，但从最终实际完成由用户态到内核态的切换操作来看，步骤有事一样的，都相当于执行了一个中断响应的过程。系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本一致。



用户态到内核态的切换步骤

[1] 从当前进程的描述符中提取其内核栈的 ss0 及 esp0 信息。

[2] 使用 ss0 和 esp0 指向的内核栈将当前进程的 cs,eip,eflags,ss,esp 信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。

[3] 将先前由中断向量检索得到的中断处理程序的 cs,eip 信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。



# 三、Java内存模型｜重点

Java 内存模型指定了 Java 程序中的共享内存的访问规则。

它定义了:

1. 线程和主内存之间的关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。

2. 线程间的通信方式：共享内存
3. 不同线程对主内存中共享数据的访问方式

Java 内存模型的主要组成有:1. 主内存:存储共享变量的内存区域,所有线程都可以访问。2. 工作内存:每个线程都有一个工作内存,存储线程私有的变量和主内存中的共享变量的副本。线程对变量的所有操作都必须在工作内存中进行,然后主内存才能更新。3. 线程:执行程序的单元,通过工作内存与主内存交互。4. 缓存一致性:当一个线程修改了共享变量,其他线程看到的共享变量的值是最新的变化。这是由 Java 内存模型的 Happens-Before 原则来保证的。

Java 内存模型规定:1. 线程间的通信方式为主内存。线程对共享变量的所有操作都必须在自己的工作内存和主内存之间同步。2. 每个线程都有一个私有的工作内存,里面保存了该线程使用的变量的主内存副本。线程对变量的所有操作都必须在工作内存中进行,之后再同步到主内存。3. 不同的线程可以同时执行 lock free 操作(没有锁的同步操作),但是遵循 happens-before 的原则。这保证了在没有锁的情况下,线程也可以观察到其他线程对共享变量的更新。4. 线程间可以使用 volatile 关键字和 lock 同步来确保可见性和有序性。5. 线程对主内存的访问可以在编译期和运行期重排序,但是不会与 happens-before 关系相违背。这保证了最终一致性。所以总结来说,Java 内存模型定义了线程和主内存之间以及线程间的交互规则,它将线程与主内存的通信方式规范为主内存,并使用 happens-before 等规则来保证内存可见性和有序性,最终实现内存一致性和线程安全。

Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行

堆内存在线程之间共享

线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。 

## 指令重排序

![image-20230514211032339](/Users/shengquan/my_website/content/posts/并发.assets/image-20230514211032339.png)



**编译器优化的重排序**：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

**指令级并行的重排序**：现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

**内存系统的重排序**：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。



对于处理器重排序，JMM的处理器重排序规则会要求Java**编译器**在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。



## 内存屏障

![image-20230514211155651](/Users/shengquan/my_website/content/posts/并发.assets/image-20230514211155651.png)

LLSSLSSL

L读取/装载

S刷新到内存

StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。



## as-if-serial

不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。

为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在**数据依赖关系**，这些操作就可能被编译器和处理器重排序。

## happens-before

意义：提高程序执行的并行度。

定义：

1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。

2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。



happens-before关系本质上和as-if-serial语义是一回事。

as-if-serial讲的是单线程

happens-before讲的是正确同步的多线程



1）程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。

2）监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。

3）volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。

4）传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。

5）start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。

6）join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。

两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前



## 锁的内存语义

JMM是基于共享内存的，所以是隐式通信。（理解）

本质上是消息的传递

·线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。

·线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。

·线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。（隐式通信）





# 四、volatile｜重点

## brief

围绕两句话展开：保证可见性、禁止指令冲排序。

volatile，保证所有线程看到这个变量的值是一致的。

为什么会不一致？因为多级缓存（L1、L2、L3），如果读到了，可以直接返回，所以读多写少的话性能很好。

缓存命中（读缓存行）、写命中（写缓存行）



## 可见性实现机制

对于volatile写操作，在汇编层面添加lock前缀的指令，做两件事1.缓存行写回内存；2.其他缓存行无效

lock，锁总线，先进的处理器会锁内存区域，改哪里锁哪里，并且使用缓存一致性协议阻止多处理器同时修改缓存。

其他处理器嗅探查看自己的缓存是否过期，如果过期，则自己的缓存行无效。

为此引出了一个volatile用法优化，有了一个相关的优化思路，比如如果有一个双向队列，要频繁的出队入队。强行padding到64字节，为了保证头尾节点不会被一起加载进缓存行，修改时不会互相锁定。（优化要求：频繁写，64字节的缓存行）

进而有一个神奇的注解，那就是@sun.misc.Contended

伪共享问题出现在以下场景：

1. 多个核心（或线程）在同一时间读写不同的变量。
2. 这些变量恰好位于同一个缓存行上。
3. 当一个核心修改它所在缓存行上的一个变量时，整个缓存行都被标记为无效。
4. 因此，其他核心在访问它们各自的变量时，需要从主内存重新加载整个缓存行，即使它们并没有真正共享任何数据。

而被@sun.misc.Contended标记的字段，会被填充到一个缓存行大小，避免伪共享。



## 禁止指令重冲排序

下面是基于**保守策略**的JMM内存屏障插入策略。·

在每个volatile写操作的前面插入一个StoreStore屏障，写volatile前其他写已经完成（完成指刷入主存）

在每个volatile写操作的后面插入一个StoreLoad屏障，写volatile后，修改可见（不是在volatile前面加内存屏障，因为volatile常见使用是单写+多线程读volatile，所以要在单后加而不是多前加）

在每个volatile读操作的后面插入一个LoadLoad屏障，读volatile后，再读其他的

在每个volatile读操作的后面插入一个LoadStore屏障，读volatile后，再写其他的

而new一个对象是写啊，会加上storestore以及storeload屏障，所以



非保守策略：按需求省略四个屏障中的几个



为什么是volatile和其他？

```java
// 2341和1234会产生不同的结果i== 0 || 1
class VolatileExample {
  int a=0;
	volatile boolean flag = false;
  public void writer() {
    a = 1;//1
		flag = true;// 2
	public void reader () {
    if (flag) {//3
    int i = a;//4
   }
}
    
写前不能冲排序，读后不能冲排序，写读不能重排序
·当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。
·当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。
·当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。

```

volatile的禁止指令重排序使用：双重检查锁。（为什么要双重检查？sychronized下推因为避免频繁的获得锁。为什么要用volatile？禁止指令重排序。

ps：双重检查锁之外，还有静态内部类，这里使用的是类加载的初始化期间，获得Class对象初始化的锁的线程进行创建对象。



# 五、Lock全解读｜重点

通过Lock+AQS实现定制化锁，程序员拥有更多的掌控权，并且使用CAS实现修改，较轻。

所以Lock也分成两个部分，Lock和AQS

## 1、AQS

### 底层原理

同步队列完成资源获取的排队（head可以直接设置，但是并发环境下，多个线程同时竞争失败，需要添加到tail，则需要cas来实现tail的设置，头节点不需要cas，因为设置head的线程是获得锁的线程，只有一个线程）

`int state`来记录状态

通过**继承**AQS作为子类的方式实现同步，在实现抽象方法过程中，对`state`的操作，包括`getStste();`and `setState(int new State);`and `compareAndSetState(int except, int update);`。AQS只提供了若干同步状态获取和释放的方法，支持独占也支持共享。



设计基于模版方法模式，即要继承AQS并且重写AQS中的部分方法。可以重写的有

```java
// 独占
protected boolean tryAcquire(int arg)
protected boolean tryRelease(int arg)
protected boolean isHeldExclusively()// 查看当前线程持有锁
// 共享
protected int tryAcquireShared(int arg)
protected boolean tryReleaseShared(int arg)
```

这几个方法会被AQS的模版方法调用。



### 具体实现

ReentrantLock就是一个实现





## 2、Lock

# 六、原子操作｜重点

基本类型、数组类型（创建传入会copy）、引用类型、引用类型中的字段

引用类型中的字段：upUpdater创建更新器。对于要修改的字段，需要使用public volatile进行修饰



LongAdder，高并发，通过Cell[]来实现线程分散，Cell是sun.misc.Contended修饰的，所以会被扩充成64字节，也就是一个缓存行大小，避免了伪共享。



# 七、并发工具类｜重点

## 1、CountDownLatch

**使用场景**

启动准备，如加载配置、初始化连接池、预热缓存等

多线程计算，等待所有结果汇总

测试并发



## 2、 CyclicBarrier







# 八、Java阻塞与非阻塞队列





# 九、线程池与executor框架｜重点







# 十、常见问题思考

如何实现线程同步？

**线程同步**:

- `synchronized`关键字: 可以应用于方法或块。
- `ReentrantLock`: 一个可重入的互斥锁，与synchronized的基本行为相同，但具有扩展功能。
- `Semaphore`: 一个计数信号量，用于控制访问资源的线程数量。
- `CountDownLatch`: 允许一个或多个线程等待其他线程中的一组操作完成。
- `CyclicBarrier`: 允许一组线程互相等待，直到达到一个公共的屏障点。
- `Phaser`: 一个灵活的屏障实现。
- `Exchanger`: 允许两个线程交换数据。



如何实现线程安全？

**线程安全**:

- **不变性**: 不可变对象本质上是线程安全的。
- **Volatile**: 保证了变量在线程间的变化的可见性。
- **原子操作**: 像`AtomicInteger`、`AtomicReference`这样的类提供原子操作支持。
- **并发数据结构**: 像`ConcurrentHashMap`、`CopyOnWriteArrayList`这样的类被设计为并发使用。

除了上面还有什么吗？

- **线程局部存储**: 使用`ThreadLocal`类，每个线程访问变量的独立实例。
- **StampedLocks**: 通过提供乐观读取，对`ReadWriteLock`进行了优化。
- **监视器模式**: 在对象内部封装同步。
- **Actor模型**: 一个更高级的并发模型，其中actor发送和接收消息，确保没有共享状态。



